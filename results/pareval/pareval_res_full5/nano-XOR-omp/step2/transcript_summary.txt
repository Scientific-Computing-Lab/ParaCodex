**Summary**
- `cellsXOR` now takes `__restrict__` pointers, keeps `N` in a local `width`, and caches `row`/`idx` per iteration so the OpenMP target loop mirrors the CUDA 2D grid while avoiding repeated multiplications; this tightened stencil body is defined at `data/src/nano-XOR-omp/nanoXOR.cpp:21`.
- Captured the runtime/GPU/plan rationale in `optimization_plan.md:1`, including the ~0.03s baseline, the ~0.02s post-optimization timing, and the decision to stay within micro-optimizations because the profile lacked GPU kernel stats.
- `data/src/nano-XOR-omp/profile.log:1` only lists OS-level `wait`/`posix_spawn` entries (no GPU kernel or memcpy rows), so the early-exit check could not prove the run was within 5% of an “expected optimal” CUDA kernel time.
- Tests: `make -f Makefile.nvc clean`; `timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make -f Makefile.nvc run`; `env OMP_TARGET_OFFLOAD=MANDATORY time ./nanoXOR.exe 1024 32`.

Next steps
1. Re-profile with `nsys` (e.g., explicitly requesting CUDA kernel tracing) to confirm the OpenMP target loop is truly offloading and to collect kernel/mem timings before attempting larger restructuring.