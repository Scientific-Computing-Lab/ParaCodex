**Changes**
- offloaded the `cellsXOR` stencil through `#pragma omp target teams loop collapse(2)` with `is_device_ptr` so the same `i,j` space is traversed on the device without CUDA-specific intrinsics (`data/src/microXOR-omp/microXOR.cpp:5`).
- reworked the driver to drop `cuda` allocations/copies, wrap `cellsXOR` in a single `#pragma omp target data map(...)` region, and keep cleanup focused on host buffers; the shader still validates and emits the gate checksum (`data/src/microXOR-omp/main.cpp:6`, `data/src/microXOR-omp/main.cpp:42`).
- captured the planned Strategy A data movement and host/device transfers in `data_plan.md` and kept a snapshot of the original CUDA driver at `main.cpp.bak` for reference (`data/src/microXOR-omp/data_plan.md:1`, `data/src/microXOR-omp/main.cpp.bak#L1`).

**Testing**
- `make -f Makefile.nvc clean` (pass)
- `env OMP_TARGET_OFFLOAD=MANDATORY make -f Makefile.nvc` (pass; compiles with `-cuda` flags but now the code only uses OpenMP offload)
- `env OMP_TARGET_OFFLOAD=MANDATORY timeout 300 make -f Makefile.nvc run > gpu_output.txt 2>&1` (pass; run output shown in `data/src/microXOR-omp/gpu_output.txt:1`)
- `diff baseline_output.txt gpu_output.txt` (fails because `baseline_output.txt:1` contains the old nvcc compile log lines and `baseline_output.txt:5` records a different gate checksum; the new run reports `GATE:SUM ... value=9fb94cb21ac542c3` instead of the previous value, reflecting the random input seed)

Next steps:
1. Capture a deterministic baseline (e.g., fixed RNG seed) or regenerate the reference gate checksum so future diffs match the OpenMP run.
2. If permitted later, update the build wrappers to drop CUDA-specific compiler flags and switch to an OpenMP-capable toolchain so the translation no longer depends on `nvcc` stitching.