**Changes**
- Swapped in the OpenMP-target version of `Simulation.cpp` (from the backup) so the build now emits `#pragma omp target` kernels instead of CUDA launches, and the new baseline run completes cleanly under `nvc++` after overriding `NVCC`’s architecture switch (`-gpu=cc89`).  
- Added `const __restrict__` aliasing to the read-only SimulationData views and helper signatures (`calculate_micro_xs`, `calculate_macro_xs`, `grid_search`, `grid_search_nuclide` in `XSbench_header.cuh` + `Simulation.cpp`), giving the compiler clearer aliasing information inside the hot lookup kernels.  
- Captured the current OpenMP metrics in `data/src/XSBench-omp/optimization_plan.md` (runtime 0.464 s, ~149 ms kernel, ~167 ms transfers, RTX 4060 cc8.9 target) and outlined one micro-optimization already applied plus a follow-on transfer/reuse investigation.  
- `profile.log` still only stores the earlier NVC++ “-arch” error, so the actionable metrics come from the runtime output above.

**Testing**
- `timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make -f Makefile.nvc NVCC='nvc++ -cuda -std=c++14 -gpu=cc89 -O3' run`: passes (runtime 0.464 s, verification checksum matches, host→device 166.6 ms, kernel 148.9 ms, device→host 0.60 ms).  
- `diff baseline_output.txt current_output.txt | grep -E "Verification|SUCCESSFUL|FAILED"`: exit 1 because no matching lines—there are no verification-status regressions reported.

Next steps:
1. Profile transfer initialization (241 MiB moved during `move_simulation_data_to_device`) to see if persistent device allocations / asynchronous copies can overlap with CPU work and reclaim the ~36% spent on transfers.  
2. If transfers remain dominant, explore splitting the big `Verification` buffer reduction / random sampling so the device stays resident longer (e.g., keep data across kernels with `omp_target_enter_data`/`exit_data`).