Swapped the CUDA flow for an OpenMP target-data + target-teams/loop offload so the stencil still runs on the (RTX 4060) GPU while the host-side validation stays intact.

- Captured the chosen Strategy A plan (allocations, transfers, kernel mapping, and migration risks) before touching code so it can guide future tweaks (`data_plan.md:1`).  
- Reimplemented `cellsXOR` as a host function that wraps a `#pragma omp target teams loop collapse(2)` over the original NxN domain, keeping the stencil logic unchanged (`main.cpp:22`).  
- Wrapped the offload in a `#pragma omp target data map(to: input[0:totalElements]) map(from: output[0:totalElements])` scope so the input/output grids stay resident on the device without any CUDA APIs while the host still owns the buffers (`main.cpp:75`).  

- Tests: `make -f Makefile.nvc clean`, `make -f Makefile.nvc`, `timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make -f Makefile.nvc run > gpu_output.txt 2>&1`; `Validation passed.` printed. `diff baseline_output.txt gpu_output.txt` only flags the missing nvcc compile lines (the actual program output still matches).

Next steps:
1. Collect profiling data via the provided `nsys profile` command (with `OMP_TARGET_OFFLOAD=MANDATORY`) to confirm the target kernel sees device execution.
2. If needed, re-run the workload with different seeds/N parameters in `gpu_output.txt` to verify consistent validation across cases.