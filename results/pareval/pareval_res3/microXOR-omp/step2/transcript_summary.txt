Cached row and neighbor pointers inside `cellsXOR` so the inner loop reuses precomputed offsets rather than redoing `i * N`, aligning with the requested micro-optimizations while keeping the original collapse/map strategy and documenting the tight GPU/mem metrics that justify only touching the kernel.

**Changes**
- Logged the current runtime (≈0.28s), single offload kernel, and 2.1ms of transfers in `optimization_plan.md:1`, then noted that only micro-padding is worth pursuing because the kernel is already just 32µs of GPU work.
- Cached `row`, `north`, `south`, and `outRow` pointers inside the target loop so the inner loop avoids repeated index math while leaving the collapse directive intact (`microXOR.cpp:8` for pointer setup and `microXOR.cpp:14` for the inner loop).
- Left the existing data-mapping region untouched (`main.cpp:50`), so the OpenMP target data strategy mirrors the baseline.

**Testing**
- `make -f Makefile.nvc clean`
- `timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make -f Makefile.nvc run > current_output.txt 2>&1`
- `/usr/bin/time -p env OMP_TARGET_OFFLOAD=MANDATORY ./microXOR.exe 1024 32` (reports ~0.33s real, validation still passes)

**Next Steps**
1. Profile the CPU-side RNG/validation path that generates the ~650ms wait time shown in `profile.log:135` if a faster end-to-end run is later required, since the GPU kernel is already negligible.