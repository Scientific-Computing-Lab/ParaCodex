Cached the row pointers inside `cellsXOR` so each inner iteration reuses a precomputed row base and neighbor pointers instead of recomputing `i*N + j` every time, keeping the single `target teams loop` and data-mapping strategy intact (`microXOR.cpp:3-23`). The profiling-driven plan now captures the transfer-heavy bottleneck and the micro-optimization + final summary in `optimization_plan.md:3-52`, citing the RTX 4060 (sm_89) characteristics and the existing `profile.log`.

Tests:
- `make -f Makefile.nvc clean`
- `timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make -f Makefile.nvc run > current_output.txt 2>&1`
- `diff baseline_output.txt current_output.txt | grep -E "Verification|SUCCESSFUL|FAILED"` (no matching lines, so the output still matches the baseline)

Suggestions:
1. If you can revisit the data strategy later, consider persisting `input`/`output` on the device via `omp_target_alloc`/`is_device_ptr` so those two 4 MB transfers aren’t paid every run.