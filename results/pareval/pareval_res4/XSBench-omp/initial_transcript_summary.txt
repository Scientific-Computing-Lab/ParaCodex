- Documented the CUDA loop/kernel hierarchy, kernel types, device data summaries, and OMP migration considerations in `data/src/XSBench-omp/analysis.md:1` so the baseline and each optimization path are fully described for future translation work.
- Copied `Simulation.cu` from the golden tree into `data/src/XSBench-omp/Simulation.c:1`, keeping the CUDA logic intact while switching the include to `XSbench_header.h` so it matches the host-focused headers already used elsewhere.
- Captured a fresh `make -f Makefile.nvc run` output sequence in `golden_labels/src/XSBench-cuda` and copied the redirect to `data/src/XSBench-omp/baseline_output.txt:1` for reference.

Tests:
- `make -f Makefile.nvc clean` (in `golden_labels/src/XSBench-cuda`)
- `make -f Makefile.nvc run > baseline_output.txt 2>&1` (in `golden_labels/src/XSBench-cuda`)

Next steps:
1. Use the loop classification in `analysis.md` as the blueprint for the eventual OpenMP kernels, starting with the CRITICAL `xs_lookup_kernel*` paths that dominate runtime.
2. Begin porting the per-material partition/sort strategy (optimizations 2â€“6) to CPU-side data structures, keeping the offset bookkeeping described in the analysis when reifying those kernels in OpenMP.