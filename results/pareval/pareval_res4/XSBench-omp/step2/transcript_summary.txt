Lowered the per-thread RNG/lookup bookkeeping while capturing the profiling rationale and outcomes in the requested plan file.

- Added a static `pick_mat_cdf` table and rewrote `pick_mat` to do a single threshold scan instead of rebuilding `dist[]` and running the nested prefix loop per thread (see `Simulation.c:97` and `Simulation.c:280`), reducing RNG overhead on the GPU.
- Tagged `evaluate_lookup`, `calculate_macro_xs`, and `calculate_micro_xs` with `__restrict__` pointers (and mirrored the prototypes in `XSbench_header.h:88`) so the compiler can assume the big lookup buffers don’t alias and emit tighter loads/stores inside the target kernels (`Simulation.c:105`‑`223`).
- Logged the profiling numbers, hypotheses, and the final performance summary in `optimization_plan.md` (starting from `optimization_plan.md:3` for the metrics and `optimization_plan.md:19` for the final summary/checklist).

Tests:
- `make -f Makefile.nvc clean`
- `timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make -f Makefile.nvc run` → Runtime 0.195 s with 100k lookups (514,101 lookups/s) and `host_to_device_ms=161`, `kernel_ms=3.000`, `device_to_host_ms=0.999` (`current_output.txt:47-53`).

Next steps: Think about reducing the 160–200 ms host→device mapping cost (e.g., persistent `omp_target_alloc` buffers or batching) since it still dominates the runtime even after the micro-optimizations documented in the plan file (`optimization_plan.md:52-61`).