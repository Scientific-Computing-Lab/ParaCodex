- Cached the per-row stride/index math and switched to `#pragma omp distribute parallel for collapse(2)` so the RTX 4060 (cc 8.9) offload reuses a single linear index for all neighbor checks while keeping the teams/threads mapping canonical.

- **Code** `microXOR.cpp:3-34`: add a `stride` constant, compute `idx = i * stride + j` once per inner iteration, re-use `idx ± stride/1` for neighbor accesses, and run the collapsed loops under `target teams distribute parallel for collapse(2)` with the existing `thread_limit`; comment explains the cached linear index.

- **Plan** `optimization_plan.md:1-18`: records the GPU/kernel/mem metrics, marks transfers and kernel micro-opts as the bottlenecks, and documents the two micro-optimizations that were executed.

- **Tests** `cd .../microXOR-omp && make -f Makefile.nvc clean`; `cd .../microXOR-omp && timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make -f Makefile.nvc run > current_output.txt 2>&1`; `diff baseline_output.txt current_output.txt | grep -E "Verification|SUCCESSFUL|FAILED"` (no verification/SUCCESSFUL/FAILED lines appeared, keeping validation aligned with the baseline run).

Next steps:
1. Re-profile with `nsys` (or equivalent) to verify whether the cached-index change changes the kernel versus transfer footprint recorded in `profile.log`.
2. If H↔D copies still dominate, consider keeping the buffers persistently mapped on the device (e.g., `omp_target_alloc` + `is_device_ptr`) so transfers happen only once per program run.