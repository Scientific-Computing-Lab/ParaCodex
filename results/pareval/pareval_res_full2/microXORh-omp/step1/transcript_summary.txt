**OpenMP Migration**
- Removed all CUDA runtime calls and rewrote the former `cellsXOR` kernel as a host function that launches the work using `#pragma omp target teams loop collapse(2)`, letting the GPU process every `(i,j)` pair while keeping the neighbor-counting logic identical (see `data/src/microXORh-omp/main.cpp:1-34`).
- Wrapped the host buffers in an OpenMP `target data map` region so that `input` and `output` stay resident on the device through the offload, while the rest of `main` (argument validation, random initialization, validation pass, cleanup) stayed largely the same except for removing device pointers and CUDA-specific cleanup (`main.cpp:41-110`).
- Captured the migration analysis in `data/src/microXORh-omp/data_plan.md` and kept the original source backed up as `main.cpp.bak` for reference.

**Testing**
- `make -f Makefile.nvc clean` (pass)
- `make -f Makefile.nvc` (fails: `nvc++` reports `NVC++ does not support NVCC’s device architecture targeting options. … use -gpu=ccXX instead`, so the current Makefile’s `-arch=sm_89` flag prevents the OpenMP build; no binary was produced, so `make run` was skipped and the `OMP_TARGET_OFFLOAD=MANDATORY` run could not be performed)

Next steps
1. Adjust the build flags (e.g., switch to `-gpu=cc89` or drive the compile with a CUDA-first toolchain) so `nvc++` can emit the OpenMP offload binary from `main.cpp`.
2. Once the binary builds cleanly, execute `OMP_TARGET_OFFLOAD=MANDATORY make -f Makefile.nvc run` and diff the output against `baseline_output.txt` to ensure the OpenMP variant matches the CUDA reference.