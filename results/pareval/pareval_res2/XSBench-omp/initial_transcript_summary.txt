Converted `Simulation.cu` into `data/src/XSBench-omp/Simulation.c` (the only allowed source change) by keeping the CUDA logic intact but pointing it at `XSbench_header.h`, then captured the golden baseline run and documented the kernel/loop structure for future OMP work.

- `data/src/XSBench-omp/Simulation.c` now mirrors the CUDA original, so the existing Makefile can compile against the CPU headers without touching any other sources.
- `make -f Makefile.nvc clean` && `make -f Makefile.nvc run > baseline_output.txt 2>&1` was executed in `golden_labels/src/XSBench-cuda/`, and the resulting `baseline_output.txt` was copied to `data/src/XSBench-omp/baseline_output.txt` for comparison.
- `data/src/XSBench-omp/analysis.md` captures mappings, host/kernel nesting, per-kernel details (Types A/B, device loops, dependencies, `thrust` usage, RNG helpers), a summary table, CUDA-specific notes, and OMP migration strategy hints so the translation team can proceed methodically.

Next steps:
1. Use the analysis to guide OpenMP rewrites of each `xs_lookup_kernel_*` (stepping through the classification table and respecting the material partitioning described in `analysis.md`).
2. Replace the CUDA-only thrust operations with CPU equivalents (`std::sort`/`std::partition`/OpenMP reductions) before wiring up the new `parallel for` kernels.
3. Re-interpret `SimulationData` transfers as host allocations so the OpenMP driver can reuse the same structs without CUDA helpers.