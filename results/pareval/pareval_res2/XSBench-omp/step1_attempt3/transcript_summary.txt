**Build Blocked**

- Tried translating `Simulation.c` to OpenMP-target code that treats the CUDA-style data structures as persistent device buffers (`omp_target_alloc` + `use_device_addr`/`is_device_ptr`) so the existing kernels could run with `target teams loop` just like the CUDA launches.
- Every compile attempt with `nvc++` failed: the compiler rejects `is_device_ptr/use_device_ptr/use_device_addr` when attached to `target teams( loop )`, so I couldn’t inform it that the `SimulationData` pointers already point to device memory. Repeated errors like `expected a ")"` at the first pointer in the clause and “this kind of pragma may not be used here” stopped the build before the baseline kernel even compiled.
- Because of those blockers I rolled `Simulation.c` back to the supplied `.bak` version to avoid leaving a broken file; there are no net source changes right now.

**Next Steps**
1. Confirm whether you want to keep trying to keep the data resident on the device (which requires a compiler that supports `is_device_ptr`/`use_device_addr` with `target teams loop`), or if it’s acceptable to offload the host arrays with `map(...)` verbatim copies (so we can write `target teams loop` pragmas that pass host arrays directly).
2. If you want to proceed with explicit mapping, I can rework the kernels to use the host `SimulationData` arrays, add `map` clauses for each buffer, and drop the device-pointer allocation helpers.