**Summary**
- Documented the measured runtime, transfer breakdown, hypotheses, and final conclusions in `optimization_plan.md:1-52`, so the analysis + micro-optimization record is readily available alongside the final summary template.
- Tightened the cross-section helpers by const-qualifying the prototype/signature Pointers in `XSbench_header.cuh:73-109` and `Simulation.cpp:107-319`, and cached each material’s `mats`/`concs` slice/`num_nucs` before the inner loop so the compiler does fewer repeated offset calculations while still keeping the CUDA/OMP flow intact.
- Regenerated the profile data via `./XSBench -m event -s small -l 100000 --csv profile.log` so `profile.log:1-2` now reflects the host→device 260.7 ms and kernel 153.5 ms split, and verification still reads `299541 (Valid)` in `current_output.txt:60`.

**Testing**
- `make -f Makefile.nvc clean`
- `timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make -f Makefile.nvc run > current_output.txt 2>&1`
- `timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY ./XSBench -m event -s small -l 100000 --csv profile.log > manual_output.txt 2>&1`
- `diff baseline_output.txt current_output.txt | grep -E "Verification|SUCCESSFUL|FAILED"` (no verification/SUCCESSFUL/FAILED differences observed)

**Next Steps**
1. Investigate reducing the ~260 ms host→device copy (e.g., keep the geometry/material buffers persistently mapped or overlap the memcpy with warmup work) so the transfer no longer dominates total runtime.
2. If further kernel work is needed, consider batching the sampling/lookup stages or pushing lookup loops into a single target region to mirror CUDA’s fused launch structure while preserving the current correctness checks.