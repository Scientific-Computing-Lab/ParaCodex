- Reworked the kernel into a host function that now uses `#pragma omp target teams loop collapse(2)` with `map(to: input[0:total]) map(from: output[0:total])` so `cellsXOR` runs as an OpenMP offload loop rather than a CUDA kernel (`microXOR.cpp:3-26`).
- Simplified the driver to operate purely on host buffers, removed every CUDA API call, and invoke the new helper directly; validation, checksum, and cleanup now only touch the CPU copies while still honoring the original `blockEdge` checks (`main.cpp:3-81`).
- Recorded the CUDA-to-OpenMP strategy in `data_plan.md:1` (device allocations/transfers and Strategy A rationale) and saved the original CUDA `main` as `main.cpp.bak:1` before rewriting it.
- Updated the nvcc-based Makefile to build with `nvc++ -gpu=cc$(SM) -mp=gpu` so OpenMP target offload compiles cleanly on the systemâ€™s Ada Lovelace GPU, and removed the unused CUDA linker flag (`Makefile.nvc:2-35`).
- Tests: `make -f Makefile.nvc clean`, `make -f Makefile.nvc`, `timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make -f Makefile.nvc run > gpu_output.txt 2>&1` (see runtime log in `gpu_output.txt:1-3`), and `diff -u baseline_output.txt gpu_output.txt` (the only differences are that the baseline file records the prior `nvcc` compile commands and a different `GATE:SUM` checksum because every run seeds the RNG differently even though the validation message matches).
  
Suggestions:
1. Seed the RNG deterministically (or capture a fixed input) so the `GATE:SUM` line stabilizes and the diff with `baseline_output.txt` only reflects the planned output changes.
2. After stabilizing functional parity, run the suggested `nsys` profiling command with `OMP_TARGET_OFFLOAD=MANDATORY` to confirm the OpenMP offload kernels reach the GPU as expected.