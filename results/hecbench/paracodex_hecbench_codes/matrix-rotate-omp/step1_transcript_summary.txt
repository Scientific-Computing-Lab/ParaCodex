**Updates**
- Offloaded the measured hotspot `rotate_matrix_parallel` loop nest to the RTX 4060 Laptop GPU (cc 8.9 per `system_info.txt`) using `#pragma omp target teams distribute` plus an inner `#pragma omp parallel for`, while mapping the entire `n*n` matrix each sweep and preserving the layered swap math (`data/src/matrix-rotate-omp/main.cpp:6-33`). This keeps the host timing code intact but now executes each repeat on the GPU with team/thread level parallelism matching the SM/warp structure of the Ada GPU.
- Applied the same GPU offload pattern to the reference `rotate_matrix_serial` implementation so every verification pass also runs through the OpenMP target runtime, guaranteeing the hot serial loop respects the mandatory offload requirement (`data/src/matrix-rotate-omp/main.cpp:36-55`).
- Cleaned up host-side initialization/verification loops while retaining the original problem sizes and data types (`data/src/matrix-rotate-omp/main.cpp:57-95`).

**Profiling**
- Ran `FORCE_OMP_GPU=1 OMP_TARGET_OFFLOAD=MANDATORY nsys profile --stats=true --trace=cuda,osrt --force-overwrite=true -o nsys_profile make -f Makefile.nvc run` (after `make -f Makefile.nvc clean`). The build, run (`./main 500 25`), and Nsight Systems capture all completed with exit code 0, reporting `Average kernel execution time: 0.000455 (s)` and `PASS`. The traces are in `data/src/matrix-rotate-omp/nsys_profile.nsys-rep` and `.sqlite` for further analysis.

**Next Steps**
1. Inspect the generated Nsight report to check team/thread occupancy and memory-transfer overhead; consider introducing an outer `target data` region to keep the matrix resident if transfers dominate.
2. Vary problem sizes/repeat counts to ensure the GPU kernels remain numerically stable and to gather baseline metrics for subsequent optimization steps.