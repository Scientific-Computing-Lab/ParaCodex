Applied a persistent device mapping so the host/device transfers happen just once per `conv1D` call: `#pragma omp target data map(to: mask[0:mask_width], a[0:input_width]) map(alloc: b[0:input_width])` now wraps the three kernel loops and pairs with `#pragma omp target update from(b[0:input_width])` before each validation/recording so the host copy stays current (`data/src/convolution1D-omp/main.cpp:220`, `data/src/convolution1D-omp/main.cpp:228`, `data/src/convolution1D-omp/main.cpp:240`, `data/src/convolution1D-omp/main.cpp:252`).  
Inside each kernel we reuse the mapped buffers with `map(present: â€¦)` clauses, preventing redundant remaps on every launch (`data/src/convolution1D-omp/main.cpp:82`, `data/src/convolution1D-omp/main.cpp:107`, `data/src/convolution1D-omp/main.cpp:148`).

Build notes: `make clean` has no rule in this directory, so it fails as documented; compilation with `make -f Makefile.nvc` succeeds.

Next steps:  
1. Re-run `ncu --target-processes all --section "SpeedOfLight" --launch-count 4 make -f Makefile.nvc run` to confirm the reduced transfer overhead shows up in profiling.  
2. If further tuning is needed, inspect the updated Nsight traces for remaining latency stalls before tackling compute-side optimizations.