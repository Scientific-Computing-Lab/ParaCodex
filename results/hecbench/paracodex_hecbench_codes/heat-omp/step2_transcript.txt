**Key Changes**
- Introduced a persistent device data environment in `data/src/heat-omp/main.cpp:87` so `u`/`u_tmp` stay resident on the H100 (CC 8.9), sharing `r`, `r2`, and `n` via `firstprivate` to eliminate per-step hostâ†”device copies.
- Kept the time-stepping stencil in a single target region (`data/src/heat-omp/main.cpp:92`) while reusing the mapped arrays with `map(tofrom: ...)`, preserving correctness through the existing ping-pong swap.
- Moved the L2-norm reduction into the same target-data scope (`data/src/heat-omp/main.cpp:111-126`) so the error metric is accumulated directly on the device and only the scalar result returns to the host.

**Build & Profiling**
- `make -f Makefile.nvc` (after the required clean) succeeds.
- `make -f Makefile.nvc run` aborts with `CUDA_ERROR_OPERATING_SYSTEM` while calling `cuInit`; GPU access appears blocked in this environment, so the executable itself was not validated.
- Once GPU access is restored, profile with `ncu --target-processes all --section "SpeedOfLight" --launch-count 4 make -f Makefile.nvc run`.

**Next Steps**
1. Resolve the host-side CUDA initialization issue so the run/profiling command can execute.
2. After confirming runtime access, rerun the `ncu` command above to measure the reduced transfer traffic.