Kept the GPU buffers resident for both kernels so we only move the geodesic data across PCIe once. In `main.cpp` I now wrap the GPU path in a single `target data` region using `map(to: input)` plus `map(alloc: output, expected_output)` and reuse those mappings for the reference kernel with `map(present: â€¦)` (data/src/geodesic-omp/main.cpp:312-330). After running the main kernel I issue one `target update` to stage both result arrays back to the host before verification, keeping host/device transfers to a minimum on the Ada Lovelace GPU (CC 8.9). In `distance_device` I inspect `omp_target_is_present` so we dispatch the offload either against the already-present device allocations or, if needed, fall back to a scoped `target data` map (data/src/geodesic-omp/main.cpp:95-231); this avoids redundant remapping when the caller has already established residency.

Next steps (if you want to validate performance):
1. `make clean && make -f Makefile.nvc`
2. `ncu --target-processes all --section "SpeedOfLight" --launch-count 4 make -f Makefile.nvc run`