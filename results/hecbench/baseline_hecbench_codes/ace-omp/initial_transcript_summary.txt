- Built a GPU-ready math/geometry layer with `#pragma omp begin declare target` helpers so gradients, anisotropy, divergence, and Laplacian are callable inside device regions without redundant recomputation (`data/src/ace-omp/main.cpp:21`, `data/src/ace-omp/main.cpp:33`, `data/src/ace-omp/main.cpp:80`, `data/src/ace-omp/main.cpp:88`).
- Translated the major kernels (`calculate_force`, `allen_cahn_step`, `thermal_step`, and both boundary operators) to OpenMP `target teams distribute parallel for collapse(3)` loops, keeping memory traffic coalesced along the fastest-varying z-dimension and reusing precomputed inverse grid spacings (`data/src/ace-omp/main.cpp:103`, `data/src/ace-omp/main.cpp:158`, `data/src/ace-omp/main.cpp:174`, `data/src/ace-omp/main.cpp:203`, `data/src/ace-omp/main.cpp:218`).
- Orchestrated the timestepper with persistent device residency: host pointers ping-pong between the two phi/u buffers, forces stay `alloc`-mapped, and a final `target update` copies only the active buffers back, mirroring the serial swap semantics while avoiding superfluous transfers (`data/src/ace-omp/main.cpp:298`, `data/src/ace-omp/main.cpp:324`, `data/src/ace-omp/main.cpp:340`, `data/src/ace-omp/main.cpp:356`).

Tests:
- `make -f Makefile.nvc clean`
- `make -f Makefile.nvc`
- `./main 0` (fails: `CUDA_ERROR_OPERATING_SYSTEM` â€“ GPU access unavailable in this environment)

Next steps:
1. Re-run `./main <steps>` (or profile with `ncu`) on a system with functional CUDA driver access to validate runtime.