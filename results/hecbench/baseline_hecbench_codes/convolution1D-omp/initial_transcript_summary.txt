Replaced the serial kernels with OpenMP target offload implementations backed by per-kernel data regions so inputs stay resident on the RTX 4060 GPU while we iterate for timing (`main.cpp:21-58`). Added a cooperative tiling kernel that stages halo data into per-team scratch space for coalesced reuse (`main.cpp:61-119`) and a cached variant that keeps both the tile and mask hot while falling back to global loads only for cross-tile elements (`main.cpp:121-195`). Introduced a compute-type selector to accumulate the int16_t path safely before casting back (`main.cpp:15-19,45-54,175-189`). Wrapped the executions in a reusable benchmarking helper that zeroes host buffers, times the offloaded run, and validates against the CPU reference (`main.cpp:222-295`). `make -f Makefile.nvc clean` and `make -f Makefile.nvc` now succeed in `data/src/convolution1D-omp`, with nvc++ confirming placement of the shared tiles in CUDA shared memory.

Next step you might consider:
1. Run `make -f Makefile.nvc run` to measure end-to-end runtime and confirm the PASS checks under your desired problem sizes.