GPU-offloaded the random access benchmark with persistent device data and atomic updates to preserve correctness under parallel execution.

- `data/src/randomAccess-omp/main.cpp:95` Introduced multi-stream partitioning of `totalUpdates` (up to 16K streams) and precomputed HPCC seeds so each GPU worker advances an independent contiguous segment of the RNG sequence.
- `data/src/randomAccess-omp/main.cpp:130` Wrapped the repeat loop in an OpenMP `target data` region with `alloc` mappings so the 512â€¯MB table and stream state stay resident on the GPU across iterations.
- `data/src/randomAccess-omp/main.cpp:138` Added a teams/threads kernel to reinitialize the table on device with static scheduling for coalesced writes.
- `data/src/randomAccess-omp/main.cpp:145` Implemented the GPU update kernel that advances each stream locally and uses `#pragma omp atomic update` on the XOR to avoid lost updates under collisions.
- `data/src/randomAccess-omp/main.cpp:171` Kept the host-side verification loop identical to the serial benchmark so the final correctness check matches the reference.

Build succeeded with `make -f Makefile.nvc` (after `make -f Makefile.nvc clean`). Next step: run `make -f Makefile.nvc run` or invoke `./main <repeat>` to validate runtime behavior on your workload.