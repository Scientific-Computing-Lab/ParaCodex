**Changes**
- `runTest_GPU` now caches `cols`/`penalty`, keeps the top-left wavefront inside a single `#pragma omp target teams num_teams(1) thread_limit(256)` kernel (`src/needle.cpp#L141`), and reuses the existing `target data` mapping so the Ada Lovelace RTX 4060 Ti described in `system_info.txt#L301` can keep its SMs busy with just one launch instead of exploding thousands of anti-diagonal kernels.
- The bottom-right sweep re-enters another persistent `#pragma omp target teams` kernel (`src/needle.cpp#L163`) that reuses the same `diag_len`/`pen` locals inside the inner `#pragma omp parallel for`, preserving the triangular dependency order while keeping the device touched no more than twice.
- Backups recorded at `data/src/nw-omp/src/needle.cpp.backup#L1` and `data/src/nw-omp/needle.cpp.backup#L1` per the workflow instructions.

**Testing**
- `OMP_TARGET_OFFLOAD=MANDATORY timeout 300 make -f Makefile.nvc CC=nvc++ CLASS=C run` (baseline output in `baseline_output.txt`: CPU 0.045914s, GPU 0.170036s).
- `OMP_TARGET_OFFLOAD=MANDATORY timeout 300 make -f Makefile.nvc CC=nvc++ CLASS=C run > gpu_output.txt` (post-change CPU 0.052703s, GPU 0.173421s, `compareResults` reports 0 mismatches).
- `diff baseline_output.txt gpu_output.txt` shows only the extra compile log lines plus the minor runtime difference, so correctness is unchanged.

**Next Steps**
- 1. Run the Class B `nsys` profiling recipe from Step 8 (clean, build with `CLASS=B`, and invoke the provided profiling command) to capture the new persistent-kernel timelines.
- 2. Optionally rerun the `OMP_TARGET_OFFLOAD=MANDATORY gate_sdk/scripts/gate_harness.py` `check-correctness` target to exercise the accelerated binary against the reference executable for additional validation.