**GPU Offload**
- Replaced `single_iteration_gpu` with two `#pragma omp target teams loop collapse(2)` kernels so the delta computation and result-to-temp copy both execute entirely on the GPU, keeping the original stencil logic and writing `result` and `temp` via `result[index] = curr_temp + delta` (`data/src/hotspot-omp/src/hotspot_openmp.cpp:36-117`).
- Wrapped the GPU simulation loop in a persistent `#pragma omp target data` region so `power`, `temp`, and `result` stay resident between iterations; the host now dispatches either the CPU or GPU loop branch (CPU path unchanged) and still emits the verbose iteration counter (`data/src/hotspot-omp/src/hotspot_openmp.cpp:223-247`).

**Build & Test**
- `cd data/src/hotspot-omp && make -f Makefile.nvc clean && make -f Makefile.nvc` (nvc++ emitted its usual warnings about the unused `t` variable and deprecated `char*` literal usage).
- `./main 512 512 2 4 input/temp_512 input/power_512` → CPU runtime 0.001405s, GPU runtime 0.151409s, zero mismatched cells; the output matches the baseline.

Next steps:
1. Profile the GPU kernel with `nsys` or a similar tool so thread limits/collapsed dimensions can be tuned for larger problem sizes.
2. Drive the validated build through the Gate harness (`gate_sdk/scripts/gate_harness.py`) or any regression suite that compares against `golden_labels` to ensure long-running stability.

OpenAI Codex v0.72.0 (research preview)
--------
workdir: /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir
model: gpt-5.1-codex-mini
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: medium
reasoning summaries: auto
session id: 019b3c22-e329-7390-84d6-a95a285e6cf9
--------
user
## First Step: Copy Source Files
Copy source files = - hotspot_openmp.cpp from /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/golden_labels/src/hotspot-serial to /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/hotspot-omp.

**Files:** - hotspot_openmp.cpp

**Your Task:**
1. Translate the code below to an OpenMP GPU-offloaded version.
2. Apply GPU offloading pragmas as needed. (`use teams loop` and not `teams distribute parallel for`)
3. Optimize the code for performance while preserving its original functionality.
4. make sure the code compiles with `make -f Makefile.nvc`, and runs with ./<executable
5. Deliver the modified code to /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/hotspot-omp.

**Deliverable:**
- The complete, modified source code for - hotspot_openmp.cpp in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/hotspot-omp, that can be compiled with `make CC=nvc++ CLASS=B` and runs with `./<executable>`.

** Rules **
- NO GIT COMMANDS.
- DO NOT READ/WRITE OUTSIDE THE WORKING DIRECTORY.
- ALWAYS CLEAN BEFORE BUILD.


mcp startup: no servers

thinking
**Checking system_info.txt**
exec
/bin/bash -lc pwd in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 4ms:
/home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir
exec
/bin/bash -lc ls in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
AGENTS.md
check_devices
check_devices.c
check_devices_mp
data
data_ParaCodex
data_plan.md
gate_sdk
golden_labels
optimization_plan.md
reference
results_perf_rodinia_nsys
serial_kernels_changedVars
strip_openmp.sh
system_info.txt

thinking
**Reading system information**
exec
/bin/bash -lc 'cat system_info.txt' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 11ms:
=== SYSTEM BASELINE ===
Linux cmhq-ext-shared-codex 6.14.0-35-generic #35~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Oct 14 13:55:17 UTC 2 x86_64 x86_64 x86_64 GNU/Linux
PRETTY_NAME="Ubuntu 24.04.2 LTS"
NAME="Ubuntu"
VERSION_ID="24.04"
VERSION="24.04.2 LTS (Noble Numbat)"
VERSION_CODENAME=noble
ID=ubuntu
ID_LIKE=debian
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
UBUNTU_CODENAME=noble
LOGO=ubuntu-logo
ldd (Ubuntu GLIBC 2.39-0ubuntu8.6) 2.39

=== FIRMWARE & MICROCODE ===
# dmidecode 3.5
Getting SMBIOS data from sysfs.

thinking
**Preparing to copy source file**
exec
/bin/bash -lc 'ls data' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
src

thinking
**Listing hotspot-omp directory contents**
exec
/bin/bash -lc 'ls data/src' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
backprop-omp
bfs-omp
b+tree-omp
common
hotspot-omp
input
lud-omp
nsys_profile.nsys-rep
nsys_profile.sqlite
nw-omp
srad-omp

thinking
**Checking for existing hotspot-omp file**
exec
/bin/bash -lc 'ls data/src/hotspot-omp' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
golden_serial
hotspot_omp.cpp
hotspot_omp.cpp.bak
input
log
Makefile.nvc
src

thinking
**Verifying file copy instructions**
exec
/bin/bash -lc 'ls golden_labels/src/hotspot-serial' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
input
log
main
Makefile.nvc
src

thinking
**Checking nested source directories**
exec
/bin/bash -lc 'ls golden_labels/src/hotspot-serial/src' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
hotspot_openmp.cpp
hotspot_openmp.o
Makefile
README
run

thinking
**Copying hotspot_openmp.cpp to data path**
exec
/bin/bash -lc 'cp golden_labels/src/hotspot-serial/src/hotspot_openmp.cpp data/src/hotspot-omp/hotspot_openmp.cpp' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:


thinking
**Preparing to inspect file for translation**
exec
/bin/bash -lc "sed -n '1,200p' data/src/hotspot-omp/hotspot_openmp.cpp" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include "../../common/rodiniaUtilFunctions.h"

#define STR_SIZE	256

/* mptogpu */
#define GPU_DEVICE 1
#define PERCENT_DIFF_ERROR_THRESHOLD 0.05

/* maximum power density possible (say 300W for a 10mm x 10mm chip)	*/
#define MAX_PD	(3.0e6)
/* required precision in degrees	*/
#define PRECISION	0.001
#define SPEC_HEAT_SI 1.75e6
#define K_SI 100
/* capacitance fitting factor	*/
#define FACTOR_CHIP	0.5
#define OPEN

thinking
**Requesting additional file content**
exec
/bin/bash -lc "sed -n '200,400p' data/src/hotspot-omp/hotspot_openmp.cpp" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 11ms:
 * transfer differential equations to difference equations 
 * and solves the difference equations by iterating
 */
void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
{
	#ifdef VERBOSE
	int i = 0;
	#endif

	double grid_height = chip_height / row;
	double grid_width = chip_width / col;

	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
	double Rz = t_chip / (K_SI * grid_height * grid_width);

	double max_slope = MAX_PD / (FACTOR_CHIP * t_chip * SPEC_HEAT_SI);
	double step = PRECISION / max_slope;
	double t;

thinking
**Converting code to OpenMP GPU offloading**

I’m focusing on transforming the existing CPU loop into an OpenMP GPU offloaded version using the `#pragma omp target teams loop` directive as instructed, avoiding `teams distribute parallel for`. I’ll check the `Makefile.nvc` to confirm compilation settings with `nvc++` and ensure necessary flags like `-fopenmp -mp` are included while using the rodinia utilities path properly.
exec
/bin/bash -lc 'cat data/src/hotspot-omp/Makefile.nvc' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 9ms:
#===============================================================================
# User Options
#===============================================================================

# Compiler can be set below, or via environment variable
CC        = nvc++
OPTIMIZE  = yes
DEBUG     = no
DEVICE    = gpu
SM        = cc89
LAUNCHER  =
GATE_ROOT ?= /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir
REF_DIR   ?= $(GATE_ROOT)/golden_labels/src/hotspot-serial
REF_BIN   ?= $(REF_DIR)/main
REF_MAKE  ?= Makefile.nvc

RUN_ARGS ?= 512 512 2 4 input/temp_512 input/power_512

#===============================================================================
# Program name & source code list



thinking
**Designing OpenMP GPU Offloading Strategy**

I'm planning how to apply OpenMP GPU offloading pragmas by restructuring the code to use `#pragma omp target data` for data mapping arrays on the device across iterations, and nested `#pragma omp target teams loop collapse(2)` for the core double loops. I want to minimize data transfers by keeping arrays resident on GPU and consider combining compute and copy loops while preserving the CPU version semantics. The approach balances correctness with GPU efficiency by managing data mapping, loop collapsing, and possible pointer swapping carefully.
thinking
**Clarifying GPU Kernel Execution and Compilation Steps**

I'm sorting out the need for two separate GPU kernels to avoid race conditions when updating `temp`, confirming use of `target teams loop collapse(2)` for both compute and copy loops, and planning how to manage data mapping with `target data` regions across iterations to minimize overhead. I’m also reviewing build commands and considering whether to create a detailed multi-step plan before implementation to ensure correctness and performance.
thinking
**Planning OpenMP GPU Kernel and Build Workflow**

I'm preparing to implement the GPU offload by applying `target teams loop collapse(2) thread_limit(256)` pragmas to the two main loops in `single_iteration_gpu`, while restructuring `compute_tran_temp` to wrap iterations in a persistent `target data` region to keep arrays mapped on the device. I’m also considering the build steps to clean and compile the code as per instructions, and I’ll draft a clear multi-step plan to organize these modifications systematically.
Plan update
  ✓ Move hotspot_openmp.cpp into the target workdir
  → Revise single_iteration_gpu to use OpenMP target teams loops (with collapse) and keep the temperature/result copy on-device
  • Add a persistent target data region around the GPU iterations in compute_tran_temp, then rebuild with make -f Makefile.nvc

thinking
**Restructuring GPU iteration and compute_tran_temp functions**
file update
M /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/hotspot-omp/hotspot_openmp.cpp
@@ -35,84 +35,85 @@
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
M data/src/hotspot-omp/hotspot_openmp.cpp
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..cf0cf2e13749add5feb921d611044dad094dc464
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,


thinking
**Restructuring compute_tran_temp function**
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..cf0cf2e13749add5feb921d611044dad094dc464
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,

file update
M /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/hotspot-omp/hotspot_openmp.cpp
@@ -205,10 +205,6 @@
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
@@ -226,16 +222,22 @@
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
 }
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
M data/src/hotspot-omp/hotspot_openmp.cpp
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..ddfa80493ac8b8f1f0d8423b8d555e59d4775bda
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,20 +220,26 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
 }
 
 void fatal(char *s)


thinking
**Reviewing VERBOSE iteration logging changes**
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..ddfa80493ac8b8f1f0d8423b8d555e59d4775bda
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,20 +220,26 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
 }
 
 void fatal(char *s)

file update
M /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/hotspot-omp/hotspot_openmp.cpp
@@ -242,3 +242,7 @@
 	}
-}
+
+#ifdef VERBOSE
+	fprintf(stdout, "iteration %d\n", num_iterations);
+#endif
+}
 
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/hotspot-omp/hotspot_openmp.cpp
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..837597af7c4a47672f232b6b97c608ac0b99e504
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,21 +220,31 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
-}
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
+
+#ifdef VERBOSE
+	fprintf(stdout, "iteration %d\n", num_iterations);
+#endif
+}
 
 void fatal(char *s)
 {


thinking
**Verifying OpenMP and VERBOSE integration**
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..837597af7c4a47672f232b6b97c608ac0b99e504
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,21 +220,31 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
-}
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
+
+#ifdef VERBOSE
+	fprintf(stdout, "iteration %d\n", num_iterations);
+#endif
+}
 
 void fatal(char *s)
 {

Plan update
  ✓ Move hotspot_openmp.cpp into the target workdir
  ✓ Revise single_iteration_gpu to use OpenMP target teams loops (with collapse) and keep the temperature/result copy on-device
  → Add a persistent target data region around the GPU iterations in compute_tran_temp, then rebuild with make -f Makefile.nvc

thinking
**Preparing build environment**
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..837597af7c4a47672f232b6b97c608ac0b99e504
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,21 +220,31 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
-}
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
+
+#ifdef VERBOSE
+	fprintf(stdout, "iteration %d\n", num_iterations);
+#endif
+}
 
 void fatal(char *s)
 {

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/hotspot-omp succeeded in 9ms:
rm -rf main src/hotspot_openmp.o

thinking
**Running compilation command**
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..837597af7c4a47672f232b6b97c608ac0b99e504
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,21 +220,31 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
-}
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
+
+#ifdef VERBOSE
+	fprintf(stdout, "iteration %d\n", num_iterations);
+#endif
+}
 
 void fatal(char *s)
 {

exec
/bin/bash -lc 'make -f Makefile.nvc' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/hotspot-omp exited 2 in 9ms:
make: *** No rule to make target 'src/hotspot_openmp.o', needed by 'main'.  Stop.

thinking
**Verifying source file paths**
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..837597af7c4a47672f232b6b97c608ac0b99e504
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,21 +220,31 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
-}
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
+
+#ifdef VERBOSE
+	fprintf(stdout, "iteration %d\n", num_iterations);
+#endif
+}
 
 void fatal(char *s)
 {

exec
/bin/bash -lc 'ls src' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/hotspot-omp succeeded in 8ms:
hotspot_openmp.cpp.backup
hotspot_openmp.cpp.bak
hotspot_openmp.cpp.bak2
hotspot_openmp.cpp.codex_backup
Makefile
README
run

thinking
**Resolving hotspot_openmp.cpp file location**
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..837597af7c4a47672f232b6b97c608ac0b99e504
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,21 +220,31 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
-}
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
+
+#ifdef VERBOSE
+	fprintf(stdout, "iteration %d\n", num_iterations);
+#endif
+}
 
 void fatal(char *s)
 {

exec
/bin/bash -lc 'cp data/src/hotspot-omp/hotspot_openmp.cpp data/src/hotspot-omp/src/hotspot_openmp.cpp' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 8ms:


thinking
**Confirming rebuild steps with clean**
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..837597af7c4a47672f232b6b97c608ac0b99e504
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,21 +220,31 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
-}
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
+
+#ifdef VERBOSE
+	fprintf(stdout, "iteration %d\n", num_iterations);
+#endif
+}
 
 void fatal(char *s)
 {

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/hotspot-omp succeeded in 10ms:
rm -rf main src/hotspot_openmp.o

thinking
**Running make with Makefile.nvc**
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..837597af7c4a47672f232b6b97c608ac0b99e504
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,21 +220,31 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
-}
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
+
+#ifdef VERBOSE
+	fprintf(stdout, "iteration %d\n", num_iterations);
+#endif
+}
 
 void fatal(char *s)
 {

exec
/bin/bash -lc 'make -f Makefile.nvc' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/hotspot-omp succeeded in 438ms:
nvc++  -std=c++14 -Wall -I/home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/gate_sdk -O3 -Minfo -mp=gpu -gpu=cc89 -c src/hotspot_openmp.cpp -o src/hotspot_openmp.o
"src/hotspot_openmp.cpp", line 216: warning: variable "t" was declared but never referenced [declared_but_not_referenced]
  	double t;
  	       ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"src/hotspot_openmp.cpp", line 264: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
  		fatal ("file could not be opened for reading");
  		       ^

"src/hotspot_openmp.cpp", line 269: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
  			fatal("not enough lines in file");
  			      ^

"src/hotspot_openmp.cpp", line 271: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
  			fatal("invalid file format");
  			      ^

"src/hotspot_openmp.cpp", line 257: warning: variable "index" was declared but never referenced [declared_but_not_referenced]

thinking
**Verifying build and preparing to run tests**
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..837597af7c4a47672f232b6b97c608ac0b99e504
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,21 +220,31 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
-}
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
+
+#ifdef VERBOSE
+	fprintf(stdout, "iteration %d\n", num_iterations);
+#endif
+}
 
 void fatal(char *s)
 {

exec
/bin/bash -lc 'ls input' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/hotspot-omp succeeded in 9ms:
inputGen
power_1024
power_512
power_64
temp_1024
temp_512
temp_64

thinking
**Preparing to run executable with sample inputs**
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..837597af7c4a47672f232b6b97c608ac0b99e504
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,21 +220,31 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
-}
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
+
+#ifdef VERBOSE
+	fprintf(stdout, "iteration %d\n", num_iterations);
+#endif
+}
 
 void fatal(char *s)
 {

exec
/bin/bash -lc './main 512 512 2 4 input/temp_512 input/power_512' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/hotspot-omp succeeded in 289ms:
<< Start computing the transient temperature >>
CPU Runtime: 0.001405s
GPU Runtime: 0.151409s
Non-Matching CPU-GPU Outputs Beyond Error Threshold of 0.05 Percent: 0
Ending simulation

thinking
**Noting runtime differences and updating plan**
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..837597af7c4a47672f232b6b97c608ac0b99e504
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,21 +220,31 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
-}
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
+
+#ifdef VERBOSE
+	fprintf(stdout, "iteration %d\n", num_iterations);
+#endif
+}
 
 void fatal(char *s)
 {

Plan update
  ✓ Move hotspot_openmp.cpp into the target workdir
  ✓ Revise single_iteration_gpu to use OpenMP target teams loops (with collapse) and keep the temperature/result copy on-device
  ✓ Add a persistent target data region around the GPU iterations in compute_tran_temp, then rebuild with make -f Makefile.nvc

thinking
**Preparing detailed modification summary**
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..837597af7c4a47672f232b6b97c608ac0b99e504
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,21 +220,31 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
-}
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
+
+#ifdef VERBOSE
+	fprintf(stdout, "iteration %d\n", num_iterations);
+#endif
+}
 
 void fatal(char *s)
 {

exec
/bin/bash -lc "nl -ba src/hotspot_openmp.cpp | sed -n '1,220p'" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/hotspot-omp succeeded in 9ms:
     1	#include <stdio.h>
     2	#include <stdlib.h>
     3	#include <sys/time.h>
     4	#include "../../common/rodiniaUtilFunctions.h"
     5	
     6	#define STR_SIZE	256
     7	
     8	/* mptogpu */
     9	#define GPU_DEVICE 1
    10	#define PERCENT_DIFF_ERROR_THRESHOLD 0.05
    11	
    12	/* maximum power density possible (say 300W for a 10mm x 10mm chip)	*/
    13	#define MAX_PD	(3.0e6)
    14	/* required precision in degrees	*/
    15	#define PRECISION	0.001
    16	#define SPEC_HEAT_SI 1.75e6
    17	#define K_SI 100
    18	/* capacitance fitting factor	*/
    19	#define FACTOR_CHIP	0.5
    20	#define OPEN

thinking
**Continuing to locate grid_size code**
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..837597af7c4a47672f232b6b97c608ac0b99e504
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,21 +220,31 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
-}
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
+
+#ifdef VERBOSE
+	fprintf(stdout, "iteration %d\n", num_iterations);
+#endif
+}
 
 void fatal(char *s)
 {

exec
/bin/bash -lc "nl -ba src/hotspot_openmp.cpp | sed -n '220,360p'" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/hotspot-omp succeeded in 9ms:
   220		fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
   221		#endif
   222	
   223		int grid_size = row * col;
   224	
   225		if (dev == 0) {
   226			for (int i = 0; i < num_iterations; i++) {
   227				#ifdef VERBOSE
   228				fprintf(stdout, "iteration %d\n", i++);
   229				#endif
   230				single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
   231			}
   232		} else {
   233			#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
   234			{
   235				for (int i = 0; i < num_iterations; i++) {
   236					#ifdef VERBOSE
   237					fprintf(stdout, "iteration %d\n", i++);
   238					#endif
   239					single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);

thinking
**Summarizing final implementation and testing**

I’m preparing a concise summary that covers the GPU offload changes with OpenMP directives in `data/src/hotspot-omp/src/hotspot_openmp.cpp` (notably lines 36-117 and 223-247), highlighting use of `target data` to keep arrays on the GPU and `teams loop collapse(2)` for nested loops. I'll include build steps using `make -f Makefile.nvc clean` then `make -f Makefile.nvc` with some pre-existing compiler warnings noted, plus running `./main` with the specified input verifying output correctness. I’ll suggest next steps like profiling with `nsys` and validating with a gating harness to help tune performance and ensure accuracy. This final message will be structured with clear bullets under **GPU Offload** and **Build & Test** headers as per guidelines.
codex
**GPU Offload**
- Replaced `single_iteration_gpu` with two `#pragma omp target teams loop collapse(2)` kernels so the delta computation and result-to-temp copy both execute entirely on the GPU, keeping the original stencil logic and writing `result` and `temp` via `result[index] = curr_temp + delta` (`data/src/hotspot-omp/src/hotspot_openmp.cpp:36-117`).
- Wrapped the GPU simulation loop in a persistent `#pragma omp target data` region so `power`, `temp`, and `result` stay resident between iterations; the host now dispatches either the CPU or GPU loop branch (CPU path unchanged) and still emits the verbose iteration counter (`data/src/hotspot-omp/src/hotspot_openmp.cpp:223-247`).

**Build & Test**
- `cd data/src/hotspot-omp && make -f Makefile.nvc clean && make -f Makefile.nvc` (nvc++ emitted its usual warnings about the unused `t` variable and deprecated `char*` literal usage).
- `./main 512 512 2 4 input/temp_512 input/power_512` → CPU runtime 0.001405s, GPU runtime 0.151409s, zero mismatched cells; the output matches the baseline.

Next steps:
1. Profile the GPU kernel with `nsys` or a similar tool so thread limits/collapsed dimensions can be tuned for larger problem sizes.
2. Drive the validated build through the Gate harness (`gate_sdk/scripts/gate_harness.py`) or any regression suite that compares against `golden_labels` to ensure long-running stability.
file update:
diff --git a/src/hotspot-omp/hotspot_openmp.cpp b/src/hotspot-omp/hotspot_openmp.cpp
index 72176c9a24ca348fa6a83ee8ec44c9e8620549c3..837597af7c4a47672f232b6b97c608ac0b99e504
--- a/src/hotspot-omp/hotspot_openmp.cpp
+++ b/src/hotspot-omp/hotspot_openmp.cpp
@@ -33,88 +33,89 @@
  * advances the solution of the discretized difference equations 
  * by one time step
  */
-void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
-					  double Cap, double Rx, double Ry, double Rz, 
-					  double step)
-{
-	double delta;
-	int r, c;
-	double amb_temp = 80.0;
-
-	{
-		for (r = 0; r < row; r++) {
-			for (c = 0; c < col; c++) {
-				/*	Corner 1	*/
-				if ((r == 0) && (c == 0)) {
-					delta = (step / Cap) * (power[0] +
-							(temp[1] - temp[0]) / Rx +
-							(temp[col] - temp[0]) / Ry +
-							(amb_temp - temp[0]) / Rz);
-				}	/*	Corner 2	*/
-				else if ((r == 0) && (c == col-1)) {
-					delta = (step / Cap) * (power[c] +
-							(temp[c-1] - temp[c]) / Rx +
-							(temp[c+col] - temp[c]) / Ry +
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Corner 3	*/
-				else if ((r == row-1) && (c == col-1)) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);					
-				}	/*	Corner 4	*/
-				else if ((r == row-1) && (c == 0)) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(temp[(r-1)*col] - temp[r*col]) / Ry + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Edge 1	*/
-				else if (r == 0) {
-					delta = (step / Cap) * (power[c] + 
-							(temp[c+1] + temp[c-1] - 2.0*temp[c]) / Rx + 
-							(temp[col+c] - temp[c]) / Ry + 
-							(amb_temp - temp[c]) / Rz);
-				}	/*	Edge 2	*/
-				else if (c == col-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c-1] - temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 3	*/
-				else if (r == row-1) {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(temp[(r-1)*col+c] - temp[r*col+c]) / Ry + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}	/*	Edge 4	*/
-				else if (c == 0) {
-					delta = (step / Cap) * (power[r*col] + 
-							(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) / Ry + 
-							(temp[r*col+1] - temp[r*col]) / Rx + 
-							(amb_temp - temp[r*col]) / Rz);
-				}	/*	Inside the chip	*/
-				else {
-					delta = (step / Cap) * (power[r*col+c] + 
-							(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) / Ry + 
-							(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) / Rx + 
-							(amb_temp - temp[r*col+c]) / Rz);
-				}
-	  			
-				/*	Update Temperatures	*/
-				result[r*col+c] =temp[r*col+c]+ delta;
-			}
-		}
-	}
-
-
-#ifdef OPEN
-#endif
-	for (r = 0; r < row; r++) {
-		for (c = 0; c < col; c++) {
-			temp[r*col+c]=result[r*col+c];
-		}
-	}
-}
+void single_iteration_gpu(double *result, double *temp, double *power, int row, int col,
+					  double Cap, double Rx, double Ry, double Rz, 
+					  double step)
+{
+	const double amb_temp = 80.0;
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			const double curr_temp = temp[index];
+			const double power_val = power[index];
+			double delta;
+
+			/*	Corner 1	*/
+			if ((r == 0) && (c == 0)) {
+				delta = (step / Cap) * (power_val +
+						(temp[1] - curr_temp) / Rx +
+						(temp[col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 2	*/
+			else if ((r == 0) && (c == col-1)) {
+				delta = (step / Cap) * (power_val +
+						(temp[c-1] - curr_temp) / Rx +
+						(temp[c+col] - curr_temp) / Ry +
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Corner 3	*/
+			else if ((r == row-1) && (c == col-1)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);					
+			}	/*	Corner 4	*/
+			else if ((r == row-1) && (c == 0)) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(temp[(r-1)*col] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 1	*/
+			else if (r == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[c+1] + temp[c-1] - 2.0*curr_temp) / Rx + 
+						(temp[col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 2	*/
+			else if (c == col-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c-1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 3	*/
+			else if (r == row-1) {
+				delta = (step / Cap) * (power_val + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(temp[(r-1)*col+c] - curr_temp) / Ry + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Edge 4	*/
+			else if (c == 0) {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col] + temp[(r-1)*col] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+1] - curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}	/*	Inside the chip	*/
+			else {
+				delta = (step / Cap) * (power_val + 
+						(temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*curr_temp) / Ry + 
+						(temp[r*col+c+1] + temp[r*col+c-1] - 2.0*curr_temp) / Rx + 
+						(amb_temp - curr_temp) / Rz);
+			}
+
+			/*	Update Temperatures	*/
+			result[index] = curr_temp + delta;
+		}
+	}
+
+	#pragma omp target teams loop collapse(2) thread_limit(256)
+	for (int r = 0; r < row; r++) {
+		for (int c = 0; c < col; c++) {
+			const int index = r * col + c;
+			temp[index] = result[index];
+		}
+	}
+}
 
 
 void single_iteration_cpu(double *result, double *temp, double *power, int row, int col,
@@ -202,14 +203,10 @@
  */
 void compute_tran_temp(double *result, int num_iterations, double *temp, double *power, int row, int col, int dev) 
 {
-	#ifdef VERBOSE
-	int i = 0;
-	#endif
-
-	double grid_height = chip_height / row;
-	double grid_width = chip_width / col;
-
-	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
+	double grid_height = chip_height / row;
+	double grid_width = chip_width / col;
+
+	double Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;
 	double Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);
 	double Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);
 	double Rz = t_chip / (K_SI * grid_height * grid_width);
@@ -223,21 +220,31 @@
 	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);
 	#endif
 
-     for (int i = 0; i < num_iterations ; i++)
-	{
-		#ifdef VERBOSE
-		fprintf(stdout, "iteration %d\n", i++);
-		#endif
-		if(dev == 0)
-			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
-		else
-			single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);	
-	}	
-
-	#ifdef VERBOSE
-	fprintf(stdout, "iteration %d\n", i++);
-	#endif
-}
+	int grid_size = row * col;
+
+	if (dev == 0) {
+		for (int i = 0; i < num_iterations; i++) {
+			#ifdef VERBOSE
+			fprintf(stdout, "iteration %d\n", i++);
+			#endif
+			single_iteration_cpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+		}
+	} else {
+		#pragma omp target data map(to: power[0:grid_size]) map(tofrom: temp[0:grid_size], result[0:grid_size])
+		{
+			for (int i = 0; i < num_iterations; i++) {
+				#ifdef VERBOSE
+				fprintf(stdout, "iteration %d\n", i++);
+				#endif
+				single_iteration_gpu(result, temp, power, row, col, Cap, Rx, Ry, Rz, step);
+			}
+		}
+	}
+
+#ifdef VERBOSE
+	fprintf(stdout, "iteration %d\n", num_iterations);
+#endif
+}
 
 void fatal(char *s)
 {

tokens used
256,396