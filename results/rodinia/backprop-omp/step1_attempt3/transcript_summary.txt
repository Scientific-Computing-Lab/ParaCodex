Mapped the contiguous weight/momentum buffers into the persistent target-data region so the `map(present: â€¦)` clauses in the kernels now reference the actual flattened blocks that stay resident on the GPU (`src/backprop.c:383`, `src/backprop.c:392`), and documented the refreshed array inventory/transfer strategy in `data_plan.md` (`data_plan.md:3`, `data_plan.md:28`).  
Kept the original `src/backprop.c` aside at `src/backprop.c.bak` as required by the workflow.

Testing:
- `OMP_TARGET_OFFLOAD=MANDATORY DEVICE=gpu SM=86 make -f Makefile.nvc CC=nvc++ CLASS=C`
- `OMP_TARGET_OFFLOAD=MANDATORY DEVICE=gpu SM=86 timeout 300 make -f Makefile.nvc CC=nvc++ CLASS=C run > gpu_output.txt 2>&1`
- `diff -u baseline_output.txt gpu_output.txt` (differences confined to the build logs and minor GPU-runtime ordering; the per-layer training output/GATE stats are unchanged)

Next steps:
1. Profile the GPU kernels with `CLASS=B` (e.g., `DEVICE=gpu SM=86 OMP_TARGET_OFFLOAD=MANDATORY make -f Makefile.nvc CC=nvc++ CLASS=B` plus an `nsys` capture) to confirm occupancy and data travel.  
2. Run a longer training/session sweep or a multi-sample dataset to verify stability and expose any emerging performance bottlenecks.