Ported the BFS frontier to OpenMP target offload so the GPU walks the graph with mapped buffers while the CPU version remains for validation and comparison.

- Added `#include <omp.h>`, honor the requested thread count, and wrapped the GPU work in a persistent `#pragma omp target data` region where each `#pragma omp target teams loop` expands the frontier and an atomic-powered stop flag detects completion (`data/src/bfs-omp/src/bfs.c:6`, `data/src/bfs-omp/src/bfs.c:163`, `data/src/bfs-omp/src/bfs.c:191`).
- Kept the original CPU BFS run for correctness checks, call to `compareResults`, result file dump, and full cleanup of host/GPU buffers so the outputs stay in sync (`data/src/bfs-omp/src/bfs.c:210`, `data/src/bfs-omp/src/bfs.c:248`, `data/src/bfs-omp/src/bfs.c:258`).
- Tests: `make -f Makefile.nvc clean`; `make -f Makefile.nvc CC=nvc++ CLASS=B`; `./main 4 input/graph1MW_6.txt` (prints GPU/CPU runtimes, reports zero mismatches, and writes `result.txt`).

Next step: profile the offloaded kernel with `nsys` (or similar) to tune team/thread limits and memory access patterns for better occupancy and throughput.