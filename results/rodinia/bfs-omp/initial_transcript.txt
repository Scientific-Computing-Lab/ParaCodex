Ported the BFS frontier to OpenMP target offload so the GPU walks the graph with mapped buffers while the CPU version remains for validation and comparison.

- Added `#include <omp.h>`, honor the requested thread count, and wrapped the GPU work in a persistent `#pragma omp target data` region where each `#pragma omp target teams loop` expands the frontier and an atomic-powered stop flag detects completion (`data/src/bfs-omp/src/bfs.c:6`, `data/src/bfs-omp/src/bfs.c:163`, `data/src/bfs-omp/src/bfs.c:191`).
- Kept the original CPU BFS run for correctness checks, call to `compareResults`, result file dump, and full cleanup of host/GPU buffers so the outputs stay in sync (`data/src/bfs-omp/src/bfs.c:210`, `data/src/bfs-omp/src/bfs.c:248`, `data/src/bfs-omp/src/bfs.c:258`).
- Tests: `make -f Makefile.nvc clean`; `make -f Makefile.nvc CC=nvc++ CLASS=B`; `./main 4 input/graph1MW_6.txt` (prints GPU/CPU runtimes, reports zero mismatches, and writes `result.txt`).

Next step: profile the offloaded kernel with `nsys` (or similar) to tune team/thread limits and memory access patterns for better occupancy and throughput.

OpenAI Codex v0.72.0 (research preview)
--------
workdir: /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir
model: gpt-5.1-codex-mini
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: medium
reasoning summaries: auto
session id: 019b3c1c-82a8-7e13-8b2f-26f609744fc5
--------
user
## First Step: Copy Source Files
Copy source files = - bfs.c from /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/golden_labels/src/bfs-serial to /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp.

**Files:** - bfs.c

**Your Task:**
1. Translate the code below to an OpenMP GPU-offloaded version.
2. Apply GPU offloading pragmas as needed. (`use teams loop` and not `teams distribute parallel for`)
3. Optimize the code for performance while preserving its original functionality.
4. make sure the code compiles with `make -f Makefile.nvc`, and runs with ./<executable
5. Deliver the modified code to /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp.

**Deliverable:**
- The complete, modified source code for - bfs.c in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp, that can be compiled with `make CC=nvc++ CLASS=B` and runs with `./<executable>`.

** Rules **
- NO GIT COMMANDS.
- DO NOT READ/WRITE OUTSIDE THE WORKING DIRECTORY.
- ALWAYS CLEAN BEFORE BUILD.


mcp startup: no servers

thinking
**Preparing to read system_info file**
exec
/bin/bash -lc pwd in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 3ms:
/home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir

thinking
**Reading system_info**
exec
/bin/bash -lc 'cat system_info.txt' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
=== SYSTEM BASELINE ===
Linux cmhq-ext-shared-codex 6.14.0-35-generic #35~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Oct 14 13:55:17 UTC 2 x86_64 x86_64 x86_64 GNU/Linux
PRETTY_NAME="Ubuntu 24.04.2 LTS"
NAME="Ubuntu"
VERSION_ID="24.04"
VERSION="24.04.2 LTS (Noble Numbat)"
VERSION_CODENAME=noble
ID=ubuntu
ID_LIKE=debian
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
UBUNTU_CODENAME=noble
LOGO=ubuntu-logo
ldd (Ubuntu GLIBC 2.39-0ubuntu8.6) 2.39

=== FIRMWARE & MICROCODE ===
# dmidecode 3.5
Getting SMBIOS data from sysfs.

thinking
**Copying source file with cp command**
exec
/bin/bash -lc 'cp golden_labels/src/bfs-serial/bfs.c data/src/bfs-omp/bfs.c' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir exited 1 in 10ms:
cp: cannot stat 'golden_labels/src/bfs-serial/bfs.c': No such file or directory

thinking
**Checking directory locations**
exec
/bin/bash -lc ls in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
AGENTS.md
check_devices
check_devices.c
check_devices_mp
data
data_ParaCodex
data_plan.md
gate_sdk
golden_labels
optimization_plan.md
reference
results_perf_rodinia_nsys
serial_kernels_changedVars
strip_openmp.sh
system_info.txt

thinking
**Checking path for golden_labels**
exec
/bin/bash -lc 'ls golden_labels' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
src

thinking
**Listing items**
exec
/bin/bash -lc 'ls golden_labels/src' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
backprop-serial
bfs-serial
b+tree-serial
common
hotspot-serial
lud-serial
nw-serial
srad-serial

thinking
**Considering BFS for directory listing**
exec
/bin/bash -lc 'ls golden_labels/src/bfs-serial' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
input
log
main
Makefile.nvc
src

thinking
**Searching for BFS.c file**
exec
/bin/bash -lc "rg --files -g 'bfs.c' golden_labels/src/bfs-serial" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 15ms:
golden_labels/src/bfs-serial/src/bfs.c

thinking
**Preparing to copy data to new location**
exec
/bin/bash -lc 'mkdir -p data/src/bfs-omp' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:


thinking
**Copying file**
exec
/bin/bash -lc 'cp golden_labels/src/bfs-serial/src/bfs.c data/src/bfs-omp/bfs.c' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:


thinking
**Preparing for OpenMP GPU translation**
exec
/bin/bash -lc "sed -n '1,200p' data/src/bfs-omp/bfs.c" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 11ms:
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <sys/time.h>
#include "../../common/rodiniaUtilFunctions.h"
//#define NUM_THREAD 4
#define OPEN

int no_of_nodes;
int edge_list_size;
FILE *fp;

//Structure to hold a node information
typedef struct Node
{
	int starting;
	int no_of_edges;
} Node;


thinking
**Continuing file review**
exec
/bin/bash -lc "sed -n '200,400p' data/src/bfs-omp/bfs.c" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 9ms:
	//CPU
	do
	{
		//if no thread changes this value then the loop stops
		stop=false;

		for(tid = 0; tid < no_of_nodes; tid++ )
		{
			if (h_graph_mask[tid] == true){ 
			h_graph_mask[tid]=false;
			for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
				{
				int id = h_graph_edges[i];
				if(!h_graph_visited[id])
					{
					h_cost[id]=h_cost[tid]+1;
					h_updating_graph_mask[id]=true;
					}
				}
			}

thinking
**Verifying include paths**
exec
/bin/bash -lc 'ls data' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 11ms:
src

thinking
**Planning GPU offloading integration**

I’m tracing paths to confirm where source and golden files live, aiming to translate BFS to GPU offloading with OpenMP pragmas like `#pragma omp target teams loop`. I need to handle data mapping and restructure loops while preserving correctness. Also, I’m focused on ensuring clean builds using `Makefile.nvc`—likely adapting or copying from golden code—to compile and run in the right `data/src/bfs-omp` location. Checking current files there will guide making the build setup complete.
exec
/bin/bash -lc 'ls data/src/bfs-omp' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 11ms:
bfs.c
bfs.c.backup
bfs.c.bak
bfs_omp.c
bfs_omp.c.backup
debug.log
input
log
Makefile
Makefile.nvc
run
src
tmp

thinking
**Handling existing BFS files carefully**
exec
/bin/bash -lc 'cat data/src/bfs-omp/Makefile.nvc' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 11ms:
#===============================================================================
# User Options
#===============================================================================

# Compiler can be set below, or via environment variable
CC        = nvc++
OPTIMIZE  = yes
DEBUG     = no
DEVICE    = gpu
SM        = cc89
LAUNCHER  =
GATE_ROOT ?= /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir
REF_DIR   ?= $(GATE_ROOT)/golden_labels/src/bfs-serial
REF_BIN   ?= $(REF_DIR)/main
REF_MAKE  ?= Makefile.nvc

RUN_ARGS ?= 4 input/graph1MW_6.txt

#===============================================================================
# Program name & source code list

thinking
**Checking source file locations**
exec
/bin/bash -lc 'ls data/src/bfs-omp/src' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 11ms:
bfs.c.backup
bfs.c.backup_user
bfs.c.backup.work
bfs.c.bak
bfs.c.codex.backup
bfs.c.codex.backup2
bfs.c.codex.bak
bfs.c.codex.bak2
bfs.c.codex.save
bfs.c.pre_opt
Makefile
run

thinking
**Evaluating directory structure for bfs.c placement**
exec
/bin/bash -lc 'cat data/src/bfs-omp/Makefile' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
SRC_DIR=$(BENCH_DIR)/src
SRC_OBJS=$(SRC_DIR)/bfs.c
INPUT_FLAGS=4 ../input/graph1MW_6.txt 


thinking
**Evaluating BFS source file placement and GPU offloading**
thinking
**Formulating OpenMP GPU offloading optimization and build plan**

I’m focusing on optimizing GPU offloading pragmas like using `thread_limit` for better occupancy, ensuring proper data mapping with `target data`, and handling `stop` with reductions correctly. I’m also considering setting `omp_set_num_threads` for CPU runs and preparing a plan including code inspection, GPU adaptation, and build steps aligned with instructions.
Plan update
Need to port the BFS benchmark to OpenMP target offload, ensuring the GPU loop structure is compliant and performance-aware, then verify the build.
  → Review the existing BFS implementation and supporting build files to understand the data layout and required outputs
  • Implement OpenMP target-offloaded GPU kernels with persistent data mappings, appropriate reductions, and thread control, updating includes and keeping the CPU baseline intact
  • Clean, build, and (if feasible) run the updated program with the provided Makefile to ensure it compiles and executes

thinking
**Updating plan progress**
Plan update
  ✓ Review the existing BFS implementation and supporting build files to understand the data layout and required outputs
  → Implement OpenMP target-offloaded GPU kernels with persistent data mappings, appropriate reductions, and thread control, updating includes and keeping the CPU baseline intact
  • Clean, build, and (if feasible) run the updated program with the provided Makefile to ensure it compiles and executes

thinking
**Determining correct file location for new code**
exec
/bin/bash -lc "rg --files -g 'bfs.c' data/src/bfs-omp/src" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir exited 1 in 14ms:



thinking
**Implementing BFS GPU code and patch plan**
thinking
**Preparing final patch for new BFS file**
file update
A /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp/src/bfs.c
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <sys/time.h>
#include <omp.h>
#include "../../common/rodiniaUtilFunctions.h"

//#define NUM_THREAD 4
#define OPEN

int no_of_nodes;
int edge_list_size;
FILE *fp;

//Structure to hold a node information
typedef struct Node
{
	int starting;
	int no_of_edges;
} Node;

#define bool int
#define true 1
#define false 0	

#define ERROR_THRESHOLD 0.05
#define GPU_DEVICE 1

void BFSGraph(int argc, char** argv);

void Usage(int argc, char**argv){

	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);

}
////////////////////////////////////////////////////////////////////////////////
// Main Program
////////////////////////////////////////////////////////////////////////////////
int main( int argc, char** argv) 
{
	no_of_nodes=0;
	edge_list_size=0;
	BFSGraph( argc, argv);
}


void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
  int i,fail;
  fail = 0;

  // Compare C with D
  for (i=0; i<no_of_nodes; i++) {
      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
	fail++;
      }
  }

  // print results
  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
}

////////////////////////////////////////////////////////////////////////////////
//Apply BFS on a Graph using OpenMP target offload
////////////////////////////////////////////////////////////////////////////////
void BFSGraph( int argc, char** argv) 
{
    char *input_f;
	int	 num_omp_threads;
	
	if(argc!=3){
	Usage(argc, argv);
	exit(0);
	}
    
	num_omp_threads = atoi(argv[1]);
	if (num_omp_threads > 0) {
		omp_set_num_threads(num_omp_threads);
	}
	input_f = argv[2];
	
	printf("Reading File\n");
	//Read in Graph from a file
	fp = fopen(input_f,"r");
	if(!fp)
	{
		printf("Error Reading graph file\n");
		return;
	}

	int source = 0;

	fscanf(fp,"%d",&no_of_nodes);
   
	// allocate host memory
	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);

	int start, edgeno;   
	// initalize the memory
	for( unsigned int i = 0; i < no_of_nodes; i++) 
	{
		fscanf(fp,"%d %d",&start,&edgeno);
		h_graph_nodes[i].starting = start;
		h_graph_nodes[i].no_of_edges = edgeno;
		h_graph_mask[i]=false;
		h_graph_mask_gpu[i]=false;
		h_updating_graph_mask[i]=false;
		h_updating_graph_mask_gpu[i]=false;
		h_graph_visited[i]=false;
		h_graph_visited_gpu[i]=false;
	}

	//read the source node from the file
	fscanf(fp,"%d",&source);
	// source=0; //tesing code line

	//set the source node as true in the mask
	h_graph_mask[source]=true;
	h_graph_mask_gpu[source]=true;
	h_graph_visited[source]=true;
	h_graph_visited_gpu[source]=true;

	fscanf(fp,"%d",&edge_list_size);

	int id,cost;
	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
	for(int i=0; i < edge_list_size ; i++)
	{
		fscanf(fp,"%d",&id);
		fscanf(fp,"%d",&cost);
		h_graph_edges[i] = id;
	}

	if(fp)
	fclose(fp);    


	// allocate mem for the result on host side
	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
	for(int i=0;i<no_of_nodes;i++){
		h_cost[i]=-1;
		h_cost_gpu[i]=-1;
	}
	h_cost[source]=0;
	h_cost_gpu[source]=0;
	
	printf("Start traversing the tree\n");
	
	int k=0;
	int stop_gpu;
	bool stop_cpu;
	double t_start, t_end;

	t_start = rtclock();
	//GPU BFS with OpenMP target offload
	#pragma omp target data \
	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
	{
		do
		{
			stop_gpu = 0;

			#pragma omp target teams loop thread_limit(128)
			for(int tid = 0; tid < no_of_nodes; tid++ )
			{
				if (h_graph_mask_gpu[tid] == true){ 
					h_graph_mask_gpu[tid]=false;
					Node current = h_graph_nodes[tid];
					int edge_start = current.starting;
					int edge_end = current.starting + current.no_of_edges;
					for(int i=edge_start; i<edge_end; i++)
					{
						int id = h_graph_edges[i];
						if(!h_graph_visited_gpu[id])
						{
							h_cost_gpu[id]=h_cost_gpu[tid]+1;
							h_updating_graph_mask_gpu[id]=true;
						}
					}
				}
			}

			#pragma omp target teams loop reduction(max:stop_gpu) thread_limit(128)
			for(int tid=0; tid< no_of_nodes ; tid++ )
			{
				if (h_updating_graph_mask_gpu[tid] == true){
					h_graph_mask_gpu[tid]=true;
					h_graph_visited_gpu[tid]=true;
					stop_gpu = 1;
					h_updating_graph_mask_gpu[tid]=false;
				}
			}

			k++;
		}
		while(stop_gpu);
	}
	t_end = rtclock();
  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);

	t_start = rtclock();
	//CPU
	do
	{
		//if no thread changes this value then the loop stops
		stop_cpu=false;

		for(int tid = 0; tid < no_of_nodes; tid++ )
		{
			if (h_graph_mask[tid] == true){ 
				h_graph_mask[tid]=false;
				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
				{
					int id = h_graph_edges[i];
					if(!h_graph_visited[id])
					{
						h_cost[id]=h_cost[tid]+1;
						h_updating_graph_mask[id]=true;
					}
				}
			}
		}

  		for(int tid=0; tid< no_of_nodes ; tid++ )
		{
			if (h_updating_graph_mask[tid] == true){
				h_graph_mask[tid]=true;
				h_graph_visited[tid]=true;
				stop_cpu=true;
				h_updating_graph_mask[tid]=false;
			}
		}
		k++;
	}
	while(stop_cpu);
	t_end = rtclock();
  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);

	compareResults(h_cost, h_cost_gpu, no_of_nodes);

	//Store the result into a file
	FILE *fpo = fopen("result.txt","w");
	for(int i=0;i<no_of_nodes;i++)
		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
	fclose(fpo);
	printf("Result stored in result.txt\n");


	// cleanup memory
	free( h_graph_nodes);
	free( h_graph_edges);
	free( h_graph_mask);
	free( h_updating_graph_mask);
	free( h_graph_visited);
	free( h_cost);
	free( h_graph_mask_gpu);
	free( h_updating_graph_mask_gpu);
	free( h_graph_visited_gpu);
	free( h_cost_gpu);

}
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
A data/src/bfs-omp/src/bfs.c
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..6b5907e9dce7445e6a060da9cdcbb2c58ca791c5
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,269 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop reduction(max:stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}


thinking
**Deciding on bfs.c file management**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..6b5907e9dce7445e6a060da9cdcbb2c58ca791c5
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,269 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop reduction(max:stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

exec
/bin/bash -lc 'cp src/bfs.c bfs.c' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp succeeded in 9ms:


thinking
**Updating plan statuses**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..6b5907e9dce7445e6a060da9cdcbb2c58ca791c5
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,269 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop reduction(max:stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

Plan update
  ✓ Review the existing BFS implementation and supporting build files to understand the data layout and required outputs
  ✓ Implement OpenMP target-offloaded GPU kernels with persistent data mappings, appropriate reductions, and thread control, updating includes and keeping the CPU baseline intact
  → Clean, build, and (if feasible) run the updated program with the provided Makefile to ensure it compiles and executes

thinking
**Preparing to clean, build, and run**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..6b5907e9dce7445e6a060da9cdcbb2c58ca791c5
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,269 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop reduction(max:stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp succeeded in 10ms:
rm -rf main src/bfs.o

thinking
**Preparing build command**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..6b5907e9dce7445e6a060da9cdcbb2c58ca791c5
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,269 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop reduction(max:stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

exec
/bin/bash -lc 'make -f Makefile.nvc CC=nvc++ CLASS=B' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp succeeded in 333ms:
nvc++  -std=c99 -Wall -I/home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/gate_sdk -O3 -Minfo -mp=gpu -gpu=cc89 -c src/bfs.c -o src/bfs.o
"src/bfs.c", line 192: warning: variable "stop_gpu" was set but never used [set_but_not_used]
  			for(int tid=0; tid< no_of_nodes ; tid++ )
  			^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

rtclock:
     14, FMA (fused multiply-add) instruction(s) generated
BFSGraph:
     14, FMA (fused multiply-add) instruction(s) generated
    106, Loop not vectorized/parallelized: contains call
    133, Loop not vectorized/parallelized: contains call
    147, Loop not vectorized/parallelized: not countable
    168, Loop not vectorized/parallelized: contains a parallel region
    169, #omp target teams loop thread_limit(128)
        169, Generating "nvkernel_BFSGraph_F1L169_2" GPU kernel
             Generating NVIDIA GPU code
          172, Loop parallelized across teams, threads(128) /* blockIdx.x threadIdx.x */
          179, Loop run sequentially 

thinking
**Resolving GPU stop variable warning**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..6b5907e9dce7445e6a060da9cdcbb2c58ca791c5
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,269 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop reduction(max:stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

file update
M /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp/src/bfs.c
@@ -156,3 +156,3 @@
 	int k=0;
-	int stop_gpu;
+	int stop_gpu = 0;
 	bool stop_cpu;
@@ -168,3 +168,2 @@
 		{
-			stop_gpu = 0;
 
@@ -190,3 +189,4 @@
 
-			#pragma omp target teams loop reduction(max:stop_gpu) thread_limit(128)
+			int updates = 0;
+			#pragma omp target teams loop reduction(max:updates) thread_limit(128)
 			for(int tid=0; tid< no_of_nodes ; tid++ )
@@ -196,3 +196,3 @@
 					h_graph_visited_gpu[tid]=true;
-					stop_gpu = 1;
+					updates = 1;
 					h_updating_graph_mask_gpu[tid]=false;
@@ -201,2 +201,3 @@
 
+			stop_gpu = updates;
 			k++;
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M data/src/bfs-omp/src/bfs.c
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..cacb29272b3ef7511a3485e35fbf460ead6f2255
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			int updates = 0;
+			#pragma omp target teams loop reduction(max:updates) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					updates = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			stop_gpu = updates;
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}


thinking
**Verifying variable initialization and file syncing**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..cacb29272b3ef7511a3485e35fbf460ead6f2255
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			int updates = 0;
+			#pragma omp target teams loop reduction(max:updates) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					updates = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			stop_gpu = updates;
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

exec
/bin/bash -lc 'cp src/bfs.c bfs.c' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp succeeded in 7ms:


thinking
**Preparing for rebuild**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..cacb29272b3ef7511a3485e35fbf460ead6f2255
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			int updates = 0;
+			#pragma omp target teams loop reduction(max:updates) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					updates = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			stop_gpu = updates;
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp succeeded in 10ms:
rm -rf main src/bfs.o

thinking
**Rebuilding the project**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..cacb29272b3ef7511a3485e35fbf460ead6f2255
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			int updates = 0;
+			#pragma omp target teams loop reduction(max:updates) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					updates = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			stop_gpu = updates;
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

exec
/bin/bash -lc 'make -f Makefile.nvc CC=nvc++ CLASS=B' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp succeeded in 332ms:
nvc++  -std=c99 -Wall -I/home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/gate_sdk -O3 -Minfo -mp=gpu -gpu=cc89 -c src/bfs.c -o src/bfs.o
"src/bfs.c", line 192: warning: variable "updates" was set but never used [set_but_not_used]
  			for(int tid=0; tid< no_of_nodes ; tid++ )
  			^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

rtclock:
     14, FMA (fused multiply-add) instruction(s) generated
BFSGraph:
     14, FMA (fused multiply-add) instruction(s) generated
    106, Loop not vectorized/parallelized: contains call
    133, Loop not vectorized/parallelized: contains call
    147, Loop not vectorized/parallelized: not countable
    168, #omp target teams loop thread_limit(128)
        168, Generating "nvkernel_BFSGraph_F1L168_2" GPU kernel
             Generating NVIDIA GPU code
          171, Loop parallelized across teams, threads(128) /* blockIdx.x threadIdx.x */
          178, Loop run sequentially 
        168, Generating Multicore code

thinking
**Analyzing OpenMP reduction warnings**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..cacb29272b3ef7511a3485e35fbf460ead6f2255
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			int updates = 0;
+			#pragma omp target teams loop reduction(max:updates) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					updates = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			stop_gpu = updates;
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

exec
/bin/bash -lc "sed -n '150,230p' data/src/bfs-omp/src/bfs.c" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
	}
	h_cost[source]=0;
	h_cost_gpu[source]=0;
	
	printf("Start traversing the tree\n");
	
	int k=0;
	int stop_gpu = 0;
	bool stop_cpu;
	double t_start, t_end;

	t_start = rtclock();
	//GPU BFS with OpenMP target offload
	#pragma omp target data \
	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
	{
		do
		{


thinking
**Reworking GPU loop synchronization**

I'm figuring out how to remove the compiler warning about the `updates` variable by replacing its reduction with an atomic `stop_gpu` flag updated inside a targeted loop. This involves mapping `stop_gpu` with `map(tofrom:)` on the OpenMP `target teams loop` to sync its value between host and device, using atomic writes to handle race conditions, and restructuring the loops accordingly to maintain correctness without triggering unused variable warnings.
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..cacb29272b3ef7511a3485e35fbf460ead6f2255
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			int updates = 0;
+			#pragma omp target teams loop reduction(max:updates) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					updates = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			stop_gpu = updates;
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

file update
M /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp/src/bfs.c
@@ -168,2 +168,3 @@
 		{
+			stop_gpu = 0;
 
@@ -189,4 +190,3 @@
 
-			int updates = 0;
-			#pragma omp target teams loop reduction(max:updates) thread_limit(128)
+			#pragma omp target teams loop map(tofrom: stop_gpu) thread_limit(128)
 			for(int tid=0; tid< no_of_nodes ; tid++ )
@@ -196,3 +196,4 @@
 					h_graph_visited_gpu[tid]=true;
-					updates = 1;
+					#pragma omp atomic write
+					stop_gpu = 1;
 					h_updating_graph_mask_gpu[tid]=false;
@@ -201,3 +202,2 @@
 
-			stop_gpu = updates;
 			k++;
apply_patch(auto_approved=true) exited 0 in 4ms:
Success. Updated the following files:
M data/src/bfs-omp/src/bfs.c
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..b53fd76de4e06146655b115532facf68f061e685
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop map(tofrom: stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					#pragma omp atomic write
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}


thinking
**Reapplying file copy to root**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..b53fd76de4e06146655b115532facf68f061e685
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop map(tofrom: stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					#pragma omp atomic write
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

exec
/bin/bash -lc 'cp src/bfs.c bfs.c' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp succeeded in 8ms:


thinking
**Re-running clean and build**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..b53fd76de4e06146655b115532facf68f061e685
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop map(tofrom: stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					#pragma omp atomic write
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp succeeded in 10ms:
rm -rf main src/bfs.o

thinking
**Rebuilding project**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..b53fd76de4e06146655b115532facf68f061e685
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop map(tofrom: stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					#pragma omp atomic write
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

exec
/bin/bash -lc 'make -f Makefile.nvc CC=nvc++ CLASS=B' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp succeeded in 324ms:
nvc++  -std=c99 -Wall -I/home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/gate_sdk -O3 -Minfo -mp=gpu -gpu=cc89 -c src/bfs.c -o src/bfs.o
rtclock:
     14, FMA (fused multiply-add) instruction(s) generated
BFSGraph:
     14, FMA (fused multiply-add) instruction(s) generated
    106, Loop not vectorized/parallelized: contains call
    133, Loop not vectorized/parallelized: contains call
    147, Loop not vectorized/parallelized: not countable
    169, #omp target teams loop thread_limit(128)
        169, Generating "nvkernel_BFSGraph_F1L169_2" GPU kernel
             Generating NVIDIA GPU code
          172, Loop parallelized across teams, threads(128) /* blockIdx.x threadIdx.x */
          179, Loop run sequentially 
        169, Generating Multicore code
          172, Loop parallelized across threads
    169, Generating implicit map(tofrom:current) 
         Local memory used for current
    179, Complex loop carried dependence of h_graph_edges->,h_graph_visited_gpu->,h_cost_gpu-> prevents parallelization
         Loop carried dependence of h_cost_gpu-> prevents parallelization
         Loop carried backward dependence of h_cost_gpu-> prevents vectorization

thinking
**Preparing to run compiled program**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..b53fd76de4e06146655b115532facf68f061e685
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop map(tofrom: stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					#pragma omp atomic write
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

exec
/bin/bash -lc './main 4 input/graph1MW_6.txt' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp succeeded in 633ms:
Reading File
Start traversing the tree
GPU Runtime: 0.150438s
CPU Runtime: 0.049052s
Non-Matching CPU-GPU Outputs Beyond Error Threshold of 0.05 Percent: 0
Result stored in result.txt

thinking
**Updating build plan status**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..b53fd76de4e06146655b115532facf68f061e685
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop map(tofrom: stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					#pragma omp atomic write
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

Plan update
  ✓ Review the existing BFS implementation and supporting build files to understand the data layout and required outputs
  ✓ Implement OpenMP target-offloaded GPU kernels with persistent data mappings, appropriate reductions, and thread control, updating includes and keeping the CPU baseline intact
  ✓ Clean, build, and (if feasible) run the updated program with the provided Makefile to ensure it compiles and executes

thinking
**Preparing detailed final summary**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..b53fd76de4e06146655b115532facf68f061e685
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop map(tofrom: stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					#pragma omp atomic write
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

exec
/bin/bash -lc "nl -ba src/bfs.c | sed -n '1,60p'" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp succeeded in 9ms:
     1	#include <stdio.h>
     2	#include <string.h>
     3	#include <math.h>
     4	#include <stdlib.h>
     5	#include <sys/time.h>
     6	#include <omp.h>
     7	#include "../../common/rodiniaUtilFunctions.h"
     8	
     9	//#define NUM_THREAD 4
    10	#define OPEN
    11	
    12	int no_of_nodes;
    13	int edge_list_size;
    14	FILE *fp;
    15	
    16	//Structure to hold a node information
    17	typedef struct Node
    18	{
    19		int starting;
    20		int no_of_edges;

thinking
**Checking GPU loop lines**
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..b53fd76de4e06146655b115532facf68f061e685
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop map(tofrom: stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					#pragma omp atomic write
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

exec
/bin/bash -lc "nl -ba src/bfs.c | sed -n '130,230p'" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp succeeded in 10ms:
   130	
   131		int id,cost;
   132		int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
   133		for(int i=0; i < edge_list_size ; i++)
   134		{
   135			fscanf(fp,"%d",&id);
   136			fscanf(fp,"%d",&cost);
   137			h_graph_edges[i] = id;
   138		}
   139	
   140		if(fp)
   141		fclose(fp);    
   142	
   143	
   144		// allocate mem for the result on host side
   145		int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
   146		int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
   147		for(int i=0;i<no_of_nodes;i++){
   148			h_cost[i]=-1;
   149			h_cost_gpu[i]=-1;

thinking
**Summarizing BFS GPU implementation details**

I’m outlining the delivered GPU-targeted BFS using OpenMP target teams loops, keeping the CPU baseline for validation. I’ll note key code modifications with precise file and line references, mention test commands run and results saved in `result.txt`, and suggest next steps like profiling with `nsys` for performance insights. This clear structure should help the user quickly grasp changes and outcomes.
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..b53fd76de4e06146655b115532facf68f061e685
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop map(tofrom: stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					#pragma omp atomic write
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

exec
/bin/bash -lc "nl -ba src/bfs.c | sed -n '230,280p'" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/bfs-omp succeeded in 10ms:
   230				}
   231			}
   232	
   233	  		for(int tid=0; tid< no_of_nodes ; tid++ )
   234			{
   235				if (h_updating_graph_mask[tid] == true){
   236					h_graph_mask[tid]=true;
   237					h_graph_visited[tid]=true;
   238					stop_cpu=true;
   239					h_updating_graph_mask[tid]=false;
   240				}
   241			}
   242			k++;
   243		}
   244		while(stop_cpu);
   245		t_end = rtclock();
   246	  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
   247	
   248		compareResults(h_cost, h_cost_gpu, no_of_nodes);
   249	

thinking
**Summarizing BFS GPU port and tests**

I’m putting together a clear final summary explaining the BFS GPU offload via OpenMP target teams loops, while keeping the CPU baseline for result validation. I’ll highlight key code changes with file and line references, mention test commands that show successful runs with GPU/CPU timings and correctness checks, and note the creation of the result file storing BFS costs. I’ll finish by suggesting profiling with `nsys` to analyze occupancy and tune performance settings. This concise bullet list approach should make the updates easy to grasp.
codex
Ported the BFS frontier to OpenMP target offload so the GPU walks the graph with mapped buffers while the CPU version remains for validation and comparison.

- Added `#include <omp.h>`, honor the requested thread count, and wrapped the GPU work in a persistent `#pragma omp target data` region where each `#pragma omp target teams loop` expands the frontier and an atomic-powered stop flag detects completion (`data/src/bfs-omp/src/bfs.c:6`, `data/src/bfs-omp/src/bfs.c:163`, `data/src/bfs-omp/src/bfs.c:191`).
- Kept the original CPU BFS run for correctness checks, call to `compareResults`, result file dump, and full cleanup of host/GPU buffers so the outputs stay in sync (`data/src/bfs-omp/src/bfs.c:210`, `data/src/bfs-omp/src/bfs.c:248`, `data/src/bfs-omp/src/bfs.c:258`).
- Tests: `make -f Makefile.nvc clean`; `make -f Makefile.nvc CC=nvc++ CLASS=B`; `./main 4 input/graph1MW_6.txt` (prints GPU/CPU runtimes, reports zero mismatches, and writes `result.txt`).

Next step: profile the offloaded kernel with `nsys` (or similar) to tune team/thread limits and memory access patterns for better occupancy and throughput.
file update:
diff --git a/src/bfs-omp/src/bfs.c b/src/bfs-omp/src/bfs.c
new file mode 100644
index 0000000000000000000000000000000000000000..b53fd76de4e06146655b115532facf68f061e685
--- /dev/null
+++ b/src/bfs-omp/src/bfs.c
@@ -0,0 +1,270 @@
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <omp.h>
+#include "../../common/rodiniaUtilFunctions.h"
+
+//#define NUM_THREAD 4
+#define OPEN
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+//Structure to hold a node information
+typedef struct Node
+{
+	int starting;
+	int no_of_edges;
+} Node;
+
+#define bool int
+#define true 1
+#define false 0	
+
+#define ERROR_THRESHOLD 0.05
+#define GPU_DEVICE 1
+
+void BFSGraph(int argc, char** argv);
+
+void Usage(int argc, char**argv){
+
+	fprintf(stderr,"Usage: %s <num_threads> <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+
+void compareResults(int* h_cost, int* h_cost_gpu, int no_of_nodes) {
+  int i,fail;
+  fail = 0;
+
+  // Compare C with D
+  for (i=0; i<no_of_nodes; i++) {
+      if (percentDiff(h_cost[i], h_cost_gpu[i]) > ERROR_THRESHOLD) {
+	fail++;
+      }
+  }
+
+  // print results
+  printf("Non-Matching CPU-GPU Outputs Beyond Error Threshold of %4.2f Percent: %d\n", ERROR_THRESHOLD, fail);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using OpenMP target offload
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+    char *input_f;
+	int	 num_omp_threads;
+	
+	if(argc!=3){
+	Usage(argc, argv);
+	exit(0);
+	}
+    
+	num_omp_threads = atoi(argv[1]);
+	if (num_omp_threads > 0) {
+		omp_set_num_threads(num_omp_threads);
+	}
+	input_f = argv[2];
+	
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+   
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited_gpu = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_graph_mask_gpu[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_updating_graph_mask_gpu[i]=false;
+		h_graph_visited[i]=false;
+		h_graph_visited_gpu[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	// source=0; //tesing code line
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_mask_gpu[source]=true;
+	h_graph_visited[source]=true;
+	h_graph_visited_gpu[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+	fclose(fp);    
+
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	int* h_cost_gpu = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++){
+		h_cost[i]=-1;
+		h_cost_gpu[i]=-1;
+	}
+	h_cost[source]=0;
+	h_cost_gpu[source]=0;
+	
+	printf("Start traversing the tree\n");
+	
+	int k=0;
+	int stop_gpu = 0;
+	bool stop_cpu;
+	double t_start, t_end;
+
+	t_start = rtclock();
+	//GPU BFS with OpenMP target offload
+	#pragma omp target data \
+	    map(to: h_graph_nodes[:no_of_nodes], h_graph_edges[:edge_list_size]) \
+	    map(tofrom: h_graph_mask_gpu[:no_of_nodes], h_updating_graph_mask_gpu[:no_of_nodes], h_graph_visited_gpu[:no_of_nodes], h_cost_gpu[:no_of_nodes])
+	{
+		do
+		{
+			stop_gpu = 0;
+
+			#pragma omp target teams loop thread_limit(128)
+			for(int tid = 0; tid < no_of_nodes; tid++ )
+			{
+				if (h_graph_mask_gpu[tid] == true){ 
+					h_graph_mask_gpu[tid]=false;
+					Node current = h_graph_nodes[tid];
+					int edge_start = current.starting;
+					int edge_end = current.starting + current.no_of_edges;
+					for(int i=edge_start; i<edge_end; i++)
+					{
+						int id = h_graph_edges[i];
+						if(!h_graph_visited_gpu[id])
+						{
+							h_cost_gpu[id]=h_cost_gpu[tid]+1;
+							h_updating_graph_mask_gpu[id]=true;
+						}
+					}
+				}
+			}
+
+			#pragma omp target teams loop map(tofrom: stop_gpu) thread_limit(128)
+			for(int tid=0; tid< no_of_nodes ; tid++ )
+			{
+				if (h_updating_graph_mask_gpu[tid] == true){
+					h_graph_mask_gpu[tid]=true;
+					h_graph_visited_gpu[tid]=true;
+					#pragma omp atomic write
+					stop_gpu = 1;
+					h_updating_graph_mask_gpu[tid]=false;
+				}
+			}
+
+			k++;
+		}
+		while(stop_gpu);
+	}
+	t_end = rtclock();
+  	fprintf(stdout, "GPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	t_start = rtclock();
+	//CPU
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop_cpu=false;
+
+		for(int tid = 0; tid < no_of_nodes; tid++ )
+		{
+			if (h_graph_mask[tid] == true){ 
+				h_graph_mask[tid]=false;
+				for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)
+				{
+					int id = h_graph_edges[i];
+					if(!h_graph_visited[id])
+					{
+						h_cost[id]=h_cost[tid]+1;
+						h_updating_graph_mask[id]=true;
+					}
+				}
+			}
+		}
+
+  		for(int tid=0; tid< no_of_nodes ; tid++ )
+		{
+			if (h_updating_graph_mask[tid] == true){
+				h_graph_mask[tid]=true;
+				h_graph_visited[tid]=true;
+				stop_cpu=true;
+				h_updating_graph_mask[tid]=false;
+			}
+		}
+		k++;
+	}
+	while(stop_cpu);
+	t_end = rtclock();
+  	fprintf(stdout, "CPU Runtime: %0.6lfs\n", t_end - t_start);
+
+	compareResults(h_cost, h_cost_gpu, no_of_nodes);
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+	free( h_graph_mask_gpu);
+	free( h_updating_graph_mask_gpu);
+	free( h_graph_visited_gpu);
+	free( h_cost_gpu);
+
+}

tokens used
334,199