Reworked the SRAD GPU compute section so the working image and derivative buffers stay resident in a single `target data` region while the derivative/divergence kernels use `depend` clauses (with the derivative kernel launched `nowait`) and refreshed the data plan to spell out Strategy B with the new scheduling.

- **Implementation** `data/src/srad-omp/src/main.c:345-417`: the ROI reduction stays synchronous to compute `q0sqr`, the derivative sweep now runs with `nowait depend(out:d*[:Ne], c[:Ne])` and `is_device_ptr` so scratch buffers stay on-device, and the divergence kernel waits on those buffers via `depend(in:...)` while writing back `image`.
- **Plan** `data/src/srad-omp/data_plan.md`: rewrote the management plan to list the arrays/stages, describe the asynchronous derivative/divergence interaction, and spell out the expected transfers for Strategy B.
- **Backup** `data/src/srad-omp/src/main.c.backup_step0` preserves the original `main.c` before edits.
- **Testing** `OMP_TARGET_OFFLOAD=MANDATORY timeout 300 make -f Makefile.nvc CC=nvc++ CLASS=C run > data/src/srad-omp/gpu_output.txt 2>&1` (fails after kernel launch with CUDA_ERROR_ILLEGAL_ADDRESS 700; see `data/src/srad-omp/gpu_output.txt` for the log).
- **Baseline** `OMP_TARGET_OFFLOAD=MANDATORY timeout 300 make -f Makefile.nvc CC=nvc++ CLASS=C run > data/src/srad-omp/baseline_output.txt 2>&1` (the same illegal-address error occurs even on the untouched baseline; see `data/src/srad-omp/baseline_output.txt`).

Next steps:
1. Use `cuda-memcheck ./main 1000 0.5 1024 1024 4` (or the equivalent OpenMP-aware memory checker) to pinpoint the illegal access during the ROI/derivative kernels.
2. Re-evaluate the array section usage (`d*`, `c`, `image`) and their bounds in the kernel loops or consider reducing the problem size temporarily to see if a specific index/loop trip is causing the fault.