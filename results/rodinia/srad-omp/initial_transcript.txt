**Changes**
- Added the `<stdio.h>` and `<omp.h>` headers at `data/src/srad-omp/main.c:24` so the file is self-contained for reporting and OpenMP GPU directives.
- Replaced the legacy GPU stub with a `#pragma omp target data` region at `data/src/srad-omp/main.c:347` that stages `image`, neighbor indices, and coefficient buffers; each GPU iteration now runs three `#pragma omp target teams loop` kernels (ROI reduction, derivative/diffusion, divergence/update) with `collapse(2)` and `thread_limit(256)` to exploit the Ada Lovelace device while honoring the “teams loop” requirement.
- The new block copies the computed `q0sqr` value back to the device via `#pragma omp target update to(q0sqr)` at `data/src/srad-omp/main.c:369`, keeping the diffusion kernels in sync with the latest ROI statistics while keeping intermediary arrays resident on the GPU.

**Testing**
- `make -f Makefile.nvc CC=nvc++ CLASS=B clean`
- `make -f Makefile.nvc CC=nvc++ CLASS=B` (build succeeds; existing warning about `th1` being set but unused in upstream code remains)
- `./main 10 0.5 502 458 1` (GPU runtime 0.002652s vs. CPU runtime 0.015696s, GATE stats reported, and GPU/CPU outputs matched with 0 mismatches)

**Next Steps**
1. Profile the new kernels with `nsys` or another NVIDIA tool to tune `thread_limit`/collapse choices and ensure the teams/threads balance maximizes occupancy on the RTX 4060 Ti.

OpenAI Codex v0.72.0 (research preview)
--------
workdir: /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir
model: gpt-5.1-codex-mini
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: medium
reasoning summaries: auto
session id: 019b3c39-80f1-7b83-87a8-10e23e2697c2
--------
user
## First Step: Copy Source Files
Copy source files = - main.c from /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/golden_labels/src/srad-serial to /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/srad-omp.

**Files:** - main.c

**Your Task:**
1. Translate the code below to an OpenMP GPU-offloaded version.
2. Apply GPU offloading pragmas as needed. (`use teams loop` and not `teams distribute parallel for`)
3. Optimize the code for performance while preserving its original functionality.
4. make sure the code compiles with `make -f Makefile.nvc`, and runs with ./<executable
5. Deliver the modified code to /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/srad-omp.

**Deliverable:**
- The complete, modified source code for - main.c in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/srad-omp, that can be compiled with `make CC=nvc++ CLASS=B` and runs with `./<executable>`.

** Rules **
- NO GIT COMMANDS.
- DO NOT READ/WRITE OUTSIDE THE WORKING DIRECTORY.
- ALWAYS CLEAN BEFORE BUILD.


mcp startup: no servers

thinking
**Preparing for OpenMP offload translation**

I need to start by reading the system_info.txt to understand the environment details. Then, I plan to copy main.c from the golden_labels source folder to the data source folder before translating the code using OpenMP offload with teams loop directives. I'll ensure to clean the build and compile with the specified make command using the NVIDIA compiler and the appropriate class setting. Listing files will help me verify the setup.
exec
/bin/bash -lc pwd in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 9ms:
/home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir

thinking
**Reading system_info file**
exec
/bin/bash -lc 'cat system_info.txt' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
=== SYSTEM BASELINE ===
Linux cmhq-ext-shared-codex 6.14.0-35-generic #35~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Oct 14 13:55:17 UTC 2 x86_64 x86_64 x86_64 GNU/Linux
PRETTY_NAME="Ubuntu 24.04.2 LTS"
NAME="Ubuntu"
VERSION_ID="24.04"
VERSION="24.04.2 LTS (Noble Numbat)"
VERSION_CODENAME=noble
ID=ubuntu
ID_LIKE=debian
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
UBUNTU_CODENAME=noble
LOGO=ubuntu-logo
ldd (Ubuntu GLIBC 2.39-0ubuntu8.6) 2.39

=== FIRMWARE & MICROCODE ===
# dmidecode 3.5
Getting SMBIOS data from sysfs.

thinking
**Preparing to copy source file**
exec
/bin/bash -lc 'cp -r golden_labels/src/srad-serial/main.c data/src/srad-omp/main.c' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir exited 1 in 10ms:
cp: cannot stat 'golden_labels/src/srad-serial/main.c': No such file or directory

thinking
**Verifying directory path**
exec
/bin/bash -lc 'ls golden_labels' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
src

thinking
**Checking for list inside src**
exec
/bin/bash -lc 'ls golden_labels/src' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
backprop-serial
bfs-serial
b+tree-serial
common
hotspot-serial
lud-serial
nw-serial
srad-serial

thinking
**Checking files to copy from srad-serial main**
exec
/bin/bash -lc 'ls golden_labels/src/srad-serial' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 11ms:
image_out.pgm
input
log
main
Makefile.nvc
src

thinking
**Checking main directory contents**
exec
/bin/bash -lc 'ls golden_labels/src/srad-serial/main' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
golden_labels/src/srad-serial/main

thinking
**Checking for main directory**
exec
/bin/bash -lc 'ls golden_labels/src/srad-serial/main' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
golden_labels/src/srad-serial/main

thinking
**Examining path symlink behavior**
exec
/bin/bash -lc 'ls -l golden_labels/src/srad-serial' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 11ms:
total 512
-rw-rw-r-- 1 codex_user codex_user 460349 Dec 17 06:17 image_out.pgm
drwxrwxr-x 2 codex_user codex_user   4096 Dec 17 06:17 input
drwxrwxr-x 2 codex_user codex_user   4096 Dec 17 06:17 log
-rwxrwxr-x 1 codex_user codex_user  44752 Dec 17 06:17 main
-rw-rw-r-- 1 codex_user codex_user   2134 Dec 17 06:17 Makefile.nvc
drwxrwxr-x 2 codex_user codex_user   4096 Dec 17 06:17 src

thinking
**Checking for main file**
exec
/bin/bash -lc "rg --files -g 'main.c' golden_labels/src/srad-serial" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
golden_labels/src/srad-serial/src/main.c

thinking
**Checking source and destination directories**
exec
/bin/bash -lc 'ls data' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
src
exec
/bin/bash -lc 'ls data/src' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 11ms:
backprop-omp
bfs-omp
b+tree-omp
common
hotspot-omp
input
lud-omp
nsys_profile.nsys-rep
nsys_profile.sqlite
nw-omp
srad-omp

thinking
**Checking for srad-omp directory**
exec
/bin/bash -lc 'ls data/src/srad-omp' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
image_out.pgm
input
log
main.c.bak
Makefile.nvc
srad.c
srad_omp.c
src

thinking
**Preparing to copy main.c file**
exec
/bin/bash -lc 'cp golden_labels/src/srad-serial/src/main.c data/src/srad-omp/main.c' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:


thinking
**Preparing to translate to OpenMP GPU offload**
exec
/bin/bash -lc "sed -n '1,200p' data/src/srad-omp/main.c" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
//====================================================================================================100
//		UPDATE
//====================================================================================================100

//    2006.03   Rob Janiczek
//        --creation of prototype version
//    2006.03   Drew Gilliam
//        --rewriting of prototype version into current version
//        --got rid of multiple function calls, all code in a  
//         single function (for speed)
//        --code cleanup & commenting
//        --code optimization efforts   
//    2006.04   Drew Gilliam
//        --added diffusion coefficent saturation on [0,1]
//		2009.12 Lukasz G. Szafaryn
//		-- reading from image, command line inputs
//		2010.01 Lukasz G. Szafaryn
//		--comments

//====================================================================================================100

thinking
**Continuing file inspection**
exec
/bin/bash -lc "sed -n '200,400p' data/src/srad-omp/main.c" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 11ms:

	// allocate variables for directional derivatives
	dN = malloc(sizeof(fp) * Ne);				// north direction derivative
	dS = malloc(sizeof(fp) * Ne);				// south direction derivative
	dW = malloc(sizeof(fp) * Ne);					// west direction derivative
	dE = malloc(sizeof(fp) * Ne);					// east direction derivative

	// allocate variable for diffusion coefficient
	c = malloc(sizeof(fp) * Ne);						// diffusion coefficient

	// N/S/W/E indices of surrounding pixels (every element of IMAGE)
	// #pragma omp parallel
	for (i = 0; i < Nr; i++) {
		iN[i] = i - 1;						// holds index of IMAGE row above
		iS[i] = i + 1;						// holds index of IMAGE row below
	}
	// #pragma omp parallel
	for (j = 0; j < Nc; j++) {
		jW[j] = j - 1;				// holds index of IMAGE column on the left
		jE[j] = j + 1;				// holds index of IMAGE column on the right

thinking
**Continuing file review**
exec
/bin/bash -lc "sed -n '400,800p' data/src/srad-omp/main.c" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 10ms:
				{
					c[k] = 0;	// ... set to 0
				}
				else if (c[k] > 1)	// if diffusion coefficient > 1
				{
					c[k] = 1;	// ... set to 1
				}			

			}
		}
	//	}
		
		// divergence & image update
	//	#pragma omp target device(GPU_DEVICE)
	//	#pragma omp target map(to: c[:Ne], iS[:Nr], jE[:Nc], dN[:Ne], dS[:Ne],  dW[:Ne], dE[:Ne] ) \
		map(tofrom: image[:Ne])
	//	{
		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE



thinking
**Planning OpenMP GPU offload with teams loop**

I’m mapping out how to convert compute loops to use OpenMP GPU offloading with `target teams loop` (not `teams distribute parallel for`) to keep with instructions and best practices. I want to offload key loops like ROI stats and derivatives, using `target data` to map arrays, handle reductions for sums properly, and ensure CPU and GPU versions coexist for comparison. I’m carefully considering mapping, loop collapsing, thread limits, and how to retrieve reduction results back on the host while respecting the code’s original data structures and types. I’ll rely on heuristics for optimization since no profiling info is given, and confirm usage details like `fp` type in the included `define.c`.
exec
/bin/bash -lc "sed -n '1,200p' data/src/srad-omp/src/define.c" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 11ms:
//====================================================================================================100
//====================================================================================================100
//	DEFINE
//====================================================================================================100
//====================================================================================================100

#define fp float




thinking
**Designing OpenMP GPU offload pragmas**
thinking
**Planning data mapping and timing for GPU loops**

I'm thinking through how to structure the GPU timing around the `#pragma omp target data` region to include all iterations properly, making sure the timing captures GPU execution correctly. I need to carefully map all necessary arrays and scalars—including dynamically updated values like `q0sqr`—to the device and manage updating those scalars on the GPU each iteration to keep them in sync with the host computations, while avoiding race conditions and ensuring proper data flow between host and device.
thinking
**Detailing GPU data mapping and kernel structure**

I'm laying out a detailed implementation plan for the GPU offload section, defining how to map all necessary arrays and scalars—including `lambda` and dynamically updated `q0sqr`—to the device within a `target data` region, then running ROI reduction and derivative/divergence loops using `target teams loop` directives with proper mapping, thread limits, and collapse clauses. I'll also plan on clean builds and header includes to support these changes.
thinking
**Preparing for GPU code refactor and include updates**

I'm planning to clean up the GPU code by removing old loops and pragma comments, adjusting indentation, and adding proper `#pragma omp` directives for reductions and loops. I'll also add necessary includes like `<stdio.h>` and `<omp.h>`, and carefully craft a patch to replace the GPU block with a clean, well-structured implementation.
file update
M /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/srad-omp/main.c
@@ -23,2 +23,3 @@
 
+#include <stdio.h>
 #include <stdlib.h>
@@ -26,2 +27,3 @@
 #include <string.h>
+#include <omp.h>
 
@@ -541,3 +543,2 @@
 }
-
 
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M data/src/srad-omp/main.c
file update:
diff --git a/src/srad-omp/main.c b/src/srad-omp/main.c
index 460fb9a007db407f4f80ff00c0a7395bbc4ead01..7fc49e521ecda6440757abe87a229432cad98a0c
--- a/src/srad-omp/main.c
+++ b/src/srad-omp/main.c
@@ -21,9 +21,11 @@
 //	DEFINE / INCLUDE
 //====================================================================================================100
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
+#include <omp.h>
 
 #include "define.c"
 #include "graphics.c"
@@ -539,5 +541,4 @@
 //====================================================================================================100
 
 }
-
 


thinking
**Replacing GPU computation block**
file update:
diff --git a/src/srad-omp/main.c b/src/srad-omp/main.c
index 460fb9a007db407f4f80ff00c0a7395bbc4ead01..7fc49e521ecda6440757abe87a229432cad98a0c
--- a/src/srad-omp/main.c
+++ b/src/srad-omp/main.c
@@ -21,9 +21,11 @@
 //	DEFINE / INCLUDE
 //====================================================================================================100
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
+#include <omp.h>
 
 #include "define.c"
 #include "graphics.c"
@@ -539,5 +541,4 @@
 //====================================================================================================100
 
 }
-
 

file update
M /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/srad-omp/main.c
@@ -345,95 +345,75 @@
 	t_start = rtclock();
-//                map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne], image[:Ne]) - removed - left over grom removing pragma
 
+#pragma omp target data device(GPU_DEVICE) \
+	map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], lambda, Nr, Nc, r1, r2, c1, c2) \
+	map(tofrom: image[:Ne], q0sqr) \
+	map(alloc: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
 	{
 	for (iter = 0; iter < niter; iter++) {// do for the number of iterations input parameter
-
 
-		// ROI statistics for entire ROI (single number for ROI)
 		sum = 0;
 		sum2 = 0;
-		for (i = r1; i <= r2; i++) {		// do for the range of rows in ROI
-			for (j = c1; j <= c2; j++) {// do for the range of columns in ROI
-				tmp = image[i + Nr * j];	// get coresponding value in IMAGE
-				sum += tmp;			// take corresponding value and add to sum
-				sum2 += tmp * tmp;// take square of corresponding value and add to sum2
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256) reduction(+:sum,sum2)
+		for (j = c1; j <= c2; j++) {
+			for (i = r1; i <= r2; i++) {
+				fp tmp_loc = image[i + Nr * j];
+				sum += tmp_loc;
+				sum2 += tmp_loc * tmp_loc;
 			}
 		}
-		meanROI = sum / NeROI;	// gets mean (average) value of element in ROI
-		varROI = (sum2 / NeROI) - meanROI * meanROI;	// gets variance of ROI
-		q0sqr = varROI / (meanROI * meanROI);// gets standard deviation of ROI
 
-		// directional derivatives, ICOV, diffusion coefficent
-	
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], image[:Ne] ) \
-	//	map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-			for (i = 0; i < Nr; i++) {	// do for the range of rows in IMAGE 
-				// current index/pixel
-				k = i + Nr * j;				// get position of current element
-				Jc = image[k];				// get value of the current element
+		meanROI = sum / NeROI;
+		varROI = (sum2 / NeROI) - meanROI * meanROI;
+		q0sqr = varROI / (meanROI * meanROI);
 
-				// directional derivates (every element of IMAGE)
-				dN[k] = image[iN[i] + Nr * j] - Jc;	// north direction derivative
-				dS[k] = image[iS[i] + Nr * j] - Jc;	// south direction derivative
-				dW[k] = image[i + Nr * jW[j]] - Jc;	// west direction derivative
-				dE[k] = image[i + Nr * jE[j]] - Jc;	// east direction derivative
+#pragma omp target update to(q0sqr) device(GPU_DEVICE)
 
-				// normalized discrete gradient mag squared (equ 52,53)
-				G2 = (dN[k] * dN[k] + dS[k] * dS[k]	// gradient (based on derivatives)
-				+ dW[k] * dW[k] + dE[k] * dE[k]) / (Jc * Jc);
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+		for (j = 0; j < Nc; j++) {
+			for (i = 0; i < Nr; i++) {
+				int k = i + Nr * j;
+				fp center = image[k];
+				fp north = image[iN[i] + Nr * j];
+				fp south = image[iS[i] + Nr * j];
+				fp west = image[i + Nr * jW[j]];
+				fp east = image[i + Nr * jE[j]];
 
-				// normalized discrete laplacian (equ 54)
-				L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;// laplacian (based on derivatives)
+				dN[k] = north - center;
+				dS[k] = south - center;
+				dW[k] = west - center;
+				dE[k] = east - center;
 
-				// ICOV (equ 31/35)
-				num = (0.5 * G2) - ((1.0 / 16.0) * (L * L));// num (based on gradient and laplacian)
-				den = 1 + (.25 * L);				// den (based on laplacian)
-				qsqr = num / (den * den);		// qsqr (based on num and den)
+				fp gradient = (dN[k] * dN[k] + dS[k] * dS[k] + dW[k] * dW[k] + dE[k] * dE[k]) / (center * center);
+				fp laplacian = (dN[k] + dS[k] + dW[k] + dE[k]) / center;
+				fp numerator = (0.5f * gradient) - ((1.0f / 16.0f) * (laplacian * laplacian));
+				fp denominator = 1.0f + (0.25f * laplacian);
+				fp qsqr = numerator / (denominator * denominator);
+				denominator = (qsqr - q0sqr) / (q0sqr * (1.0f + q0sqr));
+				fp diff_coef = 1.0f / (1.0f + denominator);
 
-				// diffusion coefficent (equ 33) (every element of IMAGE)
-				den = (qsqr - q0sqr) / (q0sqr * (1 + q0sqr));// den (based on qsqr and q0sqr)
-				c[k] = 1.0 / (1.0 + den);// diffusion coefficient (based on den)
-
-				// saturate diffusion coefficent to 0-1 range
-				if (c[k] < 0)		// if diffusion coefficient < 0
+				if (diff_coef < 0.0f)
 				{
-					c[k] = 0;	// ... set to 0
+					diff_coef = 0.0f;
 				}
-				else if (c[k] > 1)	// if diffusion coefficient > 1
+				else if (diff_coef > 1.0f)
 				{
-					c[k] = 1;	// ... set to 1
-				}			
+					diff_coef = 1.0f;
+				}
 
+				c[k] = diff_coef;
 			}
 		}
-	//	}
-		
-		// divergence & image update
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: c[:Ne], iS[:Nr], jE[:Nc], dN[:Ne], dS[:Ne],  dW[:Ne], dE[:Ne] ) \
-		map(tofrom: image[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
 
-
-			for (i = 0; i < Nr; i++) {		// do for the range of rows in IMAGE
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+		for (j = 0; j < Nc; j++) {
+			for (i = 0; i < Nr; i++) {
+				int k = i + Nr * j;
+				fp cN_loc = c[k];
+				fp cS_loc = c[iS[i] + Nr * j];
+				fp cW_loc = c[k];
+				fp cE_loc = c[i + Nr * jE[j]];
 
-				// current index
-				k = i + Nr * j;				// get position of current element
-
-				// diffusion coefficent
-				cN = c[k];						// north diffusion coefficient
-				cS = c[iS[i] + Nr * j];			// south diffusion coefficient
-				cW = c[k];						// west diffusion coefficient
-				cE = c[i + Nr * jE[j]];			// east diffusion coefficient
+				fp divergence = cN_loc * dN[k] + cS_loc * dS[k] + cW_loc * dW[k] + cE_loc * dE[k];
+				image[k] = image[k] + 0.25f * lambda * divergence;
 
-				// divergence (equ 58)
-				D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];// divergence
-
-				// image update (equ 61) (every element of IMAGE)
-				image[k] = image[k] + 0.25 * lambda * D;// updates image (based on input time step and divergence)
-
 			}
@@ -441,3 +421,2 @@
 		}
-	 //	}
 
@@ -543,2 +522 @@
 }
-
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/srad-omp/main.c
file update:
diff --git a/src/srad-omp/main.c b/src/srad-omp/main.c
index 460fb9a007db407f4f80ff00c0a7395bbc4ead01..86fee8c43744f69a1b50e15bb9a38c72492f53a0
--- a/src/srad-omp/main.c
+++ b/src/srad-omp/main.c
@@ -21,9 +21,11 @@
 //	DEFINE / INCLUDE
 //====================================================================================================100
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
+#include <omp.h>
 
 #include "define.c"
 #include "graphics.c"
@@ -341,103 +343,82 @@
 
 	//GPU
 	t_start = rtclock();
-//                map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne], image[:Ne]) - removed - left over grom removing pragma
 
+#pragma omp target data device(GPU_DEVICE) \
+	map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], lambda, Nr, Nc, r1, r2, c1, c2) \
+	map(tofrom: image[:Ne], q0sqr) \
+	map(alloc: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
 	{
 	for (iter = 0; iter < niter; iter++) {// do for the number of iterations input parameter
-
 
-		// ROI statistics for entire ROI (single number for ROI)
 		sum = 0;
 		sum2 = 0;
-		for (i = r1; i <= r2; i++) {		// do for the range of rows in ROI
-			for (j = c1; j <= c2; j++) {// do for the range of columns in ROI
-				tmp = image[i + Nr * j];	// get coresponding value in IMAGE
-				sum += tmp;			// take corresponding value and add to sum
-				sum2 += tmp * tmp;// take square of corresponding value and add to sum2
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256) reduction(+:sum,sum2)
+		for (j = c1; j <= c2; j++) {
+			for (i = r1; i <= r2; i++) {
+				fp tmp_loc = image[i + Nr * j];
+				sum += tmp_loc;
+				sum2 += tmp_loc * tmp_loc;
 			}
 		}
-		meanROI = sum / NeROI;	// gets mean (average) value of element in ROI
-		varROI = (sum2 / NeROI) - meanROI * meanROI;	// gets variance of ROI
-		q0sqr = varROI / (meanROI * meanROI);// gets standard deviation of ROI
 
-		// directional derivatives, ICOV, diffusion coefficent
-	
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], image[:Ne] ) \
-	//	map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-			for (i = 0; i < Nr; i++) {	// do for the range of rows in IMAGE 
-				// current index/pixel
-				k = i + Nr * j;				// get position of current element
-				Jc = image[k];				// get value of the current element
+		meanROI = sum / NeROI;
+		varROI = (sum2 / NeROI) - meanROI * meanROI;
+		q0sqr = varROI / (meanROI * meanROI);
 
-				// directional derivates (every element of IMAGE)
-				dN[k] = image[iN[i] + Nr * j] - Jc;	// north direction derivative
-				dS[k] = image[iS[i] + Nr * j] - Jc;	// south direction derivative
-				dW[k] = image[i + Nr * jW[j]] - Jc;	// west direction derivative
-				dE[k] = image[i + Nr * jE[j]] - Jc;	// east direction derivative
-
-				// normalized discrete gradient mag squared (equ 52,53)
-				G2 = (dN[k] * dN[k] + dS[k] * dS[k]	// gradient (based on derivatives)
-				+ dW[k] * dW[k] + dE[k] * dE[k]) / (Jc * Jc);
+#pragma omp target update to(q0sqr) device(GPU_DEVICE)
 
-				// normalized discrete laplacian (equ 54)
-				L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;// laplacian (based on derivatives)
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+		for (j = 0; j < Nc; j++) {
+			for (i = 0; i < Nr; i++) {
+				int k = i + Nr * j;
+				fp center = image[k];
+				fp north = image[iN[i] + Nr * j];
+				fp south = image[iS[i] + Nr * j];
+				fp west = image[i + Nr * jW[j]];
+				fp east = image[i + Nr * jE[j]];
 
-				// ICOV (equ 31/35)
-				num = (0.5 * G2) - ((1.0 / 16.0) * (L * L));// num (based on gradient and laplacian)
-				den = 1 + (.25 * L);				// den (based on laplacian)
-				qsqr = num / (den * den);		// qsqr (based on num and den)
+				dN[k] = north - center;
+				dS[k] = south - center;
+				dW[k] = west - center;
+				dE[k] = east - center;
 
-				// diffusion coefficent (equ 33) (every element of IMAGE)
-				den = (qsqr - q0sqr) / (q0sqr * (1 + q0sqr));// den (based on qsqr and q0sqr)
-				c[k] = 1.0 / (1.0 + den);// diffusion coefficient (based on den)
+				fp gradient = (dN[k] * dN[k] + dS[k] * dS[k] + dW[k] * dW[k] + dE[k] * dE[k]) / (center * center);
+				fp laplacian = (dN[k] + dS[k] + dW[k] + dE[k]) / center;
+				fp numerator = (0.5f * gradient) - ((1.0f / 16.0f) * (laplacian * laplacian));
+				fp denominator = 1.0f + (0.25f * laplacian);
+				fp qsqr = numerator / (denominator * denominator);
+				denominator = (qsqr - q0sqr) / (q0sqr * (1.0f + q0sqr));
+				fp diff_coef = 1.0f / (1.0f + denominator);
 
-				// saturate diffusion coefficent to 0-1 range
-				if (c[k] < 0)		// if diffusion coefficient < 0
+				if (diff_coef < 0.0f)
 				{
-					c[k] = 0;	// ... set to 0
+					diff_coef = 0.0f;
 				}
-				else if (c[k] > 1)	// if diffusion coefficient > 1
+				else if (diff_coef > 1.0f)
 				{
-					c[k] = 1;	// ... set to 1
-				}			
+					diff_coef = 1.0f;
+				}
 
+				c[k] = diff_coef;
 			}
 		}
-	//	}
-		
-		// divergence & image update
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: c[:Ne], iS[:Nr], jE[:Nc], dN[:Ne], dS[:Ne],  dW[:Ne], dE[:Ne] ) \
-		map(tofrom: image[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-
-
-			for (i = 0; i < Nr; i++) {		// do for the range of rows in IMAGE
-
-				// current index
-				k = i + Nr * j;				// get position of current element
 
-				// diffusion coefficent
-				cN = c[k];						// north diffusion coefficient
-				cS = c[iS[i] + Nr * j];			// south diffusion coefficient
-				cW = c[k];						// west diffusion coefficient
-				cE = c[i + Nr * jE[j]];			// east diffusion coefficient
-
-				// divergence (equ 58)
-				D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];// divergence
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+		for (j = 0; j < Nc; j++) {
+			for (i = 0; i < Nr; i++) {
+				int k = i + Nr * j;
+				fp cN_loc = c[k];
+				fp cS_loc = c[iS[i] + Nr * j];
+				fp cW_loc = c[k];
+				fp cE_loc = c[i + Nr * jE[j]];
 
-				// image update (equ 61) (every element of IMAGE)
-				image[k] = image[k] + 0.25 * lambda * D;// updates image (based on input time step and divergence)
+				fp divergence = cN_loc * dN[k] + cS_loc * dS[k] + cW_loc * dW[k] + cE_loc * dE[k];
+				image[k] = image[k] + 0.25f * lambda * divergence;
 
 			}
 
 		}
-	 //	}
 
 	}
 	}
@@ -539,5 +520,3 @@
 //====================================================================================================100
 
 }
-
-


thinking
**Verifying and fixing indentation**
file update:
diff --git a/src/srad-omp/main.c b/src/srad-omp/main.c
index 460fb9a007db407f4f80ff00c0a7395bbc4ead01..86fee8c43744f69a1b50e15bb9a38c72492f53a0
--- a/src/srad-omp/main.c
+++ b/src/srad-omp/main.c
@@ -21,9 +21,11 @@
 //	DEFINE / INCLUDE
 //====================================================================================================100
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
+#include <omp.h>
 
 #include "define.c"
 #include "graphics.c"
@@ -341,103 +343,82 @@
 
 	//GPU
 	t_start = rtclock();
-//                map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne], image[:Ne]) - removed - left over grom removing pragma
 
+#pragma omp target data device(GPU_DEVICE) \
+	map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], lambda, Nr, Nc, r1, r2, c1, c2) \
+	map(tofrom: image[:Ne], q0sqr) \
+	map(alloc: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
 	{
 	for (iter = 0; iter < niter; iter++) {// do for the number of iterations input parameter
-
 
-		// ROI statistics for entire ROI (single number for ROI)
 		sum = 0;
 		sum2 = 0;
-		for (i = r1; i <= r2; i++) {		// do for the range of rows in ROI
-			for (j = c1; j <= c2; j++) {// do for the range of columns in ROI
-				tmp = image[i + Nr * j];	// get coresponding value in IMAGE
-				sum += tmp;			// take corresponding value and add to sum
-				sum2 += tmp * tmp;// take square of corresponding value and add to sum2
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256) reduction(+:sum,sum2)
+		for (j = c1; j <= c2; j++) {
+			for (i = r1; i <= r2; i++) {
+				fp tmp_loc = image[i + Nr * j];
+				sum += tmp_loc;
+				sum2 += tmp_loc * tmp_loc;
 			}
 		}
-		meanROI = sum / NeROI;	// gets mean (average) value of element in ROI
-		varROI = (sum2 / NeROI) - meanROI * meanROI;	// gets variance of ROI
-		q0sqr = varROI / (meanROI * meanROI);// gets standard deviation of ROI
 
-		// directional derivatives, ICOV, diffusion coefficent
-	
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], image[:Ne] ) \
-	//	map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-			for (i = 0; i < Nr; i++) {	// do for the range of rows in IMAGE 
-				// current index/pixel
-				k = i + Nr * j;				// get position of current element
-				Jc = image[k];				// get value of the current element
+		meanROI = sum / NeROI;
+		varROI = (sum2 / NeROI) - meanROI * meanROI;
+		q0sqr = varROI / (meanROI * meanROI);
 
-				// directional derivates (every element of IMAGE)
-				dN[k] = image[iN[i] + Nr * j] - Jc;	// north direction derivative
-				dS[k] = image[iS[i] + Nr * j] - Jc;	// south direction derivative
-				dW[k] = image[i + Nr * jW[j]] - Jc;	// west direction derivative
-				dE[k] = image[i + Nr * jE[j]] - Jc;	// east direction derivative
-
-				// normalized discrete gradient mag squared (equ 52,53)
-				G2 = (dN[k] * dN[k] + dS[k] * dS[k]	// gradient (based on derivatives)
-				+ dW[k] * dW[k] + dE[k] * dE[k]) / (Jc * Jc);
+#pragma omp target update to(q0sqr) device(GPU_DEVICE)
 
-				// normalized discrete laplacian (equ 54)
-				L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;// laplacian (based on derivatives)
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+		for (j = 0; j < Nc; j++) {
+			for (i = 0; i < Nr; i++) {
+				int k = i + Nr * j;
+				fp center = image[k];
+				fp north = image[iN[i] + Nr * j];
+				fp south = image[iS[i] + Nr * j];
+				fp west = image[i + Nr * jW[j]];
+				fp east = image[i + Nr * jE[j]];
 
-				// ICOV (equ 31/35)
-				num = (0.5 * G2) - ((1.0 / 16.0) * (L * L));// num (based on gradient and laplacian)
-				den = 1 + (.25 * L);				// den (based on laplacian)
-				qsqr = num / (den * den);		// qsqr (based on num and den)
+				dN[k] = north - center;
+				dS[k] = south - center;
+				dW[k] = west - center;
+				dE[k] = east - center;
 
-				// diffusion coefficent (equ 33) (every element of IMAGE)
-				den = (qsqr - q0sqr) / (q0sqr * (1 + q0sqr));// den (based on qsqr and q0sqr)
-				c[k] = 1.0 / (1.0 + den);// diffusion coefficient (based on den)
+				fp gradient = (dN[k] * dN[k] + dS[k] * dS[k] + dW[k] * dW[k] + dE[k] * dE[k]) / (center * center);
+				fp laplacian = (dN[k] + dS[k] + dW[k] + dE[k]) / center;
+				fp numerator = (0.5f * gradient) - ((1.0f / 16.0f) * (laplacian * laplacian));
+				fp denominator = 1.0f + (0.25f * laplacian);
+				fp qsqr = numerator / (denominator * denominator);
+				denominator = (qsqr - q0sqr) / (q0sqr * (1.0f + q0sqr));
+				fp diff_coef = 1.0f / (1.0f + denominator);
 
-				// saturate diffusion coefficent to 0-1 range
-				if (c[k] < 0)		// if diffusion coefficient < 0
+				if (diff_coef < 0.0f)
 				{
-					c[k] = 0;	// ... set to 0
+					diff_coef = 0.0f;
 				}
-				else if (c[k] > 1)	// if diffusion coefficient > 1
+				else if (diff_coef > 1.0f)
 				{
-					c[k] = 1;	// ... set to 1
-				}			
+					diff_coef = 1.0f;
+				}
 
+				c[k] = diff_coef;
 			}
 		}
-	//	}
-		
-		// divergence & image update
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: c[:Ne], iS[:Nr], jE[:Nc], dN[:Ne], dS[:Ne],  dW[:Ne], dE[:Ne] ) \
-		map(tofrom: image[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-
-
-			for (i = 0; i < Nr; i++) {		// do for the range of rows in IMAGE
-
-				// current index
-				k = i + Nr * j;				// get position of current element
 
-				// diffusion coefficent
-				cN = c[k];						// north diffusion coefficient
-				cS = c[iS[i] + Nr * j];			// south diffusion coefficient
-				cW = c[k];						// west diffusion coefficient
-				cE = c[i + Nr * jE[j]];			// east diffusion coefficient
-
-				// divergence (equ 58)
-				D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];// divergence
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+		for (j = 0; j < Nc; j++) {
+			for (i = 0; i < Nr; i++) {
+				int k = i + Nr * j;
+				fp cN_loc = c[k];
+				fp cS_loc = c[iS[i] + Nr * j];
+				fp cW_loc = c[k];
+				fp cE_loc = c[i + Nr * jE[j]];
 
-				// image update (equ 61) (every element of IMAGE)
-				image[k] = image[k] + 0.25 * lambda * D;// updates image (based on input time step and divergence)
+				fp divergence = cN_loc * dN[k] + cS_loc * dS[k] + cW_loc * dW[k] + cE_loc * dE[k];
+				image[k] = image[k] + 0.25f * lambda * divergence;
 
 			}
 
 		}
-	 //	}
 
 	}
 	}
@@ -539,5 +520,3 @@
 //====================================================================================================100
 
 }
-
-

exec
/bin/bash -lc "sed -n '300,520p' data/src/srad-omp/main.c" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 7ms:

				// saturate diffusion coefficent to 0-1 range
				if (c[k] < 0)		// if diffusion coefficient < 0
				{
					c[k] = 0;	// ... set to 0
				}
				else if (c[k] > 1)	// if diffusion coefficient > 1
				{
					c[k] = 1;	// ... set to 1
				}			

			}
		}
		
		// divergence & image update
		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE


			for (i = 0; i < Nr; i++) {		// do for the range of rows in IMAGE


thinking
**Reformatting OpenMP pragma indentation**
file update:
diff --git a/src/srad-omp/main.c b/src/srad-omp/main.c
index 460fb9a007db407f4f80ff00c0a7395bbc4ead01..86fee8c43744f69a1b50e15bb9a38c72492f53a0
--- a/src/srad-omp/main.c
+++ b/src/srad-omp/main.c
@@ -21,9 +21,11 @@
 //	DEFINE / INCLUDE
 //====================================================================================================100
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
+#include <omp.h>
 
 #include "define.c"
 #include "graphics.c"
@@ -341,103 +343,82 @@
 
 	//GPU
 	t_start = rtclock();
-//                map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne], image[:Ne]) - removed - left over grom removing pragma
 
+#pragma omp target data device(GPU_DEVICE) \
+	map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], lambda, Nr, Nc, r1, r2, c1, c2) \
+	map(tofrom: image[:Ne], q0sqr) \
+	map(alloc: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
 	{
 	for (iter = 0; iter < niter; iter++) {// do for the number of iterations input parameter
-
 
-		// ROI statistics for entire ROI (single number for ROI)
 		sum = 0;
 		sum2 = 0;
-		for (i = r1; i <= r2; i++) {		// do for the range of rows in ROI
-			for (j = c1; j <= c2; j++) {// do for the range of columns in ROI
-				tmp = image[i + Nr * j];	// get coresponding value in IMAGE
-				sum += tmp;			// take corresponding value and add to sum
-				sum2 += tmp * tmp;// take square of corresponding value and add to sum2
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256) reduction(+:sum,sum2)
+		for (j = c1; j <= c2; j++) {
+			for (i = r1; i <= r2; i++) {
+				fp tmp_loc = image[i + Nr * j];
+				sum += tmp_loc;
+				sum2 += tmp_loc * tmp_loc;
 			}
 		}
-		meanROI = sum / NeROI;	// gets mean (average) value of element in ROI
-		varROI = (sum2 / NeROI) - meanROI * meanROI;	// gets variance of ROI
-		q0sqr = varROI / (meanROI * meanROI);// gets standard deviation of ROI
 
-		// directional derivatives, ICOV, diffusion coefficent
-	
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], image[:Ne] ) \
-	//	map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-			for (i = 0; i < Nr; i++) {	// do for the range of rows in IMAGE 
-				// current index/pixel
-				k = i + Nr * j;				// get position of current element
-				Jc = image[k];				// get value of the current element
+		meanROI = sum / NeROI;
+		varROI = (sum2 / NeROI) - meanROI * meanROI;
+		q0sqr = varROI / (meanROI * meanROI);
 
-				// directional derivates (every element of IMAGE)
-				dN[k] = image[iN[i] + Nr * j] - Jc;	// north direction derivative
-				dS[k] = image[iS[i] + Nr * j] - Jc;	// south direction derivative
-				dW[k] = image[i + Nr * jW[j]] - Jc;	// west direction derivative
-				dE[k] = image[i + Nr * jE[j]] - Jc;	// east direction derivative
-
-				// normalized discrete gradient mag squared (equ 52,53)
-				G2 = (dN[k] * dN[k] + dS[k] * dS[k]	// gradient (based on derivatives)
-				+ dW[k] * dW[k] + dE[k] * dE[k]) / (Jc * Jc);
+#pragma omp target update to(q0sqr) device(GPU_DEVICE)
 
-				// normalized discrete laplacian (equ 54)
-				L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;// laplacian (based on derivatives)
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+		for (j = 0; j < Nc; j++) {
+			for (i = 0; i < Nr; i++) {
+				int k = i + Nr * j;
+				fp center = image[k];
+				fp north = image[iN[i] + Nr * j];
+				fp south = image[iS[i] + Nr * j];
+				fp west = image[i + Nr * jW[j]];
+				fp east = image[i + Nr * jE[j]];
 
-				// ICOV (equ 31/35)
-				num = (0.5 * G2) - ((1.0 / 16.0) * (L * L));// num (based on gradient and laplacian)
-				den = 1 + (.25 * L);				// den (based on laplacian)
-				qsqr = num / (den * den);		// qsqr (based on num and den)
+				dN[k] = north - center;
+				dS[k] = south - center;
+				dW[k] = west - center;
+				dE[k] = east - center;
 
-				// diffusion coefficent (equ 33) (every element of IMAGE)
-				den = (qsqr - q0sqr) / (q0sqr * (1 + q0sqr));// den (based on qsqr and q0sqr)
-				c[k] = 1.0 / (1.0 + den);// diffusion coefficient (based on den)
+				fp gradient = (dN[k] * dN[k] + dS[k] * dS[k] + dW[k] * dW[k] + dE[k] * dE[k]) / (center * center);
+				fp laplacian = (dN[k] + dS[k] + dW[k] + dE[k]) / center;
+				fp numerator = (0.5f * gradient) - ((1.0f / 16.0f) * (laplacian * laplacian));
+				fp denominator = 1.0f + (0.25f * laplacian);
+				fp qsqr = numerator / (denominator * denominator);
+				denominator = (qsqr - q0sqr) / (q0sqr * (1.0f + q0sqr));
+				fp diff_coef = 1.0f / (1.0f + denominator);
 
-				// saturate diffusion coefficent to 0-1 range
-				if (c[k] < 0)		// if diffusion coefficient < 0
+				if (diff_coef < 0.0f)
 				{
-					c[k] = 0;	// ... set to 0
+					diff_coef = 0.0f;
 				}
-				else if (c[k] > 1)	// if diffusion coefficient > 1
+				else if (diff_coef > 1.0f)
 				{
-					c[k] = 1;	// ... set to 1
-				}			
+					diff_coef = 1.0f;
+				}
 
+				c[k] = diff_coef;
 			}
 		}
-	//	}
-		
-		// divergence & image update
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: c[:Ne], iS[:Nr], jE[:Nc], dN[:Ne], dS[:Ne],  dW[:Ne], dE[:Ne] ) \
-		map(tofrom: image[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-
-
-			for (i = 0; i < Nr; i++) {		// do for the range of rows in IMAGE
-
-				// current index
-				k = i + Nr * j;				// get position of current element
 
-				// diffusion coefficent
-				cN = c[k];						// north diffusion coefficient
-				cS = c[iS[i] + Nr * j];			// south diffusion coefficient
-				cW = c[k];						// west diffusion coefficient
-				cE = c[i + Nr * jE[j]];			// east diffusion coefficient
-
-				// divergence (equ 58)
-				D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];// divergence
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+		for (j = 0; j < Nc; j++) {
+			for (i = 0; i < Nr; i++) {
+				int k = i + Nr * j;
+				fp cN_loc = c[k];
+				fp cS_loc = c[iS[i] + Nr * j];
+				fp cW_loc = c[k];
+				fp cE_loc = c[i + Nr * jE[j]];
 
-				// image update (equ 61) (every element of IMAGE)
-				image[k] = image[k] + 0.25 * lambda * D;// updates image (based on input time step and divergence)
+				fp divergence = cN_loc * dN[k] + cS_loc * dS[k] + cW_loc * dW[k] + cE_loc * dE[k];
+				image[k] = image[k] + 0.25f * lambda * divergence;
 
 			}
 
 		}
-	 //	}
 
 	}
 	}
@@ -539,5 +520,3 @@
 //====================================================================================================100
 
 }
-
-

file update
M /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/srad-omp/main.c
@@ -346,23 +346,23 @@
 
-#pragma omp target data device(GPU_DEVICE) \
-	map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], lambda, Nr, Nc, r1, r2, c1, c2) \
-	map(tofrom: image[:Ne], q0sqr) \
-	map(alloc: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
+	#pragma omp target data device(GPU_DEVICE) \
+		map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], lambda, Nr, Nc, r1, r2, c1, c2) \
+		map(tofrom: image[:Ne], q0sqr) \
+		map(alloc: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
 	{
-	for (iter = 0; iter < niter; iter++) {// do for the number of iterations input parameter
+		for (iter = 0; iter < niter; iter++) { // do for the number of iterations input parameter
 
-		sum = 0;
-		sum2 = 0;
+			sum = 0;
+			sum2 = 0;
 #pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256) reduction(+:sum,sum2)
-		for (j = c1; j <= c2; j++) {
-			for (i = r1; i <= r2; i++) {
-				fp tmp_loc = image[i + Nr * j];
-				sum += tmp_loc;
-				sum2 += tmp_loc * tmp_loc;
+			for (j = c1; j <= c2; j++) {
+				for (i = r1; i <= r2; i++) {
+					fp tmp_loc = image[i + Nr * j];
+					sum += tmp_loc;
+					sum2 += tmp_loc * tmp_loc;
+				}
 			}
-		}
 
-		meanROI = sum / NeROI;
-		varROI = (sum2 / NeROI) - meanROI * meanROI;
-		q0sqr = varROI / (meanROI * meanROI);
+			meanROI = sum / NeROI;
+			varROI = (sum2 / NeROI) - meanROI * meanROI;
+			q0sqr = varROI / (meanROI * meanROI);
 
@@ -371,48 +371,50 @@
 #pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
-		for (j = 0; j < Nc; j++) {
-			for (i = 0; i < Nr; i++) {
-				int k = i + Nr * j;
-				fp center = image[k];
-				fp north = image[iN[i] + Nr * j];
-				fp south = image[iS[i] + Nr * j];
-				fp west = image[i + Nr * jW[j]];
-				fp east = image[i + Nr * jE[j]];
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp center = image[k];
+					fp north = image[iN[i] + Nr * j];
+					fp south = image[iS[i] + Nr * j];
+					fp west = image[i + Nr * jW[j]];
+					fp east = image[i + Nr * jE[j]];
+
+					dN[k] = north - center;
+					dS[k] = south - center;
+					dW[k] = west - center;
+					dE[k] = east - center;
 
-				dN[k] = north - center;
-				dS[k] = south - center;
-				dW[k] = west - center;
-				dE[k] = east - center;
+					fp gradient = (dN[k] * dN[k] + dS[k] * dS[k] + dW[k] * dW[k] + dE[k] * dE[k]) / (center * center);
+					fp laplacian = (dN[k] + dS[k] + dW[k] + dE[k]) / center;
+					fp numerator = (0.5f * gradient) - ((1.0f / 16.0f) * (laplacian * laplacian));
+					fp denominator = 1.0f + (0.25f * laplacian);
+					fp qsqr = numerator / (denominator * denominator);
+					denominator = (qsqr - q0sqr) / (q0sqr * (1.0f + q0sqr));
+					fp diff_coef = 1.0f / (1.0f + denominator);
 
-				fp gradient = (dN[k] * dN[k] + dS[k] * dS[k] + dW[k] * dW[k] + dE[k] * dE[k]) / (center * center);
-				fp laplacian = (dN[k] + dS[k] + dW[k] + dE[k]) / center;
-				fp numerator = (0.5f * gradient) - ((1.0f / 16.0f) * (laplacian * laplacian));
-				fp denominator = 1.0f + (0.25f * laplacian);
-				fp qsqr = numerator / (denominator * denominator);
-				denominator = (qsqr - q0sqr) / (q0sqr * (1.0f + q0sqr));
-				fp diff_coef = 1.0f / (1.0f + denominator);
+					if (diff_coef < 0.0f)
+					{
+						diff_coef = 0.0f;
+					}
+					else if (diff_coef > 1.0f)
+					{
+						diff_coef = 1.0f;
+					}
 
-				if (diff_coef < 0.0f)
-				{
-					diff_coef = 0.0f;
-				}
-				else if (diff_coef > 1.0f)
-				{
-					diff_coef = 1.0f;
+					c[k] = diff_coef;
 				}
-
-				c[k] = diff_coef;
 			}
-		}
 
 #pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
-		for (j = 0; j < Nc; j++) {
-			for (i = 0; i < Nr; i++) {
-				int k = i + Nr * j;
-				fp cN_loc = c[k];
-				fp cS_loc = c[iS[i] + Nr * j];
-				fp cW_loc = c[k];
-				fp cE_loc = c[i + Nr * jE[j]];
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp cN_loc = c[k];
+					fp cS_loc = c[iS[i] + Nr * j];
+					fp cW_loc = c[k];
+					fp cE_loc = c[i + Nr * jE[j]];
+
+					fp divergence = cN_loc * dN[k] + cS_loc * dS[k] + cW_loc * dW[k] + cE_loc * dE[k];
+					image[k] = image[k] + 0.25f * lambda * divergence;
 
-				fp divergence = cN_loc * dN[k] + cS_loc * dS[k] + cW_loc * dW[k] + cE_loc * dE[k];
-				image[k] = image[k] + 0.25f * lambda * divergence;
+				}
 
@@ -421,4 +423,2 @@
 		}
-
-	}
 	}
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/srad-omp/main.c
file update:
diff --git a/src/srad-omp/main.c b/src/srad-omp/main.c
index 460fb9a007db407f4f80ff00c0a7395bbc4ead01..6b081525a5c764d4d14ff961f53308fec6698860
--- a/src/srad-omp/main.c
+++ b/src/srad-omp/main.c
@@ -21,9 +21,11 @@
 //	DEFINE / INCLUDE
 //====================================================================================================100
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
+#include <omp.h>
 
 #include "define.c"
 #include "graphics.c"
@@ -341,105 +343,84 @@
 
 	//GPU
 	t_start = rtclock();
-//                map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne], image[:Ne]) - removed - left over grom removing pragma
 
+	#pragma omp target data device(GPU_DEVICE) \
+		map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], lambda, Nr, Nc, r1, r2, c1, c2) \
+		map(tofrom: image[:Ne], q0sqr) \
+		map(alloc: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
 	{
-	for (iter = 0; iter < niter; iter++) {// do for the number of iterations input parameter
+		for (iter = 0; iter < niter; iter++) { // do for the number of iterations input parameter
 
-
-		// ROI statistics for entire ROI (single number for ROI)
-		sum = 0;
-		sum2 = 0;
-		for (i = r1; i <= r2; i++) {		// do for the range of rows in ROI
-			for (j = c1; j <= c2; j++) {// do for the range of columns in ROI
-				tmp = image[i + Nr * j];	// get coresponding value in IMAGE
-				sum += tmp;			// take corresponding value and add to sum
-				sum2 += tmp * tmp;// take square of corresponding value and add to sum2
+			sum = 0;
+			sum2 = 0;
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256) reduction(+:sum,sum2)
+			for (j = c1; j <= c2; j++) {
+				for (i = r1; i <= r2; i++) {
+					fp tmp_loc = image[i + Nr * j];
+					sum += tmp_loc;
+					sum2 += tmp_loc * tmp_loc;
+				}
 			}
-		}
-		meanROI = sum / NeROI;	// gets mean (average) value of element in ROI
-		varROI = (sum2 / NeROI) - meanROI * meanROI;	// gets variance of ROI
-		q0sqr = varROI / (meanROI * meanROI);// gets standard deviation of ROI
 
-		// directional derivatives, ICOV, diffusion coefficent
-	
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], image[:Ne] ) \
-	//	map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-			for (i = 0; i < Nr; i++) {	// do for the range of rows in IMAGE 
-				// current index/pixel
-				k = i + Nr * j;				// get position of current element
-				Jc = image[k];				// get value of the current element
+			meanROI = sum / NeROI;
+			varROI = (sum2 / NeROI) - meanROI * meanROI;
+			q0sqr = varROI / (meanROI * meanROI);
 
-				// directional derivates (every element of IMAGE)
-				dN[k] = image[iN[i] + Nr * j] - Jc;	// north direction derivative
-				dS[k] = image[iS[i] + Nr * j] - Jc;	// south direction derivative
-				dW[k] = image[i + Nr * jW[j]] - Jc;	// west direction derivative
-				dE[k] = image[i + Nr * jE[j]] - Jc;	// east direction derivative
+#pragma omp target update to(q0sqr) device(GPU_DEVICE)
 
-				// normalized discrete gradient mag squared (equ 52,53)
-				G2 = (dN[k] * dN[k] + dS[k] * dS[k]	// gradient (based on derivatives)
-				+ dW[k] * dW[k] + dE[k] * dE[k]) / (Jc * Jc);
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp center = image[k];
+					fp north = image[iN[i] + Nr * j];
+					fp south = image[iS[i] + Nr * j];
+					fp west = image[i + Nr * jW[j]];
+					fp east = image[i + Nr * jE[j]];
 
-				// normalized discrete laplacian (equ 54)
-				L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;// laplacian (based on derivatives)
+					dN[k] = north - center;
+					dS[k] = south - center;
+					dW[k] = west - center;
+					dE[k] = east - center;
 
-				// ICOV (equ 31/35)
-				num = (0.5 * G2) - ((1.0 / 16.0) * (L * L));// num (based on gradient and laplacian)
-				den = 1 + (.25 * L);				// den (based on laplacian)
-				qsqr = num / (den * den);		// qsqr (based on num and den)
+					fp gradient = (dN[k] * dN[k] + dS[k] * dS[k] + dW[k] * dW[k] + dE[k] * dE[k]) / (center * center);
+					fp laplacian = (dN[k] + dS[k] + dW[k] + dE[k]) / center;
+					fp numerator = (0.5f * gradient) - ((1.0f / 16.0f) * (laplacian * laplacian));
+					fp denominator = 1.0f + (0.25f * laplacian);
+					fp qsqr = numerator / (denominator * denominator);
+					denominator = (qsqr - q0sqr) / (q0sqr * (1.0f + q0sqr));
+					fp diff_coef = 1.0f / (1.0f + denominator);
 
-				// diffusion coefficent (equ 33) (every element of IMAGE)
-				den = (qsqr - q0sqr) / (q0sqr * (1 + q0sqr));// den (based on qsqr and q0sqr)
-				c[k] = 1.0 / (1.0 + den);// diffusion coefficient (based on den)
+					if (diff_coef < 0.0f)
+					{
+						diff_coef = 0.0f;
+					}
+					else if (diff_coef > 1.0f)
+					{
+						diff_coef = 1.0f;
+					}
 
-				// saturate diffusion coefficent to 0-1 range
-				if (c[k] < 0)		// if diffusion coefficient < 0
-				{
-					c[k] = 0;	// ... set to 0
+					c[k] = diff_coef;
 				}
-				else if (c[k] > 1)	// if diffusion coefficient > 1
-				{
-					c[k] = 1;	// ... set to 1
-				}			
-
 			}
-		}
-	//	}
-		
-		// divergence & image update
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: c[:Ne], iS[:Nr], jE[:Nc], dN[:Ne], dS[:Ne],  dW[:Ne], dE[:Ne] ) \
-		map(tofrom: image[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-
 
-			for (i = 0; i < Nr; i++) {		// do for the range of rows in IMAGE
-
-				// current index
-				k = i + Nr * j;				// get position of current element
-
-				// diffusion coefficent
-				cN = c[k];						// north diffusion coefficient
-				cS = c[iS[i] + Nr * j];			// south diffusion coefficient
-				cW = c[k];						// west diffusion coefficient
-				cE = c[i + Nr * jE[j]];			// east diffusion coefficient
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp cN_loc = c[k];
+					fp cS_loc = c[iS[i] + Nr * j];
+					fp cW_loc = c[k];
+					fp cE_loc = c[i + Nr * jE[j]];
 
-				// divergence (equ 58)
-				D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];// divergence
+					fp divergence = cN_loc * dN[k] + cS_loc * dS[k] + cW_loc * dW[k] + cE_loc * dE[k];
+					image[k] = image[k] + 0.25f * lambda * divergence;
 
-				// image update (equ 61) (every element of IMAGE)
-				image[k] = image[k] + 0.25 * lambda * D;// updates image (based on input time step and divergence)
+				}
 
 			}
 
 		}
-	 //	}
-
-	}
 	}
 	t_end = rtclock();
 	t_gpu = t_end - t_start;
@@ -539,5 +520,3 @@
 //====================================================================================================100
 
 }
-
-


thinking
**Verifying indentation consistency**
file update:
diff --git a/src/srad-omp/main.c b/src/srad-omp/main.c
index 460fb9a007db407f4f80ff00c0a7395bbc4ead01..6b081525a5c764d4d14ff961f53308fec6698860
--- a/src/srad-omp/main.c
+++ b/src/srad-omp/main.c
@@ -21,9 +21,11 @@
 //	DEFINE / INCLUDE
 //====================================================================================================100
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
+#include <omp.h>
 
 #include "define.c"
 #include "graphics.c"
@@ -341,105 +343,84 @@
 
 	//GPU
 	t_start = rtclock();
-//                map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne], image[:Ne]) - removed - left over grom removing pragma
 
+	#pragma omp target data device(GPU_DEVICE) \
+		map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], lambda, Nr, Nc, r1, r2, c1, c2) \
+		map(tofrom: image[:Ne], q0sqr) \
+		map(alloc: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
 	{
-	for (iter = 0; iter < niter; iter++) {// do for the number of iterations input parameter
+		for (iter = 0; iter < niter; iter++) { // do for the number of iterations input parameter
 
-
-		// ROI statistics for entire ROI (single number for ROI)
-		sum = 0;
-		sum2 = 0;
-		for (i = r1; i <= r2; i++) {		// do for the range of rows in ROI
-			for (j = c1; j <= c2; j++) {// do for the range of columns in ROI
-				tmp = image[i + Nr * j];	// get coresponding value in IMAGE
-				sum += tmp;			// take corresponding value and add to sum
-				sum2 += tmp * tmp;// take square of corresponding value and add to sum2
+			sum = 0;
+			sum2 = 0;
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256) reduction(+:sum,sum2)
+			for (j = c1; j <= c2; j++) {
+				for (i = r1; i <= r2; i++) {
+					fp tmp_loc = image[i + Nr * j];
+					sum += tmp_loc;
+					sum2 += tmp_loc * tmp_loc;
+				}
 			}
-		}
-		meanROI = sum / NeROI;	// gets mean (average) value of element in ROI
-		varROI = (sum2 / NeROI) - meanROI * meanROI;	// gets variance of ROI
-		q0sqr = varROI / (meanROI * meanROI);// gets standard deviation of ROI
 
-		// directional derivatives, ICOV, diffusion coefficent
-	
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], image[:Ne] ) \
-	//	map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-			for (i = 0; i < Nr; i++) {	// do for the range of rows in IMAGE 
-				// current index/pixel
-				k = i + Nr * j;				// get position of current element
-				Jc = image[k];				// get value of the current element
+			meanROI = sum / NeROI;
+			varROI = (sum2 / NeROI) - meanROI * meanROI;
+			q0sqr = varROI / (meanROI * meanROI);
 
-				// directional derivates (every element of IMAGE)
-				dN[k] = image[iN[i] + Nr * j] - Jc;	// north direction derivative
-				dS[k] = image[iS[i] + Nr * j] - Jc;	// south direction derivative
-				dW[k] = image[i + Nr * jW[j]] - Jc;	// west direction derivative
-				dE[k] = image[i + Nr * jE[j]] - Jc;	// east direction derivative
+#pragma omp target update to(q0sqr) device(GPU_DEVICE)
 
-				// normalized discrete gradient mag squared (equ 52,53)
-				G2 = (dN[k] * dN[k] + dS[k] * dS[k]	// gradient (based on derivatives)
-				+ dW[k] * dW[k] + dE[k] * dE[k]) / (Jc * Jc);
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp center = image[k];
+					fp north = image[iN[i] + Nr * j];
+					fp south = image[iS[i] + Nr * j];
+					fp west = image[i + Nr * jW[j]];
+					fp east = image[i + Nr * jE[j]];
 
-				// normalized discrete laplacian (equ 54)
-				L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;// laplacian (based on derivatives)
+					dN[k] = north - center;
+					dS[k] = south - center;
+					dW[k] = west - center;
+					dE[k] = east - center;
 
-				// ICOV (equ 31/35)
-				num = (0.5 * G2) - ((1.0 / 16.0) * (L * L));// num (based on gradient and laplacian)
-				den = 1 + (.25 * L);				// den (based on laplacian)
-				qsqr = num / (den * den);		// qsqr (based on num and den)
+					fp gradient = (dN[k] * dN[k] + dS[k] * dS[k] + dW[k] * dW[k] + dE[k] * dE[k]) / (center * center);
+					fp laplacian = (dN[k] + dS[k] + dW[k] + dE[k]) / center;
+					fp numerator = (0.5f * gradient) - ((1.0f / 16.0f) * (laplacian * laplacian));
+					fp denominator = 1.0f + (0.25f * laplacian);
+					fp qsqr = numerator / (denominator * denominator);
+					denominator = (qsqr - q0sqr) / (q0sqr * (1.0f + q0sqr));
+					fp diff_coef = 1.0f / (1.0f + denominator);
 
-				// diffusion coefficent (equ 33) (every element of IMAGE)
-				den = (qsqr - q0sqr) / (q0sqr * (1 + q0sqr));// den (based on qsqr and q0sqr)
-				c[k] = 1.0 / (1.0 + den);// diffusion coefficient (based on den)
+					if (diff_coef < 0.0f)
+					{
+						diff_coef = 0.0f;
+					}
+					else if (diff_coef > 1.0f)
+					{
+						diff_coef = 1.0f;
+					}
 
-				// saturate diffusion coefficent to 0-1 range
-				if (c[k] < 0)		// if diffusion coefficient < 0
-				{
-					c[k] = 0;	// ... set to 0
+					c[k] = diff_coef;
 				}
-				else if (c[k] > 1)	// if diffusion coefficient > 1
-				{
-					c[k] = 1;	// ... set to 1
-				}			
-
 			}
-		}
-	//	}
-		
-		// divergence & image update
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: c[:Ne], iS[:Nr], jE[:Nc], dN[:Ne], dS[:Ne],  dW[:Ne], dE[:Ne] ) \
-		map(tofrom: image[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-
 
-			for (i = 0; i < Nr; i++) {		// do for the range of rows in IMAGE
-
-				// current index
-				k = i + Nr * j;				// get position of current element
-
-				// diffusion coefficent
-				cN = c[k];						// north diffusion coefficient
-				cS = c[iS[i] + Nr * j];			// south diffusion coefficient
-				cW = c[k];						// west diffusion coefficient
-				cE = c[i + Nr * jE[j]];			// east diffusion coefficient
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp cN_loc = c[k];
+					fp cS_loc = c[iS[i] + Nr * j];
+					fp cW_loc = c[k];
+					fp cE_loc = c[i + Nr * jE[j]];
 
-				// divergence (equ 58)
-				D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];// divergence
+					fp divergence = cN_loc * dN[k] + cS_loc * dS[k] + cW_loc * dW[k] + cE_loc * dE[k];
+					image[k] = image[k] + 0.25f * lambda * divergence;
 
-				// image update (equ 61) (every element of IMAGE)
-				image[k] = image[k] + 0.25 * lambda * D;// updates image (based on input time step and divergence)
+				}
 
 			}
 
 		}
-	 //	}
-
-	}
 	}
 	t_end = rtclock();
 	t_gpu = t_end - t_start;
@@ -539,5 +520,3 @@
 //====================================================================================================100
 
 }
-
-

exec
/bin/bash -lc "sed -n '320,470p' data/src/srad-omp/main.c" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 8ms:
				// current index
				k = i + Nr * j;				// get position of current element

				// diffusion coefficent
				cN = c[k];						// north diffusion coefficient
				cS = c[iS[i] + Nr * j];			// south diffusion coefficient
				cW = c[k];						// west diffusion coefficient
				cE = c[i + Nr * jE[j]];			// east diffusion coefficient

				// divergence (equ 58)
				D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];// divergence

				// image update (equ 61) (every element of IMAGE)
				image_cpu[k] = image_cpu[k] + 0.25 * lambda * D;// updates image (based on input time step and divergence)

			}

		}

	}

thinking
**Verifying OpenMP pragma formatting and build setup**

I'm checking and adjusting the indentation of `#pragma` lines and their loops, ensuring consistent tab usage and proper mapping directives for device variables like `q0sqr` and `lambda`. I'll confirm all includes and variable initializations are correct, eliminate extra blank lines, and prepare to clean and rebuild using the `Makefile.nvc` in the `data/src/srad-omp` directory.
file update:
diff --git a/src/srad-omp/main.c b/src/srad-omp/main.c
index 460fb9a007db407f4f80ff00c0a7395bbc4ead01..6b081525a5c764d4d14ff961f53308fec6698860
--- a/src/srad-omp/main.c
+++ b/src/srad-omp/main.c
@@ -21,9 +21,11 @@
 //	DEFINE / INCLUDE
 //====================================================================================================100
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
+#include <omp.h>
 
 #include "define.c"
 #include "graphics.c"
@@ -341,105 +343,84 @@
 
 	//GPU
 	t_start = rtclock();
-//                map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne], image[:Ne]) - removed - left over grom removing pragma
 
+	#pragma omp target data device(GPU_DEVICE) \
+		map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], lambda, Nr, Nc, r1, r2, c1, c2) \
+		map(tofrom: image[:Ne], q0sqr) \
+		map(alloc: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
 	{
-	for (iter = 0; iter < niter; iter++) {// do for the number of iterations input parameter
+		for (iter = 0; iter < niter; iter++) { // do for the number of iterations input parameter
 
-
-		// ROI statistics for entire ROI (single number for ROI)
-		sum = 0;
-		sum2 = 0;
-		for (i = r1; i <= r2; i++) {		// do for the range of rows in ROI
-			for (j = c1; j <= c2; j++) {// do for the range of columns in ROI
-				tmp = image[i + Nr * j];	// get coresponding value in IMAGE
-				sum += tmp;			// take corresponding value and add to sum
-				sum2 += tmp * tmp;// take square of corresponding value and add to sum2
+			sum = 0;
+			sum2 = 0;
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256) reduction(+:sum,sum2)
+			for (j = c1; j <= c2; j++) {
+				for (i = r1; i <= r2; i++) {
+					fp tmp_loc = image[i + Nr * j];
+					sum += tmp_loc;
+					sum2 += tmp_loc * tmp_loc;
+				}
 			}
-		}
-		meanROI = sum / NeROI;	// gets mean (average) value of element in ROI
-		varROI = (sum2 / NeROI) - meanROI * meanROI;	// gets variance of ROI
-		q0sqr = varROI / (meanROI * meanROI);// gets standard deviation of ROI
 
-		// directional derivatives, ICOV, diffusion coefficent
-	
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], image[:Ne] ) \
-	//	map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-			for (i = 0; i < Nr; i++) {	// do for the range of rows in IMAGE 
-				// current index/pixel
-				k = i + Nr * j;				// get position of current element
-				Jc = image[k];				// get value of the current element
+			meanROI = sum / NeROI;
+			varROI = (sum2 / NeROI) - meanROI * meanROI;
+			q0sqr = varROI / (meanROI * meanROI);
 
-				// directional derivates (every element of IMAGE)
-				dN[k] = image[iN[i] + Nr * j] - Jc;	// north direction derivative
-				dS[k] = image[iS[i] + Nr * j] - Jc;	// south direction derivative
-				dW[k] = image[i + Nr * jW[j]] - Jc;	// west direction derivative
-				dE[k] = image[i + Nr * jE[j]] - Jc;	// east direction derivative
+#pragma omp target update to(q0sqr) device(GPU_DEVICE)
 
-				// normalized discrete gradient mag squared (equ 52,53)
-				G2 = (dN[k] * dN[k] + dS[k] * dS[k]	// gradient (based on derivatives)
-				+ dW[k] * dW[k] + dE[k] * dE[k]) / (Jc * Jc);
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp center = image[k];
+					fp north = image[iN[i] + Nr * j];
+					fp south = image[iS[i] + Nr * j];
+					fp west = image[i + Nr * jW[j]];
+					fp east = image[i + Nr * jE[j]];
 
-				// normalized discrete laplacian (equ 54)
-				L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;// laplacian (based on derivatives)
+					dN[k] = north - center;
+					dS[k] = south - center;
+					dW[k] = west - center;
+					dE[k] = east - center;
 
-				// ICOV (equ 31/35)
-				num = (0.5 * G2) - ((1.0 / 16.0) * (L * L));// num (based on gradient and laplacian)
-				den = 1 + (.25 * L);				// den (based on laplacian)
-				qsqr = num / (den * den);		// qsqr (based on num and den)
+					fp gradient = (dN[k] * dN[k] + dS[k] * dS[k] + dW[k] * dW[k] + dE[k] * dE[k]) / (center * center);
+					fp laplacian = (dN[k] + dS[k] + dW[k] + dE[k]) / center;
+					fp numerator = (0.5f * gradient) - ((1.0f / 16.0f) * (laplacian * laplacian));
+					fp denominator = 1.0f + (0.25f * laplacian);
+					fp qsqr = numerator / (denominator * denominator);
+					denominator = (qsqr - q0sqr) / (q0sqr * (1.0f + q0sqr));
+					fp diff_coef = 1.0f / (1.0f + denominator);
 
-				// diffusion coefficent (equ 33) (every element of IMAGE)
-				den = (qsqr - q0sqr) / (q0sqr * (1 + q0sqr));// den (based on qsqr and q0sqr)
-				c[k] = 1.0 / (1.0 + den);// diffusion coefficient (based on den)
+					if (diff_coef < 0.0f)
+					{
+						diff_coef = 0.0f;
+					}
+					else if (diff_coef > 1.0f)
+					{
+						diff_coef = 1.0f;
+					}
 
-				// saturate diffusion coefficent to 0-1 range
-				if (c[k] < 0)		// if diffusion coefficient < 0
-				{
-					c[k] = 0;	// ... set to 0
+					c[k] = diff_coef;
 				}
-				else if (c[k] > 1)	// if diffusion coefficient > 1
-				{
-					c[k] = 1;	// ... set to 1
-				}			
-
 			}
-		}
-	//	}
-		
-		// divergence & image update
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: c[:Ne], iS[:Nr], jE[:Nc], dN[:Ne], dS[:Ne],  dW[:Ne], dE[:Ne] ) \
-		map(tofrom: image[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-
 
-			for (i = 0; i < Nr; i++) {		// do for the range of rows in IMAGE
-
-				// current index
-				k = i + Nr * j;				// get position of current element
-
-				// diffusion coefficent
-				cN = c[k];						// north diffusion coefficient
-				cS = c[iS[i] + Nr * j];			// south diffusion coefficient
-				cW = c[k];						// west diffusion coefficient
-				cE = c[i + Nr * jE[j]];			// east diffusion coefficient
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp cN_loc = c[k];
+					fp cS_loc = c[iS[i] + Nr * j];
+					fp cW_loc = c[k];
+					fp cE_loc = c[i + Nr * jE[j]];
 
-				// divergence (equ 58)
-				D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];// divergence
+					fp divergence = cN_loc * dN[k] + cS_loc * dS[k] + cW_loc * dW[k] + cE_loc * dE[k];
+					image[k] = image[k] + 0.25f * lambda * divergence;
 
-				// image update (equ 61) (every element of IMAGE)
-				image[k] = image[k] + 0.25 * lambda * D;// updates image (based on input time step and divergence)
+				}
 
 			}
 
 		}
-	 //	}
-
-	}
 	}
 	t_end = rtclock();
 	t_gpu = t_end - t_start;
@@ -539,5 +520,3 @@
 //====================================================================================================100
 
 }
-
-

exec
/bin/bash -lc 'make -f Makefile.nvc CC=nvc++ CLASS=B clean' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/srad-omp succeeded in 10ms:
rm -rf main src/main.o

thinking
**Preparing to build with Makefile.nvc**
file update:
diff --git a/src/srad-omp/main.c b/src/srad-omp/main.c
index 460fb9a007db407f4f80ff00c0a7395bbc4ead01..6b081525a5c764d4d14ff961f53308fec6698860
--- a/src/srad-omp/main.c
+++ b/src/srad-omp/main.c
@@ -21,9 +21,11 @@
 //	DEFINE / INCLUDE
 //====================================================================================================100
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
+#include <omp.h>
 
 #include "define.c"
 #include "graphics.c"
@@ -341,105 +343,84 @@
 
 	//GPU
 	t_start = rtclock();
-//                map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne], image[:Ne]) - removed - left over grom removing pragma
 
+	#pragma omp target data device(GPU_DEVICE) \
+		map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], lambda, Nr, Nc, r1, r2, c1, c2) \
+		map(tofrom: image[:Ne], q0sqr) \
+		map(alloc: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
 	{
-	for (iter = 0; iter < niter; iter++) {// do for the number of iterations input parameter
+		for (iter = 0; iter < niter; iter++) { // do for the number of iterations input parameter
 
-
-		// ROI statistics for entire ROI (single number for ROI)
-		sum = 0;
-		sum2 = 0;
-		for (i = r1; i <= r2; i++) {		// do for the range of rows in ROI
-			for (j = c1; j <= c2; j++) {// do for the range of columns in ROI
-				tmp = image[i + Nr * j];	// get coresponding value in IMAGE
-				sum += tmp;			// take corresponding value and add to sum
-				sum2 += tmp * tmp;// take square of corresponding value and add to sum2
+			sum = 0;
+			sum2 = 0;
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256) reduction(+:sum,sum2)
+			for (j = c1; j <= c2; j++) {
+				for (i = r1; i <= r2; i++) {
+					fp tmp_loc = image[i + Nr * j];
+					sum += tmp_loc;
+					sum2 += tmp_loc * tmp_loc;
+				}
 			}
-		}
-		meanROI = sum / NeROI;	// gets mean (average) value of element in ROI
-		varROI = (sum2 / NeROI) - meanROI * meanROI;	// gets variance of ROI
-		q0sqr = varROI / (meanROI * meanROI);// gets standard deviation of ROI
 
-		// directional derivatives, ICOV, diffusion coefficent
-	
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], image[:Ne] ) \
-	//	map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-			for (i = 0; i < Nr; i++) {	// do for the range of rows in IMAGE 
-				// current index/pixel
-				k = i + Nr * j;				// get position of current element
-				Jc = image[k];				// get value of the current element
+			meanROI = sum / NeROI;
+			varROI = (sum2 / NeROI) - meanROI * meanROI;
+			q0sqr = varROI / (meanROI * meanROI);
 
-				// directional derivates (every element of IMAGE)
-				dN[k] = image[iN[i] + Nr * j] - Jc;	// north direction derivative
-				dS[k] = image[iS[i] + Nr * j] - Jc;	// south direction derivative
-				dW[k] = image[i + Nr * jW[j]] - Jc;	// west direction derivative
-				dE[k] = image[i + Nr * jE[j]] - Jc;	// east direction derivative
+#pragma omp target update to(q0sqr) device(GPU_DEVICE)
 
-				// normalized discrete gradient mag squared (equ 52,53)
-				G2 = (dN[k] * dN[k] + dS[k] * dS[k]	// gradient (based on derivatives)
-				+ dW[k] * dW[k] + dE[k] * dE[k]) / (Jc * Jc);
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp center = image[k];
+					fp north = image[iN[i] + Nr * j];
+					fp south = image[iS[i] + Nr * j];
+					fp west = image[i + Nr * jW[j]];
+					fp east = image[i + Nr * jE[j]];
 
-				// normalized discrete laplacian (equ 54)
-				L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;// laplacian (based on derivatives)
+					dN[k] = north - center;
+					dS[k] = south - center;
+					dW[k] = west - center;
+					dE[k] = east - center;
 
-				// ICOV (equ 31/35)
-				num = (0.5 * G2) - ((1.0 / 16.0) * (L * L));// num (based on gradient and laplacian)
-				den = 1 + (.25 * L);				// den (based on laplacian)
-				qsqr = num / (den * den);		// qsqr (based on num and den)
+					fp gradient = (dN[k] * dN[k] + dS[k] * dS[k] + dW[k] * dW[k] + dE[k] * dE[k]) / (center * center);
+					fp laplacian = (dN[k] + dS[k] + dW[k] + dE[k]) / center;
+					fp numerator = (0.5f * gradient) - ((1.0f / 16.0f) * (laplacian * laplacian));
+					fp denominator = 1.0f + (0.25f * laplacian);
+					fp qsqr = numerator / (denominator * denominator);
+					denominator = (qsqr - q0sqr) / (q0sqr * (1.0f + q0sqr));
+					fp diff_coef = 1.0f / (1.0f + denominator);
 
-				// diffusion coefficent (equ 33) (every element of IMAGE)
-				den = (qsqr - q0sqr) / (q0sqr * (1 + q0sqr));// den (based on qsqr and q0sqr)
-				c[k] = 1.0 / (1.0 + den);// diffusion coefficient (based on den)
+					if (diff_coef < 0.0f)
+					{
+						diff_coef = 0.0f;
+					}
+					else if (diff_coef > 1.0f)
+					{
+						diff_coef = 1.0f;
+					}
 
-				// saturate diffusion coefficent to 0-1 range
-				if (c[k] < 0)		// if diffusion coefficient < 0
-				{
-					c[k] = 0;	// ... set to 0
+					c[k] = diff_coef;
 				}
-				else if (c[k] > 1)	// if diffusion coefficient > 1
-				{
-					c[k] = 1;	// ... set to 1
-				}			
-
 			}
-		}
-	//	}
-		
-		// divergence & image update
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: c[:Ne], iS[:Nr], jE[:Nc], dN[:Ne], dS[:Ne],  dW[:Ne], dE[:Ne] ) \
-		map(tofrom: image[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-
 
-			for (i = 0; i < Nr; i++) {		// do for the range of rows in IMAGE
-
-				// current index
-				k = i + Nr * j;				// get position of current element
-
-				// diffusion coefficent
-				cN = c[k];						// north diffusion coefficient
-				cS = c[iS[i] + Nr * j];			// south diffusion coefficient
-				cW = c[k];						// west diffusion coefficient
-				cE = c[i + Nr * jE[j]];			// east diffusion coefficient
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp cN_loc = c[k];
+					fp cS_loc = c[iS[i] + Nr * j];
+					fp cW_loc = c[k];
+					fp cE_loc = c[i + Nr * jE[j]];
 
-				// divergence (equ 58)
-				D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];// divergence
+					fp divergence = cN_loc * dN[k] + cS_loc * dS[k] + cW_loc * dW[k] + cE_loc * dE[k];
+					image[k] = image[k] + 0.25f * lambda * divergence;
 
-				// image update (equ 61) (every element of IMAGE)
-				image[k] = image[k] + 0.25 * lambda * D;// updates image (based on input time step and divergence)
+				}
 
 			}
 
 		}
-	 //	}
-
-	}
 	}
 	t_end = rtclock();
 	t_gpu = t_end - t_start;
@@ -539,5 +520,3 @@
 //====================================================================================================100
 
 }
-
-

exec
/bin/bash -lc 'make -f Makefile.nvc CC=nvc++ CLASS=B' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/srad-omp succeeded in 490ms:
nvc++  -std=c99 -Wall -I/home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/gate_sdk -O3 -Minfo -mp=gpu -gpu=cc89 -c src/main.c -o src/main.o
"src/main.c", line 55: warning: variable "th1" was set but never used [set_but_not_used]
  	int th1;
  	    ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

write_graphics:
      7, include "graphics.c"
          61, Loop not vectorized/parallelized: contains call
          70, Loop not vectorized/parallelized: contains call
read_graphics:
      7, include "graphics.c"
         121, Loop not vectorized/parallelized: contains call
         134, Loop nest collapsed
              Loop not vectorized/parallelized: contains call
         142, Loop not vectorized/parallelized: contains call
resize:
      8, include "resize.c"
          34, Loop not fused: no successor loop

thinking
**Preparing final response details**
file update:
diff --git a/src/srad-omp/main.c b/src/srad-omp/main.c
index 460fb9a007db407f4f80ff00c0a7395bbc4ead01..6b081525a5c764d4d14ff961f53308fec6698860
--- a/src/srad-omp/main.c
+++ b/src/srad-omp/main.c
@@ -21,9 +21,11 @@
 //	DEFINE / INCLUDE
 //====================================================================================================100
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
+#include <omp.h>
 
 #include "define.c"
 #include "graphics.c"
@@ -341,105 +343,84 @@
 
 	//GPU
 	t_start = rtclock();
-//                map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne], image[:Ne]) - removed - left over grom removing pragma
 
+	#pragma omp target data device(GPU_DEVICE) \
+		map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], lambda, Nr, Nc, r1, r2, c1, c2) \
+		map(tofrom: image[:Ne], q0sqr) \
+		map(alloc: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
 	{
-	for (iter = 0; iter < niter; iter++) {// do for the number of iterations input parameter
+		for (iter = 0; iter < niter; iter++) { // do for the number of iterations input parameter
 
-
-		// ROI statistics for entire ROI (single number for ROI)
-		sum = 0;
-		sum2 = 0;
-		for (i = r1; i <= r2; i++) {		// do for the range of rows in ROI
-			for (j = c1; j <= c2; j++) {// do for the range of columns in ROI
-				tmp = image[i + Nr * j];	// get coresponding value in IMAGE
-				sum += tmp;			// take corresponding value and add to sum
-				sum2 += tmp * tmp;// take square of corresponding value and add to sum2
+			sum = 0;
+			sum2 = 0;
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256) reduction(+:sum,sum2)
+			for (j = c1; j <= c2; j++) {
+				for (i = r1; i <= r2; i++) {
+					fp tmp_loc = image[i + Nr * j];
+					sum += tmp_loc;
+					sum2 += tmp_loc * tmp_loc;
+				}
 			}
-		}
-		meanROI = sum / NeROI;	// gets mean (average) value of element in ROI
-		varROI = (sum2 / NeROI) - meanROI * meanROI;	// gets variance of ROI
-		q0sqr = varROI / (meanROI * meanROI);// gets standard deviation of ROI
 
-		// directional derivatives, ICOV, diffusion coefficent
-	
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], image[:Ne] ) \
-	//	map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-			for (i = 0; i < Nr; i++) {	// do for the range of rows in IMAGE 
-				// current index/pixel
-				k = i + Nr * j;				// get position of current element
-				Jc = image[k];				// get value of the current element
+			meanROI = sum / NeROI;
+			varROI = (sum2 / NeROI) - meanROI * meanROI;
+			q0sqr = varROI / (meanROI * meanROI);
 
-				// directional derivates (every element of IMAGE)
-				dN[k] = image[iN[i] + Nr * j] - Jc;	// north direction derivative
-				dS[k] = image[iS[i] + Nr * j] - Jc;	// south direction derivative
-				dW[k] = image[i + Nr * jW[j]] - Jc;	// west direction derivative
-				dE[k] = image[i + Nr * jE[j]] - Jc;	// east direction derivative
+#pragma omp target update to(q0sqr) device(GPU_DEVICE)
 
-				// normalized discrete gradient mag squared (equ 52,53)
-				G2 = (dN[k] * dN[k] + dS[k] * dS[k]	// gradient (based on derivatives)
-				+ dW[k] * dW[k] + dE[k] * dE[k]) / (Jc * Jc);
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp center = image[k];
+					fp north = image[iN[i] + Nr * j];
+					fp south = image[iS[i] + Nr * j];
+					fp west = image[i + Nr * jW[j]];
+					fp east = image[i + Nr * jE[j]];
 
-				// normalized discrete laplacian (equ 54)
-				L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;// laplacian (based on derivatives)
+					dN[k] = north - center;
+					dS[k] = south - center;
+					dW[k] = west - center;
+					dE[k] = east - center;
 
-				// ICOV (equ 31/35)
-				num = (0.5 * G2) - ((1.0 / 16.0) * (L * L));// num (based on gradient and laplacian)
-				den = 1 + (.25 * L);				// den (based on laplacian)
-				qsqr = num / (den * den);		// qsqr (based on num and den)
+					fp gradient = (dN[k] * dN[k] + dS[k] * dS[k] + dW[k] * dW[k] + dE[k] * dE[k]) / (center * center);
+					fp laplacian = (dN[k] + dS[k] + dW[k] + dE[k]) / center;
+					fp numerator = (0.5f * gradient) - ((1.0f / 16.0f) * (laplacian * laplacian));
+					fp denominator = 1.0f + (0.25f * laplacian);
+					fp qsqr = numerator / (denominator * denominator);
+					denominator = (qsqr - q0sqr) / (q0sqr * (1.0f + q0sqr));
+					fp diff_coef = 1.0f / (1.0f + denominator);
 
-				// diffusion coefficent (equ 33) (every element of IMAGE)
-				den = (qsqr - q0sqr) / (q0sqr * (1 + q0sqr));// den (based on qsqr and q0sqr)
-				c[k] = 1.0 / (1.0 + den);// diffusion coefficient (based on den)
+					if (diff_coef < 0.0f)
+					{
+						diff_coef = 0.0f;
+					}
+					else if (diff_coef > 1.0f)
+					{
+						diff_coef = 1.0f;
+					}
 
-				// saturate diffusion coefficent to 0-1 range
-				if (c[k] < 0)		// if diffusion coefficient < 0
-				{
-					c[k] = 0;	// ... set to 0
+					c[k] = diff_coef;
 				}
-				else if (c[k] > 1)	// if diffusion coefficient > 1
-				{
-					c[k] = 1;	// ... set to 1
-				}			
-
 			}
-		}
-	//	}
-		
-		// divergence & image update
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: c[:Ne], iS[:Nr], jE[:Nc], dN[:Ne], dS[:Ne],  dW[:Ne], dE[:Ne] ) \
-		map(tofrom: image[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-
 
-			for (i = 0; i < Nr; i++) {		// do for the range of rows in IMAGE
-
-				// current index
-				k = i + Nr * j;				// get position of current element
-
-				// diffusion coefficent
-				cN = c[k];						// north diffusion coefficient
-				cS = c[iS[i] + Nr * j];			// south diffusion coefficient
-				cW = c[k];						// west diffusion coefficient
-				cE = c[i + Nr * jE[j]];			// east diffusion coefficient
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp cN_loc = c[k];
+					fp cS_loc = c[iS[i] + Nr * j];
+					fp cW_loc = c[k];
+					fp cE_loc = c[i + Nr * jE[j]];
 
-				// divergence (equ 58)
-				D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];// divergence
+					fp divergence = cN_loc * dN[k] + cS_loc * dS[k] + cW_loc * dW[k] + cE_loc * dE[k];
+					image[k] = image[k] + 0.25f * lambda * divergence;
 
-				// image update (equ 61) (every element of IMAGE)
-				image[k] = image[k] + 0.25 * lambda * D;// updates image (based on input time step and divergence)
+				}
 
 			}
 
 		}
-	 //	}
-
-	}
 	}
 	t_end = rtclock();
 	t_gpu = t_end - t_start;
@@ -539,5 +520,3 @@
 //====================================================================================================100
 
 }
-
-

exec
/bin/bash -lc "nl -ba data/src/srad-omp/main.c | sed -n '1,80p'" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 9ms:
     1	//====================================================================================================100
     2	//		UPDATE
     3	//====================================================================================================100
     4	
     5	//    2006.03   Rob Janiczek
     6	//        --creation of prototype version
     7	//    2006.03   Drew Gilliam
     8	//        --rewriting of prototype version into current version
     9	//        --got rid of multiple function calls, all code in a  
    10	//         single function (for speed)
    11	//        --code cleanup & commenting
    12	//        --code optimization efforts   
    13	//    2006.04   Drew Gilliam
    14	//        --added diffusion coefficent saturation on [0,1]
    15	//		2009.12 Lukasz G. Szafaryn
    16	//		-- reading from image, command line inputs
    17	//		2010.01 Lukasz G. Szafaryn
    18	//		--comments
    19	
    20	//====================================================================================================100

thinking
**Checking line numbers for GPU block**
file update:
diff --git a/src/srad-omp/main.c b/src/srad-omp/main.c
index 460fb9a007db407f4f80ff00c0a7395bbc4ead01..6b081525a5c764d4d14ff961f53308fec6698860
--- a/src/srad-omp/main.c
+++ b/src/srad-omp/main.c
@@ -21,9 +21,11 @@
 //	DEFINE / INCLUDE
 //====================================================================================================100
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
+#include <omp.h>
 
 #include "define.c"
 #include "graphics.c"
@@ -341,105 +343,84 @@
 
 	//GPU
 	t_start = rtclock();
-//                map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne], image[:Ne]) - removed - left over grom removing pragma
 
+	#pragma omp target data device(GPU_DEVICE) \
+		map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], lambda, Nr, Nc, r1, r2, c1, c2) \
+		map(tofrom: image[:Ne], q0sqr) \
+		map(alloc: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
 	{
-	for (iter = 0; iter < niter; iter++) {// do for the number of iterations input parameter
+		for (iter = 0; iter < niter; iter++) { // do for the number of iterations input parameter
 
-
-		// ROI statistics for entire ROI (single number for ROI)
-		sum = 0;
-		sum2 = 0;
-		for (i = r1; i <= r2; i++) {		// do for the range of rows in ROI
-			for (j = c1; j <= c2; j++) {// do for the range of columns in ROI
-				tmp = image[i + Nr * j];	// get coresponding value in IMAGE
-				sum += tmp;			// take corresponding value and add to sum
-				sum2 += tmp * tmp;// take square of corresponding value and add to sum2
+			sum = 0;
+			sum2 = 0;
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256) reduction(+:sum,sum2)
+			for (j = c1; j <= c2; j++) {
+				for (i = r1; i <= r2; i++) {
+					fp tmp_loc = image[i + Nr * j];
+					sum += tmp_loc;
+					sum2 += tmp_loc * tmp_loc;
+				}
 			}
-		}
-		meanROI = sum / NeROI;	// gets mean (average) value of element in ROI
-		varROI = (sum2 / NeROI) - meanROI * meanROI;	// gets variance of ROI
-		q0sqr = varROI / (meanROI * meanROI);// gets standard deviation of ROI
 
-		// directional derivatives, ICOV, diffusion coefficent
-	
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], image[:Ne] ) \
-	//	map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-			for (i = 0; i < Nr; i++) {	// do for the range of rows in IMAGE 
-				// current index/pixel
-				k = i + Nr * j;				// get position of current element
-				Jc = image[k];				// get value of the current element
+			meanROI = sum / NeROI;
+			varROI = (sum2 / NeROI) - meanROI * meanROI;
+			q0sqr = varROI / (meanROI * meanROI);
 
-				// directional derivates (every element of IMAGE)
-				dN[k] = image[iN[i] + Nr * j] - Jc;	// north direction derivative
-				dS[k] = image[iS[i] + Nr * j] - Jc;	// south direction derivative
-				dW[k] = image[i + Nr * jW[j]] - Jc;	// west direction derivative
-				dE[k] = image[i + Nr * jE[j]] - Jc;	// east direction derivative
+#pragma omp target update to(q0sqr) device(GPU_DEVICE)
 
-				// normalized discrete gradient mag squared (equ 52,53)
-				G2 = (dN[k] * dN[k] + dS[k] * dS[k]	// gradient (based on derivatives)
-				+ dW[k] * dW[k] + dE[k] * dE[k]) / (Jc * Jc);
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp center = image[k];
+					fp north = image[iN[i] + Nr * j];
+					fp south = image[iS[i] + Nr * j];
+					fp west = image[i + Nr * jW[j]];
+					fp east = image[i + Nr * jE[j]];
 
-				// normalized discrete laplacian (equ 54)
-				L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;// laplacian (based on derivatives)
+					dN[k] = north - center;
+					dS[k] = south - center;
+					dW[k] = west - center;
+					dE[k] = east - center;
 
-				// ICOV (equ 31/35)
-				num = (0.5 * G2) - ((1.0 / 16.0) * (L * L));// num (based on gradient and laplacian)
-				den = 1 + (.25 * L);				// den (based on laplacian)
-				qsqr = num / (den * den);		// qsqr (based on num and den)
+					fp gradient = (dN[k] * dN[k] + dS[k] * dS[k] + dW[k] * dW[k] + dE[k] * dE[k]) / (center * center);
+					fp laplacian = (dN[k] + dS[k] + dW[k] + dE[k]) / center;
+					fp numerator = (0.5f * gradient) - ((1.0f / 16.0f) * (laplacian * laplacian));
+					fp denominator = 1.0f + (0.25f * laplacian);
+					fp qsqr = numerator / (denominator * denominator);
+					denominator = (qsqr - q0sqr) / (q0sqr * (1.0f + q0sqr));
+					fp diff_coef = 1.0f / (1.0f + denominator);
 
-				// diffusion coefficent (equ 33) (every element of IMAGE)
-				den = (qsqr - q0sqr) / (q0sqr * (1 + q0sqr));// den (based on qsqr and q0sqr)
-				c[k] = 1.0 / (1.0 + den);// diffusion coefficient (based on den)
+					if (diff_coef < 0.0f)
+					{
+						diff_coef = 0.0f;
+					}
+					else if (diff_coef > 1.0f)
+					{
+						diff_coef = 1.0f;
+					}
 
-				// saturate diffusion coefficent to 0-1 range
-				if (c[k] < 0)		// if diffusion coefficient < 0
-				{
-					c[k] = 0;	// ... set to 0
+					c[k] = diff_coef;
 				}
-				else if (c[k] > 1)	// if diffusion coefficient > 1
-				{
-					c[k] = 1;	// ... set to 1
-				}			
-
 			}
-		}
-	//	}
-		
-		// divergence & image update
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: c[:Ne], iS[:Nr], jE[:Nc], dN[:Ne], dS[:Ne],  dW[:Ne], dE[:Ne] ) \
-		map(tofrom: image[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-
 
-			for (i = 0; i < Nr; i++) {		// do for the range of rows in IMAGE
-
-				// current index
-				k = i + Nr * j;				// get position of current element
-
-				// diffusion coefficent
-				cN = c[k];						// north diffusion coefficient
-				cS = c[iS[i] + Nr * j];			// south diffusion coefficient
-				cW = c[k];						// west diffusion coefficient
-				cE = c[i + Nr * jE[j]];			// east diffusion coefficient
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp cN_loc = c[k];
+					fp cS_loc = c[iS[i] + Nr * j];
+					fp cW_loc = c[k];
+					fp cE_loc = c[i + Nr * jE[j]];
 
-				// divergence (equ 58)
-				D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];// divergence
+					fp divergence = cN_loc * dN[k] + cS_loc * dS[k] + cW_loc * dW[k] + cE_loc * dE[k];
+					image[k] = image[k] + 0.25f * lambda * divergence;
 
-				// image update (equ 61) (every element of IMAGE)
-				image[k] = image[k] + 0.25 * lambda * D;// updates image (based on input time step and divergence)
+				}
 
 			}
 
 		}
-	 //	}
-
-	}
 	}
 	t_end = rtclock();
 	t_gpu = t_end - t_start;
@@ -539,5 +520,3 @@
 //====================================================================================================100
 
 }
-
-

exec
/bin/bash -lc "nl -ba data/src/srad-omp/main.c | sed -n '320,520p'" in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir succeeded in 9ms:
   320					// current index
   321					k = i + Nr * j;				// get position of current element
   322	
   323					// diffusion coefficent
   324					cN = c[k];						// north diffusion coefficient
   325					cS = c[iS[i] + Nr * j];			// south diffusion coefficient
   326					cW = c[k];						// west diffusion coefficient
   327					cE = c[i + Nr * jE[j]];			// east diffusion coefficient
   328	
   329					// divergence (equ 58)
   330					D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];// divergence
   331	
   332					// image update (equ 61) (every element of IMAGE)
   333					image_cpu[k] = image_cpu[k] + 0.25 * lambda * D;// updates image (based on input time step and divergence)
   334	
   335				}
   336	
   337			}
   338	
   339		}

thinking
**Summarizing compilation and test details**
file update:
diff --git a/src/srad-omp/main.c b/src/srad-omp/main.c
index 460fb9a007db407f4f80ff00c0a7395bbc4ead01..6b081525a5c764d4d14ff961f53308fec6698860
--- a/src/srad-omp/main.c
+++ b/src/srad-omp/main.c
@@ -21,9 +21,11 @@
 //	DEFINE / INCLUDE
 //====================================================================================================100
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
+#include <omp.h>
 
 #include "define.c"
 #include "graphics.c"
@@ -341,105 +343,84 @@
 
 	//GPU
 	t_start = rtclock();
-//                map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne], image[:Ne]) - removed - left over grom removing pragma
 
+	#pragma omp target data device(GPU_DEVICE) \
+		map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], lambda, Nr, Nc, r1, r2, c1, c2) \
+		map(tofrom: image[:Ne], q0sqr) \
+		map(alloc: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
 	{
-	for (iter = 0; iter < niter; iter++) {// do for the number of iterations input parameter
+		for (iter = 0; iter < niter; iter++) { // do for the number of iterations input parameter
 
-
-		// ROI statistics for entire ROI (single number for ROI)
-		sum = 0;
-		sum2 = 0;
-		for (i = r1; i <= r2; i++) {		// do for the range of rows in ROI
-			for (j = c1; j <= c2; j++) {// do for the range of columns in ROI
-				tmp = image[i + Nr * j];	// get coresponding value in IMAGE
-				sum += tmp;			// take corresponding value and add to sum
-				sum2 += tmp * tmp;// take square of corresponding value and add to sum2
+			sum = 0;
+			sum2 = 0;
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256) reduction(+:sum,sum2)
+			for (j = c1; j <= c2; j++) {
+				for (i = r1; i <= r2; i++) {
+					fp tmp_loc = image[i + Nr * j];
+					sum += tmp_loc;
+					sum2 += tmp_loc * tmp_loc;
+				}
 			}
-		}
-		meanROI = sum / NeROI;	// gets mean (average) value of element in ROI
-		varROI = (sum2 / NeROI) - meanROI * meanROI;	// gets variance of ROI
-		q0sqr = varROI / (meanROI * meanROI);// gets standard deviation of ROI
 
-		// directional derivatives, ICOV, diffusion coefficent
-	
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], image[:Ne] ) \
-	//	map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-			for (i = 0; i < Nr; i++) {	// do for the range of rows in IMAGE 
-				// current index/pixel
-				k = i + Nr * j;				// get position of current element
-				Jc = image[k];				// get value of the current element
+			meanROI = sum / NeROI;
+			varROI = (sum2 / NeROI) - meanROI * meanROI;
+			q0sqr = varROI / (meanROI * meanROI);
 
-				// directional derivates (every element of IMAGE)
-				dN[k] = image[iN[i] + Nr * j] - Jc;	// north direction derivative
-				dS[k] = image[iS[i] + Nr * j] - Jc;	// south direction derivative
-				dW[k] = image[i + Nr * jW[j]] - Jc;	// west direction derivative
-				dE[k] = image[i + Nr * jE[j]] - Jc;	// east direction derivative
+#pragma omp target update to(q0sqr) device(GPU_DEVICE)
 
-				// normalized discrete gradient mag squared (equ 52,53)
-				G2 = (dN[k] * dN[k] + dS[k] * dS[k]	// gradient (based on derivatives)
-				+ dW[k] * dW[k] + dE[k] * dE[k]) / (Jc * Jc);
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp center = image[k];
+					fp north = image[iN[i] + Nr * j];
+					fp south = image[iS[i] + Nr * j];
+					fp west = image[i + Nr * jW[j]];
+					fp east = image[i + Nr * jE[j]];
 
-				// normalized discrete laplacian (equ 54)
-				L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;// laplacian (based on derivatives)
+					dN[k] = north - center;
+					dS[k] = south - center;
+					dW[k] = west - center;
+					dE[k] = east - center;
 
-				// ICOV (equ 31/35)
-				num = (0.5 * G2) - ((1.0 / 16.0) * (L * L));// num (based on gradient and laplacian)
-				den = 1 + (.25 * L);				// den (based on laplacian)
-				qsqr = num / (den * den);		// qsqr (based on num and den)
+					fp gradient = (dN[k] * dN[k] + dS[k] * dS[k] + dW[k] * dW[k] + dE[k] * dE[k]) / (center * center);
+					fp laplacian = (dN[k] + dS[k] + dW[k] + dE[k]) / center;
+					fp numerator = (0.5f * gradient) - ((1.0f / 16.0f) * (laplacian * laplacian));
+					fp denominator = 1.0f + (0.25f * laplacian);
+					fp qsqr = numerator / (denominator * denominator);
+					denominator = (qsqr - q0sqr) / (q0sqr * (1.0f + q0sqr));
+					fp diff_coef = 1.0f / (1.0f + denominator);
 
-				// diffusion coefficent (equ 33) (every element of IMAGE)
-				den = (qsqr - q0sqr) / (q0sqr * (1 + q0sqr));// den (based on qsqr and q0sqr)
-				c[k] = 1.0 / (1.0 + den);// diffusion coefficient (based on den)
+					if (diff_coef < 0.0f)
+					{
+						diff_coef = 0.0f;
+					}
+					else if (diff_coef > 1.0f)
+					{
+						diff_coef = 1.0f;
+					}
 
-				// saturate diffusion coefficent to 0-1 range
-				if (c[k] < 0)		// if diffusion coefficient < 0
-				{
-					c[k] = 0;	// ... set to 0
+					c[k] = diff_coef;
 				}
-				else if (c[k] > 1)	// if diffusion coefficient > 1
-				{
-					c[k] = 1;	// ... set to 1
-				}			
-
 			}
-		}
-	//	}
-		
-		// divergence & image update
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: c[:Ne], iS[:Nr], jE[:Nc], dN[:Ne], dS[:Ne],  dW[:Ne], dE[:Ne] ) \
-		map(tofrom: image[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-
 
-			for (i = 0; i < Nr; i++) {		// do for the range of rows in IMAGE
-
-				// current index
-				k = i + Nr * j;				// get position of current element
-
-				// diffusion coefficent
-				cN = c[k];						// north diffusion coefficient
-				cS = c[iS[i] + Nr * j];			// south diffusion coefficient
-				cW = c[k];						// west diffusion coefficient
-				cE = c[i + Nr * jE[j]];			// east diffusion coefficient
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp cN_loc = c[k];
+					fp cS_loc = c[iS[i] + Nr * j];
+					fp cW_loc = c[k];
+					fp cE_loc = c[i + Nr * jE[j]];
 
-				// divergence (equ 58)
-				D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];// divergence
+					fp divergence = cN_loc * dN[k] + cS_loc * dS[k] + cW_loc * dW[k] + cE_loc * dE[k];
+					image[k] = image[k] + 0.25f * lambda * divergence;
 
-				// image update (equ 61) (every element of IMAGE)
-				image[k] = image[k] + 0.25 * lambda * D;// updates image (based on input time step and divergence)
+				}
 
 			}
 
 		}
-	 //	}
-
-	}
 	}
 	t_end = rtclock();
 	t_gpu = t_end - t_start;
@@ -539,5 +520,3 @@
 //====================================================================================================100
 
 }
-
-

exec
/bin/bash -lc 'ls input' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/srad-omp succeeded in 8ms:
image.pgm

thinking
**Preparing to run main executable**
file update:
diff --git a/src/srad-omp/main.c b/src/srad-omp/main.c
index 460fb9a007db407f4f80ff00c0a7395bbc4ead01..6b081525a5c764d4d14ff961f53308fec6698860
--- a/src/srad-omp/main.c
+++ b/src/srad-omp/main.c
@@ -21,9 +21,11 @@
 //	DEFINE / INCLUDE
 //====================================================================================================100
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
+#include <omp.h>
 
 #include "define.c"
 #include "graphics.c"
@@ -341,105 +343,84 @@
 
 	//GPU
 	t_start = rtclock();
-//                map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne], image[:Ne]) - removed - left over grom removing pragma
 
+	#pragma omp target data device(GPU_DEVICE) \
+		map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], lambda, Nr, Nc, r1, r2, c1, c2) \
+		map(tofrom: image[:Ne], q0sqr) \
+		map(alloc: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
 	{
-	for (iter = 0; iter < niter; iter++) {// do for the number of iterations input parameter
+		for (iter = 0; iter < niter; iter++) { // do for the number of iterations input parameter
 
-
-		// ROI statistics for entire ROI (single number for ROI)
-		sum = 0;
-		sum2 = 0;
-		for (i = r1; i <= r2; i++) {		// do for the range of rows in ROI
-			for (j = c1; j <= c2; j++) {// do for the range of columns in ROI
-				tmp = image[i + Nr * j];	// get coresponding value in IMAGE
-				sum += tmp;			// take corresponding value and add to sum
-				sum2 += tmp * tmp;// take square of corresponding value and add to sum2
+			sum = 0;
+			sum2 = 0;
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256) reduction(+:sum,sum2)
+			for (j = c1; j <= c2; j++) {
+				for (i = r1; i <= r2; i++) {
+					fp tmp_loc = image[i + Nr * j];
+					sum += tmp_loc;
+					sum2 += tmp_loc * tmp_loc;
+				}
 			}
-		}
-		meanROI = sum / NeROI;	// gets mean (average) value of element in ROI
-		varROI = (sum2 / NeROI) - meanROI * meanROI;	// gets variance of ROI
-		q0sqr = varROI / (meanROI * meanROI);// gets standard deviation of ROI
 
-		// directional derivatives, ICOV, diffusion coefficent
-	
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], image[:Ne] ) \
-	//	map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-			for (i = 0; i < Nr; i++) {	// do for the range of rows in IMAGE 
-				// current index/pixel
-				k = i + Nr * j;				// get position of current element
-				Jc = image[k];				// get value of the current element
+			meanROI = sum / NeROI;
+			varROI = (sum2 / NeROI) - meanROI * meanROI;
+			q0sqr = varROI / (meanROI * meanROI);
 
-				// directional derivates (every element of IMAGE)
-				dN[k] = image[iN[i] + Nr * j] - Jc;	// north direction derivative
-				dS[k] = image[iS[i] + Nr * j] - Jc;	// south direction derivative
-				dW[k] = image[i + Nr * jW[j]] - Jc;	// west direction derivative
-				dE[k] = image[i + Nr * jE[j]] - Jc;	// east direction derivative
+#pragma omp target update to(q0sqr) device(GPU_DEVICE)
 
-				// normalized discrete gradient mag squared (equ 52,53)
-				G2 = (dN[k] * dN[k] + dS[k] * dS[k]	// gradient (based on derivatives)
-				+ dW[k] * dW[k] + dE[k] * dE[k]) / (Jc * Jc);
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp center = image[k];
+					fp north = image[iN[i] + Nr * j];
+					fp south = image[iS[i] + Nr * j];
+					fp west = image[i + Nr * jW[j]];
+					fp east = image[i + Nr * jE[j]];
 
-				// normalized discrete laplacian (equ 54)
-				L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;// laplacian (based on derivatives)
+					dN[k] = north - center;
+					dS[k] = south - center;
+					dW[k] = west - center;
+					dE[k] = east - center;
 
-				// ICOV (equ 31/35)
-				num = (0.5 * G2) - ((1.0 / 16.0) * (L * L));// num (based on gradient and laplacian)
-				den = 1 + (.25 * L);				// den (based on laplacian)
-				qsqr = num / (den * den);		// qsqr (based on num and den)
+					fp gradient = (dN[k] * dN[k] + dS[k] * dS[k] + dW[k] * dW[k] + dE[k] * dE[k]) / (center * center);
+					fp laplacian = (dN[k] + dS[k] + dW[k] + dE[k]) / center;
+					fp numerator = (0.5f * gradient) - ((1.0f / 16.0f) * (laplacian * laplacian));
+					fp denominator = 1.0f + (0.25f * laplacian);
+					fp qsqr = numerator / (denominator * denominator);
+					denominator = (qsqr - q0sqr) / (q0sqr * (1.0f + q0sqr));
+					fp diff_coef = 1.0f / (1.0f + denominator);
 
-				// diffusion coefficent (equ 33) (every element of IMAGE)
-				den = (qsqr - q0sqr) / (q0sqr * (1 + q0sqr));// den (based on qsqr and q0sqr)
-				c[k] = 1.0 / (1.0 + den);// diffusion coefficient (based on den)
+					if (diff_coef < 0.0f)
+					{
+						diff_coef = 0.0f;
+					}
+					else if (diff_coef > 1.0f)
+					{
+						diff_coef = 1.0f;
+					}
 
-				// saturate diffusion coefficent to 0-1 range
-				if (c[k] < 0)		// if diffusion coefficient < 0
-				{
-					c[k] = 0;	// ... set to 0
+					c[k] = diff_coef;
 				}
-				else if (c[k] > 1)	// if diffusion coefficient > 1
-				{
-					c[k] = 1;	// ... set to 1
-				}			
-
 			}
-		}
-	//	}
-		
-		// divergence & image update
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: c[:Ne], iS[:Nr], jE[:Nc], dN[:Ne], dS[:Ne],  dW[:Ne], dE[:Ne] ) \
-		map(tofrom: image[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-
 
-			for (i = 0; i < Nr; i++) {		// do for the range of rows in IMAGE
-
-				// current index
-				k = i + Nr * j;				// get position of current element
-
-				// diffusion coefficent
-				cN = c[k];						// north diffusion coefficient
-				cS = c[iS[i] + Nr * j];			// south diffusion coefficient
-				cW = c[k];						// west diffusion coefficient
-				cE = c[i + Nr * jE[j]];			// east diffusion coefficient
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp cN_loc = c[k];
+					fp cS_loc = c[iS[i] + Nr * j];
+					fp cW_loc = c[k];
+					fp cE_loc = c[i + Nr * jE[j]];
 
-				// divergence (equ 58)
-				D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];// divergence
+					fp divergence = cN_loc * dN[k] + cS_loc * dS[k] + cW_loc * dW[k] + cE_loc * dE[k];
+					image[k] = image[k] + 0.25f * lambda * divergence;
 
-				// image update (equ 61) (every element of IMAGE)
-				image[k] = image[k] + 0.25 * lambda * D;// updates image (based on input time step and divergence)
+				}
 
 			}
 
 		}
-	 //	}
-
-	}
 	}
 	t_end = rtclock();
 	t_gpu = t_end - t_start;
@@ -539,5 +520,3 @@
 //====================================================================================================100
 
 }
-
-

exec
/bin/bash -lc './main 10 0.5 502 458 1' in /home/codex_user/lian/codex_baseline/serial_omp_rodinia_workdir/data/src/srad-omp succeeded in 252ms:
Time spent in different stages of the application:
0.000000000000 s, 0.000000000000 % : SETUP VARIABLES
0.000004000000 s, 0.002200849587 % : READ COMMAND LINE PARAMETERS
0.006415000185 s, 3.529612302780 % : READ IMAGE FROM FILE
0.000622000021 s, 0.342232108116 % : RESIZE IMAGE
0.000016000000 s, 0.008803398348 % : SETUP, MEMORY ALLOCATION
0.000747999991 s, 0.411558836699 % : EXTRACT IMAGE
0.166511997581 s, 91.616966247559 % : COMPUTE
0.000407000014 s, 0.223936438560 % : COMPRESS IMAGE
0.006901999936 s, 3.797565698624 % : SAVE IMAGE INTO FILE
0.000121999998 s, 0.067125916481 % : FREE MEMORY
Total time:
0.181748002768 s


GPU Runtime: 0.002652s
CPU Runtime: 0.015696s
GATE:STAT name=srad_arr1_final dtype=f32 n=229916 min=28.5115395 max=254.618698 mean=106.704959 L1=24533177.4 L2=56848.7535
GATE:STAT name=srad_arr2_final dtype=f32 n=229916 min=28.5115395 max=254.618698 mean=106.70496 L1=24533177.5 L2=56848.7535
Non-Matching CPU-GPU Outputs Beyond Error Threshold of 0.05 Percent: 0

thinking
**Summarizing final modifications and tests**

I’m preparing a detailed final message covering changes in `data/src/srad-omp/main.c`—including added includes at line 24 and the GPU offload block starting at line 347 with `target data` and `teams loop` pragmas plus the `target update to(q0sqr)` on line 369. I’ll note the build steps (`make clean`, `make`), the successful GPU run with matching CPU results and GPU runtime, plus the compilation warning about the unused variable `th1`. I’ll also suggest profiling GPU kernels with `nsys` for tuning and list the test commands run, following the user’s requested bullet-list format and references to file lines.
codex
**Changes**
- Added the `<stdio.h>` and `<omp.h>` headers at `data/src/srad-omp/main.c:24` so the file is self-contained for reporting and OpenMP GPU directives.
- Replaced the legacy GPU stub with a `#pragma omp target data` region at `data/src/srad-omp/main.c:347` that stages `image`, neighbor indices, and coefficient buffers; each GPU iteration now runs three `#pragma omp target teams loop` kernels (ROI reduction, derivative/diffusion, divergence/update) with `collapse(2)` and `thread_limit(256)` to exploit the Ada Lovelace device while honoring the “teams loop” requirement.
- The new block copies the computed `q0sqr` value back to the device via `#pragma omp target update to(q0sqr)` at `data/src/srad-omp/main.c:369`, keeping the diffusion kernels in sync with the latest ROI statistics while keeping intermediary arrays resident on the GPU.

**Testing**
- `make -f Makefile.nvc CC=nvc++ CLASS=B clean`
- `make -f Makefile.nvc CC=nvc++ CLASS=B` (build succeeds; existing warning about `th1` being set but unused in upstream code remains)
- `./main 10 0.5 502 458 1` (GPU runtime 0.002652s vs. CPU runtime 0.015696s, GATE stats reported, and GPU/CPU outputs matched with 0 mismatches)

**Next Steps**
1. Profile the new kernels with `nsys` or another NVIDIA tool to tune `thread_limit`/collapse choices and ensure the teams/threads balance maximizes occupancy on the RTX 4060 Ti.
file update:
diff --git a/src/srad-omp/main.c b/src/srad-omp/main.c
index 460fb9a007db407f4f80ff00c0a7395bbc4ead01..6b081525a5c764d4d14ff961f53308fec6698860
--- a/src/srad-omp/main.c
+++ b/src/srad-omp/main.c
@@ -21,9 +21,11 @@
 //	DEFINE / INCLUDE
 //====================================================================================================100
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
+#include <omp.h>
 
 #include "define.c"
 #include "graphics.c"
@@ -341,105 +343,84 @@
 
 	//GPU
 	t_start = rtclock();
-//                map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne], image[:Ne]) - removed - left over grom removing pragma
 
+	#pragma omp target data device(GPU_DEVICE) \
+		map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], lambda, Nr, Nc, r1, r2, c1, c2) \
+		map(tofrom: image[:Ne], q0sqr) \
+		map(alloc: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
 	{
-	for (iter = 0; iter < niter; iter++) {// do for the number of iterations input parameter
+		for (iter = 0; iter < niter; iter++) { // do for the number of iterations input parameter
 
-
-		// ROI statistics for entire ROI (single number for ROI)
-		sum = 0;
-		sum2 = 0;
-		for (i = r1; i <= r2; i++) {		// do for the range of rows in ROI
-			for (j = c1; j <= c2; j++) {// do for the range of columns in ROI
-				tmp = image[i + Nr * j];	// get coresponding value in IMAGE
-				sum += tmp;			// take corresponding value and add to sum
-				sum2 += tmp * tmp;// take square of corresponding value and add to sum2
+			sum = 0;
+			sum2 = 0;
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256) reduction(+:sum,sum2)
+			for (j = c1; j <= c2; j++) {
+				for (i = r1; i <= r2; i++) {
+					fp tmp_loc = image[i + Nr * j];
+					sum += tmp_loc;
+					sum2 += tmp_loc * tmp_loc;
+				}
 			}
-		}
-		meanROI = sum / NeROI;	// gets mean (average) value of element in ROI
-		varROI = (sum2 / NeROI) - meanROI * meanROI;	// gets variance of ROI
-		q0sqr = varROI / (meanROI * meanROI);// gets standard deviation of ROI
 
-		// directional derivatives, ICOV, diffusion coefficent
-	
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: iN[:Nr], iS[:Nr], jW[:Nc], jE[:Nc], image[:Ne] ) \
-	//	map(tofrom: dN[:Ne], dS[:Ne], dW[:Ne], dE[:Ne], c[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-			for (i = 0; i < Nr; i++) {	// do for the range of rows in IMAGE 
-				// current index/pixel
-				k = i + Nr * j;				// get position of current element
-				Jc = image[k];				// get value of the current element
+			meanROI = sum / NeROI;
+			varROI = (sum2 / NeROI) - meanROI * meanROI;
+			q0sqr = varROI / (meanROI * meanROI);
 
-				// directional derivates (every element of IMAGE)
-				dN[k] = image[iN[i] + Nr * j] - Jc;	// north direction derivative
-				dS[k] = image[iS[i] + Nr * j] - Jc;	// south direction derivative
-				dW[k] = image[i + Nr * jW[j]] - Jc;	// west direction derivative
-				dE[k] = image[i + Nr * jE[j]] - Jc;	// east direction derivative
+#pragma omp target update to(q0sqr) device(GPU_DEVICE)
 
-				// normalized discrete gradient mag squared (equ 52,53)
-				G2 = (dN[k] * dN[k] + dS[k] * dS[k]	// gradient (based on derivatives)
-				+ dW[k] * dW[k] + dE[k] * dE[k]) / (Jc * Jc);
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp center = image[k];
+					fp north = image[iN[i] + Nr * j];
+					fp south = image[iS[i] + Nr * j];
+					fp west = image[i + Nr * jW[j]];
+					fp east = image[i + Nr * jE[j]];
 
-				// normalized discrete laplacian (equ 54)
-				L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;// laplacian (based on derivatives)
+					dN[k] = north - center;
+					dS[k] = south - center;
+					dW[k] = west - center;
+					dE[k] = east - center;
 
-				// ICOV (equ 31/35)
-				num = (0.5 * G2) - ((1.0 / 16.0) * (L * L));// num (based on gradient and laplacian)
-				den = 1 + (.25 * L);				// den (based on laplacian)
-				qsqr = num / (den * den);		// qsqr (based on num and den)
+					fp gradient = (dN[k] * dN[k] + dS[k] * dS[k] + dW[k] * dW[k] + dE[k] * dE[k]) / (center * center);
+					fp laplacian = (dN[k] + dS[k] + dW[k] + dE[k]) / center;
+					fp numerator = (0.5f * gradient) - ((1.0f / 16.0f) * (laplacian * laplacian));
+					fp denominator = 1.0f + (0.25f * laplacian);
+					fp qsqr = numerator / (denominator * denominator);
+					denominator = (qsqr - q0sqr) / (q0sqr * (1.0f + q0sqr));
+					fp diff_coef = 1.0f / (1.0f + denominator);
 
-				// diffusion coefficent (equ 33) (every element of IMAGE)
-				den = (qsqr - q0sqr) / (q0sqr * (1 + q0sqr));// den (based on qsqr and q0sqr)
-				c[k] = 1.0 / (1.0 + den);// diffusion coefficient (based on den)
+					if (diff_coef < 0.0f)
+					{
+						diff_coef = 0.0f;
+					}
+					else if (diff_coef > 1.0f)
+					{
+						diff_coef = 1.0f;
+					}
 
-				// saturate diffusion coefficent to 0-1 range
-				if (c[k] < 0)		// if diffusion coefficient < 0
-				{
-					c[k] = 0;	// ... set to 0
+					c[k] = diff_coef;
 				}
-				else if (c[k] > 1)	// if diffusion coefficient > 1
-				{
-					c[k] = 1;	// ... set to 1
-				}			
-
 			}
-		}
-	//	}
-		
-		// divergence & image update
-	//	#pragma omp target device(GPU_DEVICE)
-	//	#pragma omp target map(to: c[:Ne], iS[:Nr], jE[:Nc], dN[:Ne], dS[:Ne],  dW[:Ne], dE[:Ne] ) \
-		map(tofrom: image[:Ne])
-	//	{
-		for (j = 0; j < Nc; j++) {		// do for the range of columns in IMAGE
-
 
-			for (i = 0; i < Nr; i++) {		// do for the range of rows in IMAGE
-
-				// current index
-				k = i + Nr * j;				// get position of current element
-
-				// diffusion coefficent
-				cN = c[k];						// north diffusion coefficient
-				cS = c[iS[i] + Nr * j];			// south diffusion coefficient
-				cW = c[k];						// west diffusion coefficient
-				cE = c[i + Nr * jE[j]];			// east diffusion coefficient
+#pragma omp target teams loop device(GPU_DEVICE) collapse(2) thread_limit(256)
+			for (j = 0; j < Nc; j++) {
+				for (i = 0; i < Nr; i++) {
+					int k = i + Nr * j;
+					fp cN_loc = c[k];
+					fp cS_loc = c[iS[i] + Nr * j];
+					fp cW_loc = c[k];
+					fp cE_loc = c[i + Nr * jE[j]];
 
-				// divergence (equ 58)
-				D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];// divergence
+					fp divergence = cN_loc * dN[k] + cS_loc * dS[k] + cW_loc * dW[k] + cE_loc * dE[k];
+					image[k] = image[k] + 0.25f * lambda * divergence;
 
-				// image update (equ 61) (every element of IMAGE)
-				image[k] = image[k] + 0.25 * lambda * D;// updates image (based on input time step and divergence)
+				}
 
 			}
 
 		}
-	 //	}
-
-	}
 	}
 	t_end = rtclock();
 	t_gpu = t_end - t_start;
@@ -539,5 +520,3 @@
 //====================================================================================================100
 
 }
-
-

tokens used
98,636