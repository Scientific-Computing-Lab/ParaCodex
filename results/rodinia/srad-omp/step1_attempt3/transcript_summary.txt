Reworked the GPU stage to follow the Strategy B data plan so the working image, scratch buffers, and index tables stay resident in a single `target data` region while the ROI reduction, derivative, and divergence kernels execute sequentially with explicit maps but no illegal `depend`/`is_device_ptr` clauses.

- Captured the detailed data management plan in `data_plan.md:1`, covering the timed-region arrays, stage functions, Strategy B allocations/transfers, and expected volumes so the code changes have a documented roadmap.
- Rebuilt the GPU block in `data/src/srad-omp/src/main.c:342` to launch the three kernels back-to-back inside one `target data` region, relying on map clauses and sequential host dispatch for correctness while keeping scratch buffers allocated on the device.
- Ran the mandated CLASS=C builds/runs and `diff`; both scripts print slight timing variations but `Non-Matching CPU-GPU Outputs â€¦ 0` confirms the numerical results match.

**Tests**
- `OMP_TARGET_OFFLOAD=MANDATORY make -f Makefile.nvc CC=nvc++ clean && timeout 300 make -f Makefile.nvc CC=nvc++ CLASS=C run > baseline_output.txt 2>&1` (baseline rebuild/run)
- `OMP_TARGET_OFFLOAD=MANDATORY make -f Makefile.nvc CC=nvc++ clean && timeout 300 make -f Makefile.nvc CC=nvc++ CLASS=C run > gpu_output.txt 2>&1` (post-change GPU run)
- `diff baseline_output.txt gpu_output.txt` (only timer printouts differ; functional output identical)

Next steps:
1. Capture a CLASS B profile (per the profiling step) with `nsys` to gather kernel timing and memory behavior for further optimization.