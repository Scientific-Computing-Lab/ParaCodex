I offloaded the Gaussian-pair processing to an OpenMP target kernel while keeping the RNG loop on the CPU and shrinking the temporary `v60` buffer into a per-iteration slab so that only the current `2*v7` values get pushed to the GPU before computing pairwise contributions.

**Changes**
- Included `<omp.h>` and reduced `v60` to `2*v7` entries so each iteration feeds only the samples needed by the GPU, while `v61` still holds the `v8 Ã— v75` histogram (see `data/src/ep-omp/ep.c:12` and `data/src/ep-omp/ep.c:93-95`).
- Inserted a target teams/distribute/parallel for region that reads the contiguous `v60` slab, applies the Box-Muller transform, atomically accumulates the bin counts, and reduces the sums via `v71`/`v72`, leaving the rest of the CPU logic untouched (`data/src/ep-omp/ep.c:209-235`).

**Validation**
- `make CC=nvc++ CLASS=B clean && make CC=nvc++ CLASS=B` (nvc++ reports the existing unused-variable and deprecated string literal warnings from the original code).
- `./ep.B.x` (initial runs with 120s/240s CLI timeouts exited 124; rerunning with a 600s timeout succeeded after ~324.29s with verification PASS and printed the expected EP output).

Next steps:
1. Profile the GPU kernel (e.g., with `nsys`) to confirm the atomic updates and host-to-device copies are not bottlenecking occupancy.
2. Exercise larger classes or alternate seeds to ensure the offloaded kernel scales and verifies across the full EP suite.