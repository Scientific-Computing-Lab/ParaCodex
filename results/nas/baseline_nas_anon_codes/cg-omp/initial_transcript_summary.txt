Converted `cg.c` so the heavy conjugate-gradient kernel stays on the GPU: added `#include <omp.h>` and wrapped `f1` inside a single `#pragma omp target data` region that keeps the sparse matrix, solution vectors, and reductions resident on the device while the per-iteration matrix-vector multiply and dot-product loops run with `#pragma omp target teams distribute parallel for` across the GPU (see `data/src/cg-omp/cg.c:12-15` and `data/src/cg-omp/cg.c:531-639`). That block now mirrors the original loop ordering, and we removed the earlier `map(present: …)` clauses after `compute-sanitizer` flagged illegal writes so every kernel simply reuses the device mapping instead of trying to remap host pointers.

**Validation**
- `make clean && make CC=nvc++ CLASS=B` (the compile still emits the pre-existing string-literal-to-`char*` warnings plus the unused `v128`/`v129` notices; no new diagnostics from the offload code).
- `./cg.B.x` (runs to completion, prints all Class B iterations, and ends with “VERIFICATION SUCCESSFUL” for zeta).
- `compute-sanitizer ./cg.B.x` was used during debugging to pinpoint the invalid writes that appeared when `map(present: …)` was present; once those clauses were removed the regular run above completes cleanly.

Next, you might profile the offloaded kernel (e.g., with `nsys`/`ncu`) to tune occupancy, memory coalescing, or reduction strategies now that the GPU version is functionally correct.