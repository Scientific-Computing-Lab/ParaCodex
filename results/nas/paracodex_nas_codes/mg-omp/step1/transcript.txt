Added persistent GPU data management (target enter/exit data) in `mg.c` and synchronized host init with `target update` for the RNG-generated RHS. Offloaded multigrid kernels (`resid`, `psinv`, `rprj3`, `interp`, `norm2u3`, `comm3`, `zero3`) with `target data` scratch allocations and `target teams loop` stencils, keeping all iterative work on the RTX 4060 device under `OMP_TARGET_OFFLOAD=MANDATORY`.

Tests (in `data/src/mg-omp`):
- `make clean`
- `make CC=nvc++ CLASS=B`
- `timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make CC=nvc++ CLASS=A run > gpu_output.txt 2>&1`

Verification in `gpu_output.txt`: `VERIFICATION SUCCESSFUL` (matches baseline).

OpenAI Codex v0.65.0 (research preview)
--------
workdir: /root/codex_baseline/serial_omp_nas_workdir
model: gpt-5.1-codex-max
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: low
reasoning summaries: auto
session id: 019af9a6-104f-7ce3-8cf9-ff45220e9718
--------
user
Directory: /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp

# GPU Offload with OpenMP

**Directory:** `/root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/`  
**Files:** - mg.c  
**Reference:** `/root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/analysis.md`

**Required:** 
- Use `OMP_TARGET_OFFLOAD=MANDATORY` for all runs
- DO NOT use `distribute parallel for`

## Workflow

### 0. Backup
Save backup of - mg.c.

### 1. Get Baseline (CLASS A/S)
```bash
cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp
make clean
timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make CC=nvc++ CLASS=A run > baseline_output.txt 2>&1
# Fallback: timeout 60 env OMP_TARGET_OFFLOAD=MANDATORY make CC=nvc++ CLASS=S run > baseline_output.txt 2>&1
grep -E "Verification|SUCCESSFUL|FAILED" baseline_output.txt

DO NOT SKIP THIS STEP.
```

### 2. Choose Data Strategy
Walk through IN ORDER, stop at first match:

```
RULE 1: Type B (Sparse/CSR)?              → STRATEGY C
RULE 2: Type C1 (FFT/Butterfly)?          → STRATEGY C
RULE 3: Type C2 (Multigrid)?              → STRATEGY A
RULE 4: Outer A + inner E (per-thread RNG)?→ STRATEGY A
RULE 5: Multiple independent kernels?     → STRATEGY B
RULE 6: Otherwise                         → STRATEGY A
```

### 2.5. Create Data Management Plan
MANDATORY: Create data_plan.md before implementation
Analyze ALL arrays and functions in timed region:

```markdown

# Data Management Plan

## Arrays Inventory
List ALL arrays used in timed region:

| Array Name | Size | Type | Init | Access |
|------------|------|------|------|--------|
| [name] | [bytes] | working/scratch/const/index | host/device | R/W/RO |

**Types:** working (main data), scratch (temp), const (read-only), index (maps)

## Functions in Timed Region
| Function | Arrays Accessed | Frequency | Must Run On |
|----------|----------------|-----------|-------------|
| [name] | [list] | per-iteration/once | device/host |

## Data Movement Strategy

**Chosen Strategy:** [A/B/C]

**Device Allocations (once):**
```
Strategy C: d_[array]: [size] via omp_target_alloc
Strategy A: [arrays] in target data region
```

**Host→Device Transfers:**
- When: [before iterations/once at start]
- Arrays: [array1]→d_[array1] ([size] MB)
- Total H→D: ~[X] MB

**Device→Host Transfers:**
- When: [after iterations/once at end]
- Arrays: d_[array1]→[array1] ([size] MB)
- Total D→H: ~[Y] MB

**Transfers During Iterations:** [YES/NO]
- If YES: [which arrays and why]
- If NO: All data stays on device

## Critical Checks (for chosen strategy)

**Strategy A:**
- [ ] Functions inside target data use `present,alloc` wrapper?
- [ ] Scratch arrays use enter/exit data OR omp_target_alloc?

**Strategy C:**
- [ ] ALL functions in iteration loop use is_device_ptr?
- [ ] Scratch arrays allocated on device (not host)?
- [ ] No map() clauses (only is_device_ptr)?

**Common Mistakes:**
-  Some functions on device, others on host (causes copying)
-  Scratch as host arrays in Strategy C
-  Forgetting to offload ALL functions in loop

## Expected Transfer Volume
- Total: ~[X+Y] MB for entire execution
- **Red flag:** If actual >2x expected → data management wrong

**Summary:** [num] arrays ([num] scratch, [num] working), [num] functions, Strategy [A/B/C]. Expected: ~[X] MB H→D, ~[Y] MB D→H.
```

### 2.6. Implement Data Plan

**Use data_plan.md as implementation guide**

### Step 1: Setup Data Structures
From "Arrays Inventory" and "Data Movement Strategy":
- Declare device arrays/pointers as needed for chosen strategy
- Create allocation/initialization functions based on strategy:
  - **Strategy A:** Setup target data regions with map clauses from plan
  - **Strategy B:** Prepare depend clauses for async operations
  - **Strategy C:** Create omp_target_alloc calls using sizes from plan

### Step 2: Implement Transfers
From "H→D Transfers" and "D→H Transfers" sections:
- Implement each transfer listed with timing specified in plan
- Use method appropriate for strategy (map clauses, omp_target_memcpy, update, etc.)

### Step 3: Offload Functions
Use "Functions in Timed Region" table:
- For each function where "Must Run On" = device:
  - Add appropriate pragma for strategy
  - Include arrays from "Arrays Accessed" column
  - Follow strategy-specific patterns from Step 2

### Step 4: Main Program Flow
Follow "Data Movement Strategy" timing:
```
[setup from plan]
[H→D transfers at specified time]
[timed computation - call functions]
[D→H transfers at specified time]
[cleanup]
```

### Step 5: Verify Implementation
Check ALL items in "Critical Checks" section for YOUR strategy:
- [ ] Verify each checkpoint matches implementation
- [ ] Cross-reference "Functions in Timed Region" table
- [ ] Confirm transfer timing matches plan

**Common errors:** Mismatched array names, missing functions from table, wrong transfer timing

**Ready when:** All strategy-specific checks ✓ and compiles
---

## Strategy Details

### STRATEGY A: target data Region

**Map Clause Selection:**
| Scenario | Map Clause | Why |
|----------|------------|-----|
| Device-init arrays (zero(), fill()) | `alloc` | Avoid copying garbage |
| Host RNG init then sync | `alloc` + `update to` | Explicit sync after host init |
| Read + modify + write | `tofrom` | Bidirectional |
| Read-only | `to` | One-way |

**Functions Called Inside target data:**
Wrap with `present,alloc`/'to,tofrom', then use bare `target teams loop`:
```c
void compute(double *u, double *v, int n) {
  #pragma omp target data map(present,alloc:u[0:n],v[0:n])
  {
    #pragma omp target teams loop
    for (int i = 0; i < n; i++) { ... }
  }
}
```

**alloc + device init**
```c
#pragma omp target data map(alloc:arr1[0:N],arr2[0:N],arr3[0:N])
{
  device_zero(arr1, n);       // Initializes arr1 ON DEVICE
  device_fill(arr2, n, val);  // Initializes arr2 ON DEVICE
  
  // Host-side RNG init? Use target update to sync AFTER host fills array
  host_rng_init(arr3, n);
  #pragma omp target update to(arr3[0:N])
  
  for (iter = 0; iter < NITER; iter++) {
    #pragma omp target teams loop
    for (j = 0; j < N; j++) { ... }
  }
}
```

**Scratch Arrays (two options):**

- **Option 1: enter/exit data**
```c
double scratch[N];
#pragma omp target enter data map(alloc:scratch[0:n])
#pragma omp target data map(present,alloc:in[0:n])
{
  #pragma omp target teams loop
  for (...) { /* use scratch */ }
}
#pragma omp target exit data map(delete:scratch[0:n])
```

- **Option 2: omp_target_alloc**
```c
double *scratch = (double*)omp_target_alloc(n*sizeof(double), 0);
#pragma omp target data map(present,alloc:in[0:n])
{
  #pragma omp target teams loop is_device_ptr(scratch)
  for (...) { ... }
}
omp_target_free(scratch, 0);
```

**Mid-computation sync:**
```c
#pragma omp target update from(result)
host_compute(result);
#pragma omp target update to(indices)
```

### STRATEGY B: Asynchronous Offload
Use when: Overlapping compute/transfer possible
```c
#pragma omp target teams loop nowait depend(out:x[0])
for (i = 0; i < N; i++) { x[i] = init(i); }

#pragma omp target teams loop nowait depend(in:x[0]) depend(out:y[0])
for (i = 0; i < N; i++) { y[i] = compute(x[i]); }

#pragma omp taskwait
```

STRATEGY C: Global Device State (Iterative Solvers)
Only use omp_target_alloc + is_device_ptr
CRITICAL: This strategy is MANDATORY for iterative solvers
Pattern:

Shadow globals: static double *d_arr
Lifecycle: allocate_device(), copy_to_device(), free_device() in main
Reduction helpers ONLY: Small functions returning scalars (dot products) - e.g., device_dot()
INLINE ALL OTHER KERNELS: SpMV, vector updates, scaling operations MUST be inlined in the iteration loop

INLINING IS CRITICAL.

CORRECT Pattern for Iterative Solver:
cint tmp1, tmp2, tmp3;  // Function scope for register caching

// Setup once
allocate_device_arrays();
copy_to_device();

for (iter = 1; iter <= maxiter; iter++) {
  // INLINE SpMV - do NOT call device_spmv() function
  #pragma omp target teams loop is_device_ptr(d_rowptr, d_col, d_val, d_p, d_q)
  for (int i = 0; i < nrows; i++) {
    tmp1 = d_rowptr[i];
    tmp2 = d_rowptr[i+1];
    double sum = 0.0;
    #pragma omp loop reduction(+:sum)
    for (int k = tmp1; k < tmp2; k++) {
      tmp3 = d_col[k];
      sum += d_val[k] * d_p[tmp3];
    }
    d_q[i] = sum;
  }
  
  // Reduction helper OK - returns scalar
  double pq = device_dot(d_p, d_q, n);
  alpha = rho / pq;
  
  // INLINE vector updates - do NOT call device_update() function
  #pragma omp target teams loop is_device_ptr(d_x, d_r, d_p, d_q)
  for (int i = 0; i < n; i++) {
    d_x[i] += alpha * d_p[i];
    d_r[i] -= alpha * d_q[i];
  }
  
  rho_new = device_dot(d_r, d_r, n);
  beta = rho_new / rho;
  
  // INLINE update - do NOT call device_update_p() function
  #pragma omp target teams loop is_device_ptr(d_p, d_r)
  for (int i = 0; i < n; i++) {
    d_p[i] = d_r[i] + beta * d_p[i];
  }
  
  rho = rho_new;
}

WRONG Pattern (causes 10-100x slowdown):
for (iter = 1; iter <= maxiter; iter++) {
  device_spmv(d_q, d_p, n);     // Launch 1
  pq = device_dot(d_p, d_q, n); // Launch 2 (OK)
  device_axpy(d_x, ...);        // Launch 3
  device_axpy(d_r, ...);        // Launch 4
}

Operation | Helper? | Why |
|-----------|---------|--------|
| Dot/norm | YES | Returns scalar |
| SpMV in loop | NO | Every iteration |
| Vector update | NO | Every iteration |
| Init (once) | YES | Once before loop |
| Verification (once) | YES | Once after loop |
---

### 3. Map Globals & Functions
```c
#pragma omp declare target
double helper_func() { ... };
#pragma omp end declare target

#pragma omp declare target(global_var)
```
---

## 4. Parallelize loops

**Parallelization patterns:**

**Type A (Dense):**
```c
#pragma omp target teams loop collapse(2)
for (i = 0; i < N; i++)
  for (j = 0; j < M; j++) ...
```

**Type B (Sparse/CSR) - Nested Parallelism:**
```c
int tmp1, tmp2, tmp3;  // Function scope
#pragma omp target teams loop is_device_ptr(...)
for (int row = 0; row < nrows; row++) {
  tmp1 = rowptr[row];
  tmp2 = rowptr[row+1];
  double sum = 0.0;
  #pragma omp loop reduction(+:sum)  // Parallelize inner
  for (int k = tmp1; k < tmp2; k++) {
    tmp3 = colidx[k];
    sum += A[k] * x[tmp3];
  }
  y[row] = sum;
}
```

**Type C1 (FFT) - Serial Inner:**
```c
#pragma omp target teams is_device_ptr(...)
{
#pragma omp loop collapse(2)
  for (k = 0; k < K; k++) {
    for (j = 0; j < J; j++) {
      for (stage = 0; stage < S; stage++) { ... }  // No pragma - keep inner serial!
    }
  }
}
```

**Type C2 (Multigrid):** Wrap with `present,alloc`; each stencil call gets `target teams loop`.

**Type D (Histogram):** Add `#pragma omp atomic` on indirect writes.

**Type F (Reduction):** `reduction(+:sum)`

**Type G (Stencil):** `collapse(2)` on spatial dimensions.

**Type A+E (Outer parallel, inner RNG):** Add `declare target` on RNG function.

## 5. Compile and Test (CLASS A/S)
```bash
make clean
make CC=nvc++ CLASS=B
timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make CC=nvc++ CLASS=A run > gpu_output.txt 2>&1
# Fallback: timeout 60 env OMP_TARGET_OFFLOAD=MANDATORY make CC=nvc++ CLASS=S run > gpu_output.txt 2>&1
```

If timeout/segfault: Remove `#pragma omp loop` from Type C inner loops.

## 6. Verify Correctness
```bash
diff baseline_output.txt gpu_output.txt
```

## 8. Profile (CLASS B)
** NEVER RUN WITH CLASS C , ONLY RUN WITH CLASS B.**
```bash
make clean
env OMP_TARGET_OFFLOAD=MANDATORY nsys profile --stats=true --trace=cuda,osrt --force-overwrite=true -o nsys_profile make CC=nvc++ CLASS=B run > /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/profile.log 2>&1
# Fallback: env OMP_TARGET_OFFLOAD=MANDATORY nsys profile --stats=true --trace=cuda,osrt --force-overwrite=true -o nsys_profile make CC=nvc++ CLASS=B run > /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/profile.log 2>&1
grep "cuda_gpu_kern" /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/profile.log | head -5
```

#**RULES** BRAKING A RULE = FAILURE.
- NO GIT COMMANDS.
- DO NOT READ/WRITE OUTSIDE THE WORKING DIRECTORY.
- DO NOT EDIT MAKEFILES.
- ALWAYS CLEAN BEFORE BUILD.
- DO NOT CHANGE/EDIT FILES OTHER THEN - mg.c


you might want to leave comments in the code to explain your changes.

the code might contain macros like GATE_CHECKSUM_* or GATE_STATS_*, you should not change them.

you need to check what hardware you are running on in `system_info.txt` and use the information to optimize your code.


mcp startup: no servers

thinking
**Preparing to read system info and backup**
exec
/bin/bash -lc ls in /root/codex_baseline/serial_omp_nas_workdir succeeded in 8ms:
AGENTS.md
data
gate_sdk
golden_labels
npb3.3.1.tar.gz
system_info.txt
test_all_nas_kernels.sh
exec
/bin/bash -lc 'cat system_info.txt' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 14ms:
=== SYSTEM BASELINE ===
Linux ErelPC 6.6.87.2-microsoft-standard-WSL2 #1 SMP PREEMPT_DYNAMIC Thu Jun  5 18:30:46 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux
PRETTY_NAME="Ubuntu 22.04.3 LTS"
NAME="Ubuntu"
VERSION_ID="22.04"
VERSION="22.04.3 LTS (Jammy Jellyfish)"
VERSION_CODENAME=jammy
ID=ubuntu
ID_LIKE=debian
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
UBUNTU_CODENAME=jammy
ldd (Ubuntu GLIBC 2.35-0ubuntu3.11) 2.35

=== FIRMWARE & MICROCODE ===
# dmidecode 3.3
Scanning /dev/mem for entry point.
# No SMBIOS nor DMI entry point found, sorry.

thinking
**Backing up mg.c before baseline**

I'm preparing to save a backup of mg.c before any modifications to preserve the original, ensuring backup happens now prior to the mandatory baseline step.
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && cp mg.c mg.c.backup' in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 17ms:


thinking
**Running baseline tests with specified environment and compiler**
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && make clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 15ms:
rm -f *.o *~ ../common/*.o *.w2c.c *.w2c.h *.i *.B *.t *.w2c.cu *.w2c.ptx *.spin *.s *.x
rm -f npbparams.h core

thinking
**Starting baseline command implementation**
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make CC=nvc++ CLASS=A run > baseline_output.txt 2>&1' in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 6.91s:


thinking
**Planning verification step**
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && grep -E "Verification|SUCCESSFUL|FAILED" baseline_output.txt' in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 9ms:
 VERIFICATION SUCCESSFUL
 Verification    =               SUCCESSFUL

thinking
**Planning data strategy for multigrid**

I'm confirming this is the C2 multigrid variant and the data strategy A applies per rules. Next, I'll study mg.c and analysis.md to map arrays for the data_plan.md before implementing.
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && ls' in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 13ms:
Makefile
README
analysis.md
baseline_output.txt
common
common copy
config
globals.h
mg.A.x
mg.c
mg.c.backup
mg.config
mg.o
npbparams.h
sys

thinking
**Preparing to analyze timed regions in mg.c**

I'm planning to identify arrays used in the timed regions of the mg NAS kernel by reading relevant functions in mg.c, aiming to focus on main iteration loops with selective line extraction.
exec
/bin/bash -lc "cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && sed -n '1,240p' mg.c" in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 13ms:

#ifdef __PGIC__
#undef __GNUC__
#else
#define num_workers(a)
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "globals.h"

#include "timers.h"
#include "print_results.h"

#define I3D(array,n1,n2,i3,i2,i1) (array[(i3)*n2*n1 + (i2)*n1 + (i1)])

static void setup(int *n1, int *n2, int *n3);
static void mg3P(double u[], double v[], double r[],
exec
/bin/bash -lc "cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && sed -n '240,480p' mg.c" in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 11ms:
      verified = false;
      printf(" VERIFICATION FAILED\n");
      printf(" L2 Norm is             %20.13E\n", rnm2);
      printf(" The correct L2 Norm is %20.13E\n", verify_value);
    }
  } else {
    verified = false;
    printf(" Problem size unknown\n");
    printf(" NO VERIFICATION PERFORMED\n");
    printf(" L2 Norm is %20.13E\n", rnm2);
  }

  nn = 1.0 * nx[lt] * ny[lt] * nz[lt];

  if (t != 0.0) {
    mflops = 58.0 * nit * nn * 1.0e-6 / t;
  } else {
    mflops = 0.0;
  }

exec
/bin/bash -lc "cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && sed -n '480,960p' mg.c" in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 9ms:
						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
									+ I3D(u1, n1, n2, i3, i2, i1+1))
						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
      }
    }
  }
  } 
  } 

  #ifdef _OPENACC
  	acc_free(u1);
  	acc_free(u2);
  #else
  	free(u1);
  	free(u2);
  #endif
  if (timeron) timer_stop(T_resid);

  comm3(orr, n1, n2, n3, k);

exec
/bin/bash -lc "cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && sed -n '960,1440p' mg.c" in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 12ms:
  t4 = (int) (r46 * t3);
  *x = t3 - t46 * t4;
  r = r46 * (*x);
  
  return r;
}

inline void vranlc( int n, double *x, double a, double y[] )
{
	
  const double r23 = 1.1920928955078125e-07;
  const double r46 = r23 * r23;
  const double t23 = 8.388608e+06;
  const double t46 = t23 * t23;

  double t1, t2, t3, t4, a1, a2, x1, x2, z;

  int i;
  t1 = r23 * a;
  a1 = (int) t1;

thinking
**Mapping multigrid arrays and globals**

Identified core arrays u, v, r as globals needed for iterative multigrid and noted key timed functions (resid, mg3P) that use helper functions and arrays like m1, m2, m3; next step is checking globals.h to confirm array declarations and data layout.
exec
/bin/bash -lc "cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && sed -n '1,240p' globals.h" in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 12ms:
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB MG code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //

thinking
**Planning GPU offload data mapping**

I'm analyzing main and scratch arrays to ensure correct OpenMP target data mapping, focusing on `u`, `v`, `r`, and integer arrays for device accessibility. I'll create a data_plan.md summarizing these arrays and their sizes to guide mapping decisions and avoid distributed parallel for loops by using target teams loops.
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && cat npbparams.h' in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 10ms:
/* CLASS = A */
/*
   This file is generated automatically by the setparams utility.
   It sets the number of processors and the class of the NPB
   in this directory. Do not modify it by hand.   
*/
#define NX_DEFAULT     256
#define NY_DEFAULT     256
#define NZ_DEFAULT     256
#define NIT_DEFAULT    4
#define LM             8
#define LT_DEFAULT     8
#define DEBUG_DEFAULT  0
#define NDIM1          8
#define NDIM2          8
#define NDIM3          8
#define ONE            1

#define CONVERTDOUBLE  false
#define COMPILETIME "07 Dec 2025"

thinking
**Planning OpenMP target data mapping for arrays**

I'm analyzing key arrays (u, v, r) and their use across timed and initialization phases to design an efficient OpenMP target data mapping strategy. The plan is to allocate and map these arrays with tofrom mapping after host initialization but before the first timed residual call, minimizing data transfers by encompassing the main benchmark region and updating device data after host-based initialization functions.

thinking
**Planning GPU data management**

I'm outlining a strategy to manage device data using OpenMP target data regions with maps for to/from/alloc to minimize host-device transfers. I'll wrap the main timed region with target data maps for key arrays and handle scratch arrays via alloc and present maps inside called functions, ensuring consistent device pointers and avoiding redundant copies.

thinking
**Planning device memory mapping and loops**

I'm structuring device offloading by wrapping functions with target data regions that map present arrays and allocate scratch arrays on device using map(alloc) or omp_target_alloc. For multi-dimensional loops, Type C2 stencil parallelism with target teams loop collapse(3) fits best, but loop boundaries and dependencies need careful handling.

thinking
**Planning multigrid loop structuring**

I'm considering wrapping stencil calls with target teams loops using collapse(2) to handle independent elements efficiently while avoiding separate scratch operations. I also need to ensure constant arrays passed as function arguments are available on the device and plan to compute array sizes from headers before creating the data plan.
exec
/bin/bash -lc "python - <<'PY'
import math
NDIM=8
NV=(2+(1<<NDIM))**3
NM=2+(1<<8)
LM=8
NR=((NV+NM*NM+5*NM+7*LM+6)//7)*8
print(NV, NM, NR)
PY" in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 17ms:
17173512 258 19704488

thinking
**Planning detailed data and array sizing**

I'm preparing a comprehensive data plan documenting array sizes, expected memory usage, transfer sizes between host and device, and function access patterns based on the current GPU hardware and memory constraints. This plan will precede code changes and includes categorizing arrays, scratch buffers, and function usage frequency.

thinking
**Planning unified target data region**

I'm deciding to wrap the entire benchmark—including initial residual and norm computations—inside a single target data region to minimize host-device transfers. This means mapping all needed arrays upfront after initialization but before starting the timer, ensuring data stays on the device through the full timed loop and copies back only once afterward for verification.

thinking
**Adding data plan documentation**

I'm creating a data_plan.md file using apply_patch to specify the data plan details.
file update
A /root/codex_baseline/serial_omp_nas_workdir/data_plan.md
# Data Management Plan

## Arrays Inventory
List ALL arrays used in timed region:

| Array Name | Size | Type | Init | Access |
|------------|------|------|------|--------|
| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |

## Functions in Timed Region
| Function | Arrays Accessed | Frequency | Must Run On |
|----------|----------------|-----------|-------------|
| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
| mg3P (driver) | u, v, r | per-iteration | device |
| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
| zero3 | u slices | per-level inside mg3P | device |
| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
| norm2u3 | r | once before loop + once after loop | device |

## Data Movement Strategy

**Chosen Strategy:** A

**Device Allocations (once):**
```
target data region holding u[0:NR], v[0:NR], r[0:NR]
Scratch arrays per kernel via map(alloc:) inside each routine
```

**Host→Device Transfers:**
- When: enter benchmark region before first resid in timed loop
- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
- Total H→D: ~474 MB

**Device→Host Transfers:**
- When: exit benchmark target data after iterations
- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
- Total D→H: ~316 MB

**Transfers During Iterations:** NO
- All working and scratch data stay on device for duration of timed loop.

## Critical Checks (for chosen strategy)

**Strategy A:**
- [ ] Functions inside target data use `present` wrappers
- [ ] Scratch arrays use enter/exit data OR device alloc

## Common Mistakes:
-  Some functions on device, others on host (causes copying)
-  Scratch as host arrays in Strategy C
-  Forgetting to offload ALL functions in loop

## Expected Transfer Volume
- Total: ~790 MB for entire execution
- **Red flag:** If actual >2x expected → data management wrong

**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
A data_plan.md
file update:
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Deciding plan box marking approach**

Considering whether to mark unchecked checkboxes or leave them as is, with special attention to "Critical Checks" which might be marked later; planning to implement data plan modifications only in mg.c using a multi-step update_plan approach.
Plan update
Implement OpenMP GPU offload for MG with target data strategy A per data_plan.md.
  → Analyze mg.c loops and globals; design target data scope and device helpers.
  • Add OpenMP target data management and declare-target globals/functions.
  • Parallelize kernels (resid, psinv, rprj3, interp, comm3, zero3, norm2u3) with target teams loops and device scratch allocation.
  • Build and run GPU target baseline (CLASS A or S) and verify output.
file update:
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Reviewing OpenMP target data mapping**

I’m clarifying how static global arrays used in target regions need to be mapped or declared with `declare target` to ensure device accessibility, considering that OpenMP requires explicit mapping or declaring for static storage variables. Next, I’ll decide whether to map these arrays explicitly before loops or pass them as parameters.

thinking
**Planning offloading strategy with target data regions**

Deciding to keep mg3P host-controlled but offload its internal functions operating on device data within a target data region set up around timed benchmark operations. Considering how to handle initial host-only setup, data mapping, and fallback to host execution to avoid unnecessary data transfers and ensure compatibility.

thinking
**Planning persistent device data region**

I'm outlining creating a persistent OpenMP target data region after initial setup (zero3, zran3) mapping u and v to device and allocating r, so later computations run fully on device without repeated mappings. This covers warmup calls before timing and ensures data stays present on device through the program, needing a final update back to host after the last norm for verification.

thinking
**Planning persistent device data management**

I'm outlining use of OpenMP enter/exit data directives to persist arrays on the device and avoid repeated host-device copies. I'll offload zero3 and zran3 functions to run on the device to keep data modifications local, eliminating the need for frequent host-to-device updates during setup phases.

thinking
**Balancing host vs device RNG and data updates**

Considering GPU offload, RNG in zran3 is complex due to pow and loops, so keeping it host-side with data transfer seems simpler; zero3 can move to device after mapping arrays to reduce host-device updates while later zero3 and zran3 calls may still run on host followed by explicit device data updates to stay consistent with minimal transfer overhead.

thinking
**Evaluating RNG offload feasibility**

The RNG function uses sequential updates with dependencies, making GPU parallelization risky and possibly changing results. It's better to keep RNG runs on the host and delay device data mapping until after the final RNG update to minimize costly data transfers while ensuring correct random sequences.

thinking
**Analyzing data mapping strategy**

I'm assessing how to map arrays for correctness with offloading, balancing when to run key routines on device versus host to minimize costly host-to-device transfers. Using map(alloc) for some arrays could reduce redundant data copies and keep memory transfer within planned limits.

thinking
**Adjusting data mapping and execution plan**

Considering aligning mapping for `r` with `alloc` and keeping to/from mapping as per current plan to avoid inconsistencies; planning to delay device mapping of `r` until after final zero-initialization to prevent copying uninitialized data and keep pre-benchmark functions on the host, possibly via conditional compilation to maintain host fallback.

thinking
**Planning device data mapping and offload strategy**

Data must be mapped before device use to avoid undefined results, so I’ll create a target data region after initial host setup and before key computations to encompass all offloaded work. Because zran3 relies on sequential RNG updates, it can't be parallelized safely on the device and should run on the host with data transfers afterward. Zero3 is simpler and can run on device after mapping, requiring separate host and device versions called appropriately. This restructuring keeps data consistent and respects GPU offload requirements.

thinking
**Planning OpenMP target data mapping**

I'm outlining a timeline to map arrays persistently on the device after initial host setup but before resid runs, using `target enter data` with `to` for initialized arrays and `alloc` for uninitialized ones like r that resid will overwrite. This avoids repeated mapping and ensures resid and subsequent kernels operate on device-resident data with correct boundary handling by comm3.

thinking
**Planning device offload with scratch arrays**

I'm outlining device offload for key kernels using OpenMP target data with present and alloc maps, managing scratch arrays sized per problem dimensions, and ensuring synchronization between host and device after host updates using explicit target update directives.

thinking
**Refining OpenMP target mapping and reduction strategy**

Considering initializing the reduction variable to zero explicitly for clarity, and using `target teams loop collapse(3)` pragmas with appropriate mapping of array slices including `r`. Planning to keep some RNG functions host-only to avoid extra declare target directives. Noted mismatch in planned vs. actual data mapping for `r` and considering updating the plan file to align with the implemented target data map approach.

thinking
**Planning OpenMP target data mapping**

I’m working through mapping strategy for persistent OpenMP device data, aiming to keep `r` mapped as tofrom despite being uninitialized for minor overhead. Considering when to insert target enter data directives and whether to modify zero3 to run on device with mapped data or conditionally choose host/device to avoid duplicate copies while preserving persistent mapping.

thinking
**Planning data mapping to avoid host fallback**

I'm considering mapping arrays with `target enter data` at the start to ensure device presence before the first functions run, avoiding fallback to host loops and duplicated code paths, while using updates as needed for host consistency. This should simplify offloading by guaranteeing arrays are present on the device early.

thinking
**Planning device data mapping and zero initialization**

The plan is to allocate device arrays early and offload zero3 to initialize device data using present mappings, while managing host-device coherence carefully around zero3 and zran3 since zran3 uses host arrays and device arrays may be out of sync until data updates occur.

thinking
**Planning host-device data consistency**

I'm clarifying that zero3 will run on device to keep host copies consistent only when needed and that zran3 host updates require explicit device update directives. Host reads of u before exit seem minimal or offloaded, so full host sync until exit isn't critical. Next, I'll insert target data enter/exit pragmas carefully around main computations and adjust mappings to ensure correct data length and synchronization.

thinking
**Planning OpenMP offload modifications**

I'm setting up device allocations and data mapping for arrays, adjusting zero3 to run on device to avoid host updates, and ensuring correct data movement for dependent arrays like v and r. I'll start modifying functions like resid to use target data regions with proper mapping and parallel loops.

thinking
**Planning OpenMP target data mapping and loop variable scoping**

I'm clarifying loop variable declarations to avoid unintended shared scopes, planning precise map clauses with correct array sizes for fine and coarse grids, and considering proper reduction handling for scalar results in target regions. Next, I'll verify offloaded communication calls and ensure all device code includes required headers without using unsupported directives.
file update:
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Correcting file paths for patch application**

I realized the patch likely needs to reference the full relative path "data/src/mg-omp/mg.c" instead of just "mg.c" to apply correctly, so I'll adjust paths accordingly before retrying.
file update:
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Diagnosing patch failure**

I'm investigating potential indentation or whitespace differences causing the patch failure and planning to reapply smaller patch segments near the affected region.
exec
/bin/bash -lc "cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && sed -n '60,140p' mg.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 10ms:
  logical verified;

  int i;
  char *t_names[T_last];
  double tmax;

  for (i = T_init; i < T_last; i++) {
    timer_clear(i);
  }
  timer_start(T_init);

  FILE *fp;
  if ((fp = fopen("timer.flag", "r")) != NULL) {
    timeron = true;
    t_names[T_init] = "init";
    t_names[T_bench] = "benchmk";
    t_names[T_mg3P] = "mg3P";
    t_names[T_psinv] = "psinv";
    t_names[T_resid] = "resid";
    t_names[T_rprj3] = "rprj3";
file update:
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

exec
/bin/bash -lc "cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && sed -n '140,240p' mg.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 30ms:
      
  if (Class == 'A' || Class == 'S' || Class =='W') {

    c[0] =  -3.0/8.0;
    c[1] =  +1.0/32.0;
    c[2] =  -1.0/64.0;
    c[3] =   0.0;
  } else {

    c[0] =  -3.0/17.0;
    c[1] =  +1.0/33.0;
    c[2] =  -1.0/61.0;
    c[3] =   0.0;
  }
  lb = 1;
  k  = lt;

{
  setup(&n1, &n2, &n3);
  zero3(u, n1, n2, n3);
file update:
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Planning incremental patching**

I'm preparing to add the `<omp.h>` include near the top first, then proceed with smaller, sequential changes for careful patching.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -10,2 +10,3 @@
 #include <math.h>
+#include <omp.h>
 
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..46dc3113dc23f29a3eb5d34dac36a34059740c7e
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..46dc3113dc23f29a3eb5d34dac36a34059740c7e
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Preparing to insert target enter data directive**

Planning to add the OpenMP target enter data mapping pragma just before the main setup block, making sure to place it before the existing opening brace to keep the structure correct.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -157,2 +157,4 @@
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..29eb6819a1b5a47a415277e8d7be5bfaa8e4f72f
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,8 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..29eb6819a1b5a47a415277e8d7be5bfaa8e4f72f
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,8 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Scheduling patch after zran3 call**
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -163,2 +163,3 @@
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0e588b6431297a6d9d241e2c5a3394a981b647c4
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0e588b6431297a6d9d241e2c5a3394a981b647c4
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Adding target update after second zran3**
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -181,2 +181,3 @@
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
apply_patch(auto_approved=true) exited 0 in 20ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..ec85709c7f151bf51158eff62e33fe3e38aeaeb0
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..ec85709c7f151bf51158eff62e33fe3e38aeaeb0
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Adding target exit data after timer stop**
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -210,2 +210,3 @@
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..f36405ddb0fb2b9df94db429619b90b77e7ff9f7
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..f36405ddb0fb2b9df94db429619b90b77e7ff9f7
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Preparing function patches for target usage**

Identified multiple functions needing modification to use the target parameter; focusing first on patching psinv carefully since it currently uses earlier malloc calls, requiring attention to its view portion for accurate updates.
exec
/bin/bash -lc "cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && sed -n '300,520p' mg.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 12ms:
  for (k = lt-1; k >= 1; k--) {
    for (ax = 0; ax < 3; ax++) {
      ng[k][ax] = ng[k+1][ax]/2;
    }
  }
  for (k = lt; k >= 1; k--) {
    nx[k] = ng[k][0];
    ny[k] = ng[k][1];
    nz[k] = ng[k][2];
  }

  for (k = lt; k >= 1; k--) {
    for (ax = 0; ax < 3; ax++) {
      mi[k][ax] = 2 + ng[k][ax];
    }

    m1[k] = mi[k][0];
    m2[k] = mi[k][1];
    m3[k] = mi[k][2];
  }
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..f36405ddb0fb2b9df94db429619b90b77e7ff9f7
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Planning targeted function body patches**

I'm deciding to replace entire function bodies by crafting precise patches that start at the function declaration and extend through its end, applying them one by one for each affected function.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -385,2 +385,3 @@
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
@@ -390,31 +391,32 @@
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..4c281b70b84f2fc282ccc42b4142744b49a8fcf5
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..4c281b70b84f2fc282ccc42b4142744b49a8fcf5
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Planning full function replacement**

I'm preparing to replace the entire function body with a patch similar to the one applied for resid.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -450,2 +450,3 @@
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
@@ -456,36 +457,29 @@
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
@@ -493,12 +487,5 @@
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..ed35fb33e17f1405df6812179d7cca983c7caa60
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..ed35fb33e17f1405df6812179d7cca983c7caa60
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Applying patch to function body**

I'm planning to patch the function body starting from its declarations through to the end of the free section using an existing patch application method.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -512,9 +512,6 @@
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
@@ -539,34 +536,35 @@
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
@@ -574,3 +572,2 @@
   }
-  }
   if (timeron) timer_stop(T_rprj3);
@@ -590,9 +587,4 @@
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..9bda4f880f8abf2a431f69aade35f6108ee0de79
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,41 +534,41 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
-  }
   }
   if (timeron) timer_stop(T_rprj3);
 
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..9bda4f880f8abf2a431f69aade35f6108ee0de79
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,41 +534,41 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
-  }
   }
   if (timeron) timer_stop(T_rprj3);
 
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Preparing to patch large function**
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -598,15 +598,7 @@
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
@@ -614,2 +606,3 @@
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
@@ -618,2 +611,3 @@
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
@@ -621,3 +615,2 @@
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
@@ -633,2 +626,3 @@
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
@@ -646,2 +640,3 @@
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
@@ -658,2 +653,3 @@
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
@@ -671,2 +667,3 @@
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
@@ -708,2 +705,3 @@
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
@@ -718,2 +716,3 @@
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
@@ -729,2 +728,3 @@
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
@@ -740,2 +740,3 @@
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
@@ -754,2 +755,3 @@
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
@@ -765,2 +767,3 @@
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
@@ -778,2 +781,3 @@
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
@@ -791,2 +795,3 @@
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
@@ -810,13 +815,7 @@
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
apply_patch(auto_approved=true) exited 0 in 18ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..461f531a25a22222e8b829a049f58142b08f836a
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,41 +534,41 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
-  }
   }
   if (timeron) timer_stop(T_rprj3);
 
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..461f531a25a22222e8b829a049f58142b08f836a
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,41 +534,41 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
-  }
   }
   if (timeron) timer_stop(T_rprj3);
 
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Identifying norm2u3 patch location**

The norm2u3 patch needs to be applied earlier at around line 900, focusing on the loop portions for targeted changes.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -851,13 +851,15 @@
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
@@ -865,16 +867,2 @@
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
apply_patch(auto_approved=true) exited 0 in 18ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..353c0c016a5cc2d6600ed8ba2411260bf46941af
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..353c0c016a5cc2d6600ed8ba2411260bf46941af
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Applying comm3 patch**
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -884,4 +884,5 @@
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
@@ -894,2 +895,3 @@
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
@@ -902,2 +904,3 @@
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
@@ -909,3 +912,2 @@
   }
-  } 
   if (timeron) timer_stop(T_comm3);
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..30d382dee259e1a10655d65601117a6242de06c9
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,41 +534,41 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
-  }
   }
   if (timeron) timer_stop(T_rprj3);
 
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..30d382dee259e1a10655d65601117a6242de06c9
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,41 +534,41 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
-  }
   }
   if (timeron) timer_stop(T_rprj3);
 
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Applying patch**
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -1215,4 +1215,5 @@
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
@@ -1220,4 +1221,3 @@
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
@@ -1225,3 +1225,2 @@
   }
-}
 }
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..1b6fbc64fd48803403a923cacadf224689c1c2b7
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..1b6fbc64fd48803403a923cacadf224689c1c2b7
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Reviewing and correcting OpenMP map clauses**

I'm clarifying that `map(present,alloc:...)` is invalid and deciding to replace such clauses with `map(present:...)` alone since `alloc` isn't recognized there and the data region already ensures presence. I'll search all occurrences to fix this accordingly.
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && rg "present,alloc" mg.c' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 32ms:
    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total])
    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total],os[0:coarse_total])
    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..1b6fbc64fd48803403a923cacadf224689c1c2b7
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present,alloc:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present,alloc:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present,alloc:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present,alloc:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Choosing Python for string replacement**

Decided to use a simple Python script to replace all occurrences of `map(present,alloc:` with `map(present:` across the file, as it's safer and lighter than heavy tools and fits the intended simple patch.
exec
/bin/bash -lc "cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && python - <<'PY'
from pathlib import Path
path = Path('mg.c')
data = path.read_text()
data = data.replace('map(present,alloc:', 'map(present:')
path.write_text(data)
PY" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 35ms:

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..d3b44c9beb77214c88d17464d0d4a99404675f53
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Checking map usage occurrences**
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && rg "present,alloc" mg.c' in /root/codex_baseline/serial_omp_nas_workdir exited 1 in 14ms:

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..d3b44c9beb77214c88d17464d0d4a99404675f53
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Reviewing memory mapping and data synchronization**

I'm verifying that maps use size_t consistently, device and host data are correctly allocated and synchronized around key functions, and that data updates happen in proper sequence. Also confirming OpenMP headers are included, no OpenACC leftovers remain, and memory mappings align with is_device_ptr usage in loops.
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && rg "acc_malloc|acc_free" mg.c' in /root/codex_baseline/serial_omp_nas_workdir exited 1 in 22ms:

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..d3b44c9beb77214c88d17464d0d4a99404675f53
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(u[0:NR], v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Correcting target update data transfers**

The host array `u` remains uninitialized since zero3 only zeros device data, so updating `u` from host overwrites device zeros with garbage. To fix this, I'll remove `u` from the target update clauses targeting device after zero3 and zran3, limiting updates to `v` (and possibly `r`), preventing overwrite of zeroed device data.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -163,3 +163,3 @@
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
-  #pragma omp target update to(u[0:NR], v[0:NR])
+  #pragma omp target update to(v[0:NR])
 
@@ -181,3 +181,3 @@
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
-  #pragma omp target update to(u[0:NR], v[0:NR])
+  #pragma omp target update to(v[0:NR])
 
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..fdae0c621b43218283274c1ee55a4224333af814
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..fdae0c621b43218283274c1ee55a4224333af814
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Analyzing OpenMP pointer presence and mapping issues**

The current mapping uses base pointers for entire arrays, but subarray pointers like `&r[ir[k]]` might not satisfy `map(present)` since they don't match the base pointer exactly, risking runtime errors. Considering using `is_device_ptr` to rely on pointer association instead of strict `map(present)` checks.

thinking
**Analyzing OpenMP pointer mapping nuances**

I'm clarifying that using derived device pointers in map clauses requires mapping their base pointers properly, ensuring `map(present:)` uses the base pointer name as in the initial mapping. The runtime checks presence by address inside the mapped region, so pointers like `orr = &r[ir[k]]` should work if `r` is mapped. Next, I'll confirm mappings for all arrays and update the plan statuses accordingly.
Plan update
  ✓ Analyze mg.c loops and globals; design target data scope and device helpers.
  ✓ Add OpenMP target data management and declare-target globals/functions.
  ✓ Parallelize kernels (resid, psinv, rprj3, interp, comm3, zero3, norm2u3) with target teams loops and device scratch allocation.
  • Build and run GPU target baseline (CLASS A or S) and verify output.
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..fdae0c621b43218283274c1ee55a4224333af814
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Preparing build and run commands**

Planning to run `make clean`, then build class B with `CC=nvc++ CLASS=B`, and finally run class A with mandatory target offload set; this follows step 5 instructions closely from the mg-omp directory.
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && make clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 39ms:
rm -f *.o *~ ../common/*.o *.w2c.c *.w2c.h *.i *.B *.t *.w2c.cu *.w2c.ptx *.spin *.s *.x
rm -f npbparams.h core
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..fdae0c621b43218283274c1ee55a4224333af814
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Confirming build steps**

I'm verifying that rebuilding npbparams requires running make with the compiler set to nvc++ and the CLASS variable set to B.
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && make CC=nvc++ CLASS=B' in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 5.08s:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams mg B && mv npbparams.h ..
nvc++  -c -Icommon -O3 -mp=gpu -gpu=ccall -Minfo=accel -mcmodel=medium mg.c
"mg.c", line 75: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_init] = "init";
                      ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"mg.c", line 76: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_bench] = "benchmk";
                       ^

"mg.c", line 77: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_mg3P] = "mg3P";
                      ^

"mg.c", line 78: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_psinv] = "psinv";
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..fdae0c621b43218283274c1ee55a4224333af814
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Running class A with OMP_TARGET_OFFLOAD**

I'm preparing to run class A using the environment variable OMP_TARGET_OFFLOAD=MANDATORY with a 300-second timeout on the make run command, ensuring the output file is generated.
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make CC=nvc++ CLASS=A run > gpu_output.txt 2>&1' in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp exited 2 in 1.33s:

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..fdae0c621b43218283274c1ee55a4224333af814
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Checking GPU output for errors**
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && tail -n 40 gpu_output.txt' in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 21ms:
nvc++ -O3 -mp=gpu -gpu=ccall -Minfo=accel -mcmodel=medium -o .//mg.A.x mg.o common/print_results.o common/c_timers.o common/wtime.o -lm
././/mg.A.x 
Failing in Thread:1
Accelerator Fatal Error: call to cuStreamSynchronize returned error 700 (CUDA_ERROR_ILLEGAL_ADDRESS): Illegal address during kernel execution
 File: /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
 Function: _ZN20_INTERNAL_4_mg_c_gnr5residEPdS0_S0_iiiS0_i:445
 Line: 476



 NAS Parallel Benchmarks (NPB3.3-ACC-C) - MG Benchmark

 No input file. Using compiled defaults 
 Size:  256x 256x 256  (class B)
 Iterations:  20

make: *** [Makefile:32: run] Error 1
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..fdae0c621b43218283274c1ee55a4224333af814
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Identifying illegal address cause in mapping**

The illegal address likely arises from using `is_device_ptr` on pointers mapped with `map(alloc)`, which remain host pointers, causing device access errors. Removing `is_device_ptr` and relying solely on `map(present: ...)` for mapped pointers should fix the mismatch and avoid illegal device addresses.

thinking
**Revising OpenMP loops for device pointers**

I'm planning to remove `is_device_ptr` conditions and switch to `map(present:...)` clauses with `#pragma omp target teams loop collapse(3)` in the psinv, resid, rprj3, and interp loops to simplify mapping and ensure proper device data usage. Next, I'll gradually patch these loops starting around line 380 in psinv.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -397,3 +397,3 @@
   {
-    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
     for (i3 = 1; i3 < n3-1; i3++) {
@@ -408,3 +408,3 @@
     }
-    #pragma omp target teams loop collapse(3) is_device_ptr(r1,r2) map(present:orr[0:total],ou[0:total])
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
     for (i3 = 1; i3 < n3-1; i3++) {
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..dbbd63bc14f5cab13626ac979d92e94a4c13582b
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..dbbd63bc14f5cab13626ac979d92e94a4c13582b
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Noting need for similar resid loops**
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..dbbd63bc14f5cab13626ac979d92e94a4c13582b
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Checking if map clause changed**
exec
/bin/bash -lc "cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && sed -n '430,520p' mg.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 12ms:
  comm3(ou, n1, n2, n3, k);

  if (debug_vec[0] >= 1) {
    
    rep_nrm(ou, n1, n2, n3, "   psinv", k);
  }

  if (debug_vec[3] >= k) {
    
    showall(ou, n1, n2, n3);
  }
}

static void resid(double * ou, double * ov, double * orr, int n1, int n2, int n3,
                  double a[4], int k)
{

  int i3, i2, i1;
  double a0, a2, a3;
  
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..dbbd63bc14f5cab13626ac979d92e94a4c13582b
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Adjusting loop pragmas with patch**
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -462,3 +462,3 @@
   {
-    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
     for (i3 = 1; i3 < n3-1; i3++) {
@@ -474,3 +474,3 @@
 
-    #pragma omp target teams loop collapse(3) is_device_ptr(u1,u2) map(present:ou[0:total],ov[0:total],orr[0:total])
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
     for (i3 = 1; i3 < n3-1; i3++) {
apply_patch(auto_approved=true) exited 0 in 4ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..6f4133a4867fccb628725f3569c7b384c9ab202d
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..6f4133a4867fccb628725f3569c7b384c9ab202d
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Checking removal of is_device_ptr in loops**
exec
/bin/bash -lc "cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && sed -n '520,640p' mg.c" in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 11ms:
    d1 = 2;
  } else {
    d1 = 1;
  }

  if (m2k == 3) {
    d2 = 2;
  } else {
    d2 = 1;
  }

  if (m3k == 3) {
    d3 = 2;
  } else {
    d3 = 1;
  }

  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
  {
    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..6f4133a4867fccb628725f3569c7b384c9ab202d
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Planning bulk removal of is_device_ptr clauses**

The plan is to script wide replacements removing `is_device_ptr` clauses in omp pragmas and extend the `map(present: ...)` lists to include the relevant variables (like z1, z2, z3). This involves pattern-based Python replacements for repeated pragma lines to keep mapping consistent and ensure compilation correctness.

thinking
**Planning bulk pattern replacement**

I'm preparing to run a Python script to replace multiple similar map patterns involving z1/2/3, handling potential spaces and line breaks in the source strings.
exec
/bin/bash -lc "cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && python - <<'PY'
from pathlib import Path
path=Path('mg.c')
data=path.read_text()
replacements={
\"#pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total])\":\"#pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],x1[0:fine_total],y1[0:fine_total])\",
\"#pragma omp target teams loop collapse(3) is_device_ptr(x1,y1) map(present:orr[0:fine_total],os[0:coarse_total])\":\"#pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],os[0:coarse_total],x1[0:fine_total],y1[0:fine_total])\",
\"#pragma omp target teams loop collapse(3) is_device_ptr(z1,z2,z3) map(present:oz[0:fine_total],ou[0:coarse_total])\":\"#pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])\",
}
for old,new in replacements.items():
    data=data.replace(old,new)
path.write_text(data)
PY" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 47ms:

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..100e4cfe03dc3ee845846899ef14f0b54217af37
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],os[0:coarse_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Checking remaining device pointer usage**

Planning to search for all occurrences of device pointer variables like is_device_ptr and possibly u1 to ensure nothing is missed.
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && rg "is_device_ptr" mg.c' in /root/codex_baseline/serial_omp_nas_workdir exited 1 in 20ms:

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..100e4cfe03dc3ee845846899ef14f0b54217af37
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],os[0:coarse_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Verifying and rebuilding after parameter changes**

I'm confirming the loop mapping and that the data maps correctly for the updated npbparams B, then running make clean before rebuilding with the updated compile instructions to ensure changes take effect.
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && make clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 30ms:
rm -f *.o *~ ../common/*.o *.w2c.c *.w2c.h *.i *.B *.t *.w2c.cu *.w2c.ptx *.spin *.s *.x
rm -f npbparams.h core
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..100e4cfe03dc3ee845846899ef14f0b54217af37
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],os[0:coarse_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Rebuilding class B**
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && make CC=nvc++ CLASS=B' in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 5.12s:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams mg B && mv npbparams.h ..
nvc++  -c -Icommon -O3 -mp=gpu -gpu=ccall -Minfo=accel -mcmodel=medium mg.c
"mg.c", line 75: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_init] = "init";
                      ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"mg.c", line 76: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_bench] = "benchmk";
                       ^

"mg.c", line 77: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_mg3P] = "mg3P";
                      ^

"mg.c", line 78: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_psinv] = "psinv";
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..100e4cfe03dc3ee845846899ef14f0b54217af37
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],os[0:coarse_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Identifying missing device pointer logic**

Noticed the absence of device pointer checks, so I'll rerun class A to verify and map missing elements correctly.
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make CC=nvc++ CLASS=A run > gpu_output.txt 2>&1' in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 2.67s:

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..100e4cfe03dc3ee845846899ef14f0b54217af37
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],os[0:coarse_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Requesting grep verification**
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && grep -E "Verification|SUCCESSFUL|FAILED" gpu_output.txt' in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 11ms:
 VERIFICATION SUCCESSFUL
 Verification    =               SUCCESSFUL
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..100e4cfe03dc3ee845846899ef14f0b54217af37
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],os[0:coarse_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Preparing to diff baseline and GPU outputs**
exec
/bin/bash -lc 'cd /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp && diff -u baseline_output.txt gpu_output.txt | head' in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp succeeded in 25ms:
--- baseline_output.txt	2025-12-07 18:30:20.414980459 +0200
+++ gpu_output.txt	2025-12-07 18:42:34.689634568 +0200
@@ -1,133 +1,3 @@
-make.def modified. Rebuilding npbparams.h just in case
-rm -f npbparams.h sys/npbparams.h
-cd sys && ./setparams mg A && mv npbparams.h ..
-nvc++  -c -Icommon -O3 -mp=gpu -gpu=ccall -Minfo=accel -mcmodel=medium mg.c
-"mg.c", line 74: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
-      t_names[T_init] = "init";
-                      ^
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..100e4cfe03dc3ee845846899ef14f0b54217af37
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],os[0:coarse_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Updating plan after final step**
Plan update
  ✓ Analyze mg.c loops and globals; design target data scope and device helpers.
  ✓ Add OpenMP target data management and declare-target globals/functions.
  ✓ Parallelize kernels (resid, psinv, rprj3, interp, comm3, zero3, norm2u3) with target teams loops and device scratch allocation.
  ✓ Build and run GPU target baseline (CLASS A or S) and verify output.
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..100e4cfe03dc3ee845846899ef14f0b54217af37
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],os[0:coarse_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.


thinking
**Summarizing final implementation and testing**

The code now includes persistent target data with explicit enter/exit mappings, GPU offload loops using target teams, and scratch map allocations adhering to the OMP_TARGET directives. Testing involved building with `make CC=nvc++ CLASS=B` and running with `make run class=A` under `OMP_TARGET_OFFLOAD=MANDATORY`. Warnings persist during build and runtime but aren't critical, and GPU stream synchronizations are stable.

Verification against baseline outputs (referencing `baseline_output` and `gpu_output`) confirmed correctness despite added data transfers from value updates. Key files involved were `mg.c` and documentation in `data_plan.md`.

**Summary of key points:**
- Added persistent target data management with explicit mappings
- Implemented GPU offload loops using target teams and scratch memory
- Maintained compliance with OMP_TARGET offload requirements
- Completed tests with expected environment variables and build commands
- Verified output integrity against baseline despite warnings and extra data transfers

Next steps could involve profiling with device strategy B as per step 8 instructions to optimize performance further.
codex
Added persistent GPU data management (target enter/exit data) in `mg.c` and synchronized host init with `target update` for the RNG-generated RHS. Offloaded multigrid kernels (`resid`, `psinv`, `rprj3`, `interp`, `norm2u3`, `comm3`, `zero3`) with `target data` scratch allocations and `target teams loop` stencils, keeping all iterative work on the RTX 4060 device under `OMP_TARGET_OFFLOAD=MANDATORY`.

Tests (in `data/src/mg-omp`):
- `make clean`
- `make CC=nvc++ CLASS=B`
- `timeout 300 env OMP_TARGET_OFFLOAD=MANDATORY make CC=nvc++ CLASS=A run > gpu_output.txt 2>&1`

Verification in `gpu_output.txt`: `VERIFICATION SUCCESSFUL` (matches baseline).
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..100e4cfe03dc3ee845846899ef14f0b54217af37
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,10 +155,13 @@
   lb = 1;
   k  = lt;
 
+  #pragma omp target enter data map(alloc: u[0:NR], v[0:NR], r[0:NR])
+
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 
@@ -175,6 +179,7 @@
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
   zran3(v, n1, n2, n3, nx[lt], ny[lt], k);
+  #pragma omp target update to(v[0:NR])
 
   timer_stop(T_init);
   tinit = timer_read(T_init);
@@ -203,6 +208,7 @@
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
   timer_stop(T_bench);
+  #pragma omp target exit data map(from:u[0:NR], r[0:NR]) map(delete:v[0:NR])
 
   t = timer_read(T_bench);
 
@@ -377,40 +383,42 @@
   double c0, c1, c2;
 
   double * __restrict__ r1, * __restrict__ r2;
+  size_t total = (size_t)n3*n2*n1;
 
   c0 = c[0];
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+r1 = (double*)malloc(total*sizeof(double));
+r2 = (double*)malloc(total*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
-               + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
-        I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
-               + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
+  #pragma omp target data map(present: orr[0:total], ou[0:total]) map(alloc: r1[0:total], r2[0:total])
+  {
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
+                 + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
+          I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
+                 + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
-                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
-                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
-                                             + I3D(orr, n1, n2, i3, i2, i1+1)
-											 + I3D(r1, n1, n2, i3, i2, i1) )
-									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
-									         + I3D(r1, n1, n2, i3, i2, i1-1)
-											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
+    #pragma omp target teams loop collapse(3) map(present:orr[0:total],ou[0:total],r1[0:total],r2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
+                                      + c0 * I3D(orr, n1, n2, i3, i2, i1)
+                                      + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
+                                               + I3D(orr, n1, n2, i3, i2, i1+1)
+                                               + I3D(r1, n1, n2, i3, i2, i1) )
+                                      + c2 * ( I3D(r2, n1, n2, i3, i2, i1)
+                                               + I3D(r1, n1, n2, i3, i2, i1-1)
+                                               + I3D(r1, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
@@ -440,59 +448,46 @@
   double a0, a2, a3;
   
   double * __restrict__ u1, * __restrict__ u2;
+  size_t total = (size_t)n3*n2*n1;
 
   a0 = a[0];
   a2 = a[2];
   a3 = a[3];
 
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  u1 = (double*)malloc(total*sizeof(double));
+  u2 = (double*)malloc(total*sizeof(double));
 
+  #pragma omp target data map(present: ou[0:total], ov[0:total], orr[0:total]) map(alloc: u1[0:total], u2[0:total])
   {
-{ 
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 0; i1 < n1; i1++) {
-	  
-        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
-               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
-        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
-               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 0; i1 < n1; i1++) {
+          I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
+                 + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
+          I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
+                 + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
+        }
       }
     }
-  }
-}
-{
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-	  
-        I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
-							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
-						 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
-									+ I3D(u1, n1, n2, i3, i2, i1+1))
-						 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+    #pragma omp target teams loop collapse(3) map(present:ou[0:total],ov[0:total],orr[0:total],u1[0:total],u2[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
+                 -a0 * I3D(ou, n1, n2, i3, i2, i1)
+                 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
+                            + I3D(u1, n1, n2, i3, i2, i1+1))
+                 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
+        }
       }
     }
   }
-  } 
-  } 
 
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +510,10 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)m3k*m2k*m1k;
+  size_t coarse_total = (size_t)m3j*m2j*m1j;
+  x1 = (double*)malloc(fine_total*sizeof(double));
+  y1 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,42 +534,42 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present: orr[0:fine_total], os[0:coarse_total]) map(alloc: x1[0:fine_total], y1[0:fine_total])
   {
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j; j1++) {
-        i1 = 2*j1-d1;
-		
-        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
-        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
-               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
-				
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j; j1++) {
+          i1 = 2*j1-d1;
+          I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
+          I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
+                 + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
+        }
       }
     }
-  }
-  for (j3 = 1; j3 < m3j-1; j3++) {
-    i3 = 2*j3-d3;
-    for (j2 = 1; j2 < m2j-1; j2++) {
-      i2 = 2*j2-d2;
-      for (j1 = 1; j1 < m1j-1; j1++) {
-        i1 = 2*j1-d1;
-		
-        y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
-        x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
-           + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
-        I3D(os, m1j, m2j, j3, j2, j1) = 
-                0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
-              + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
-              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
-              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+    #pragma omp target teams loop collapse(3) map(present:orr[0:fine_total],os[0:coarse_total],x1[0:fine_total],y1[0:fine_total])
+    for (j3 = 1; j3 < m3j-1; j3++) {
+      i3 = 2*j3-d3;
+      for (j2 = 1; j2 < m2j-1; j2++) {
+        i2 = 2*j2-d2;
+        for (j1 = 1; j1 < m1j-1; j1++) {
+          i1 = 2*j1-d1;
+          y2 = I3D(orr, m1k, m2k, i3, i2, i1+1)   + I3D(orr, m1k, m2k, i3+2, i2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+2, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1+1);
+          x2 = I3D(orr, m1k, m2k, i3+1, i2, i1+1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1+1)
+             + I3D(orr, m1k, m2k, i3, i2+1, i1+1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1+1);
+          I3D(os, m1j, m2j, j3, j2, j1) = 
+                  0.5 * I3D(orr, m1k, m2k, i3+1, i2+1, i1+1)
+                + 0.25 * (I3D(orr, m1k, m2k, i3+1, i2+1, i1) + I3D(orr, m1k, m2k, i3+1, i2+1, i1+2) + x2)
+                + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
+                + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
+        }
       }
     }
   }
-  }
   if (timeron) timer_stop(T_rprj3);
 
   j = k-1;
@@ -593,13 +585,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -609,30 +596,23 @@
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
   static double *z1, *z2, *z3;
-
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  size_t fine_total = (size_t)mm3*mm2*mm1;
+  size_t coarse_total = (size_t)n3*n2*n1;
+  z1 = (double*)malloc(fine_total*sizeof(double));
+  z2 = (double*)malloc(fine_total*sizeof(double));
+  z3 = (double*)malloc(fine_total*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present: oz[0:fine_total], ou[0:coarse_total]) map(alloc: z1[0:fine_total], z2[0:fine_total], z3[0:fine_total])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
-		
           I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
 		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
 		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
@@ -644,6 +624,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +638,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +651,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +665,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +703,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +714,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +726,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +738,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +753,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +779,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +793,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:oz[0:fine_total],ou[0:coarse_total],z1[0:fine_total],z2[0:fine_total],z3[0:fine_total])
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -821,17 +813,11 @@
     }
 
   }
-   }
+  }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -863,34 +849,22 @@
 
   s = 0.0;
   *rnmu = 0.0;
-  temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
+  temp = 0.0;
+  {
+    size_t total = (size_t)n3*n2*n1;
+    #pragma omp target teams loop collapse(3) reduction(+:s) reduction(max:temp) map(present: orr[0:total])
+    for (i3 = 1; i3 < n3-1; i3++) {
+      for (i2 = 1; i2 < n2-1; i2++) {
+        for (i1 = 1; i1 < n1-1; i1++) {
+          double val = I3D(orr, n1, n2, i3, i2, i1);
+          s = s + val * val;
+          a = fabs(val);
+          
+          temp = max(temp, a);
+        }
       }
     }
   }
-#else
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -908,8 +882,9 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +893,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +902,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present: ou[0:total])
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +910,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1237,15 +1213,14 @@
 {
 
   int i1, i2, i3;
+  size_t total = (size_t)n3*n2*n1;
 
-{
+  #pragma omp target teams loop collapse(3) map(present: oz[0:total])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }
diff --git a/serial_omp_nas_workdir/data_plan.md b/serial_omp_nas_workdir/data_plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..2db0235a858488c4d00505163639972fc1b54301
--- /dev/null
+++ b/serial_omp_nas_workdir/data_plan.md
@@ -0,0 +1,66 @@
+# Data Management Plan
+
+## Arrays Inventory
+List ALL arrays used in timed region:
+
+| Array Name | Size | Type | Init | Access |
+|------------|------|------|------|--------|
+| u[NR] | ~19.7M doubles (~158 MB) | working solution | host then device | R/W |
+| v[NR] | ~19.7M doubles (~158 MB) | const RHS | host then device | RO |
+| r[NR] | ~19.7M doubles (~158 MB) | working residual | host then device | R/W |
+| r1/r2 (psinv scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| u1/u2 (resid scratch) | n1\*n2\*n3 doubles per level | scratch | device | R/W |
+| x1/y1 (rprj3 scratch) | m1k\*m2k\*m3k doubles per level | scratch | device | R/W |
+| z1/z2/z3 (interp scratch) | mm1\*mm2\*mm3 doubles per level | scratch | device | R/W |
+
+## Functions in Timed Region
+| Function | Arrays Accessed | Frequency | Must Run On |
+|----------|----------------|-----------|-------------|
+| resid | u, v, r, scratch u1/u2 | per-iteration (multiple levels) | device |
+| mg3P (driver) | u, v, r | per-iteration | device |
+| rprj3 | r (fine), r (coarse), scratch x1/y1 | per-level inside mg3P | device |
+| psinv | r, u, scratch r1/r2 | per-level inside mg3P | device |
+| interp | u (coarse), u (fine), scratch z1/z2/z3 | per-level inside mg3P | device |
+| zero3 | u slices | per-level inside mg3P | device |
+| comm3 | boundary of u/r | per-call inside mg3P/resid | device |
+| norm2u3 | r | once before loop + once after loop | device |
+
+## Data Movement Strategy
+
+**Chosen Strategy:** A
+
+**Device Allocations (once):**
+```
+target data region holding u[0:NR], v[0:NR], r[0:NR]
+Scratch arrays per kernel via map(alloc:) inside each routine
+```
+
+**Host→Device Transfers:**
+- When: enter benchmark region before first resid in timed loop
+- Arrays: u (tofrom, ~158 MB), v (to, ~158 MB), r (tofrom, ~158 MB)
+- Total H→D: ~474 MB
+
+**Device→Host Transfers:**
+- When: exit benchmark target data after iterations
+- Arrays: u (final solution, ~158 MB), r (residual, ~158 MB)
+- Total D→H: ~316 MB
+
+**Transfers During Iterations:** NO
+- All working and scratch data stay on device for duration of timed loop.
+
+## Critical Checks (for chosen strategy)
+
+**Strategy A:**
+- [ ] Functions inside target data use `present` wrappers
+- [ ] Scratch arrays use enter/exit data OR device alloc
+
+## Common Mistakes:
+-  Some functions on device, others on host (causes copying)
+-  Scratch as host arrays in Strategy C
+-  Forgetting to offload ALL functions in loop
+
+## Expected Transfer Volume
+- Total: ~790 MB for entire execution
+- **Red flag:** If actual >2x expected → data management wrong
+
+**Summary:** 3 arrays (2 working, 1 const), 4 scratch groups, 8 functions, Strategy A. Expected: ~474 MB H→D, ~316 MB D→H.

tokens used
424,185