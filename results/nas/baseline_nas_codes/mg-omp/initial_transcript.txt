Added OpenMP GPU offload across MG kernels: introduced target data mapping for `u/v/r`, offloaded all heavy 3D loops with `target teams loop`, and replaced temporary buffer handling with device-mapped allocations for psinv, resid, rprj3, and interp. Boundary exchange, zeroing, and norm calculations now run on the GPU, with host/device synchronization handled via OpenMP directives. Initialization and execution stay within a single target data region for reduced transfers.

Key file: `data/src/mg-omp/mg.c`

Commands run:
- `make clean`
- `make CC=nvc++ CLASS=A`
- `./mg.A.x` (passes verification, Class A)

Warnings are from legacy string literals and unused locals; runtime completes and verifies successfully.

OpenAI Codex v0.65.0 (research preview)
--------
workdir: /root/codex_baseline/serial_omp_nas_workdir
model: gpt-5.1-codex-max
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: low
reasoning summaries: auto
session id: 019af9fa-da9e-7950-9625-2c0f3f8df000
--------
user
## First Step: Copy Source Files
Copy source files - mg.c from /root/codex_baseline/serial_omp_nas_workdir/golden_labels/src/mg-serial to /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp.

**Files:** - mg.c

**Your Task:**
1. Translate the code below to an OpenMP GPU-offloaded version.
2. Apply GPU offloading pragmas as needed. (`use teams loop` and not `teams distribute parallel for`)
3. Optimize the code for performance while preserving its original functionality.
4. make sure the code compiles with `make CC=nvc++ CLASS=A`, and runs with ./<executable
5. Deliver the modified code to /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp.

**Deliverable:**
- The complete, modified source code for - mg.c in /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp, that can be compiled with `make CC=nvc++ CLASS=A` and runs with `./<executable>`.

** Rules **
- NO GIT COMMANDS.
- DO NOT READ/WRITE OUTSIDE THE WORKING DIRECTORY.
- ALWAYS CLEAN BEFORE BUILD.

mcp startup: no servers

thinking
**Copying source file from golden**
exec
/bin/bash -lc ls in /root/codex_baseline/serial_omp_nas_workdir succeeded in 8ms:
AGENTS.md
data
data_plan.md
gate_sdk
golden_labels
npb3.3.1.tar.gz
system_info.txt
test_all_nas_kernels.sh

thinking
**Confirming system_info read**
exec
/bin/bash -lc 'cat system_info.txt' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 16ms:
=== SYSTEM BASELINE ===
Linux ErelPC 6.6.87.2-microsoft-standard-WSL2 #1 SMP PREEMPT_DYNAMIC Thu Jun  5 18:30:46 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux
PRETTY_NAME="Ubuntu 22.04.3 LTS"
NAME="Ubuntu"
VERSION_ID="22.04"
VERSION="22.04.3 LTS (Jammy Jellyfish)"
VERSION_CODENAME=jammy
ID=ubuntu
ID_LIKE=debian
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
UBUNTU_CODENAME=jammy
ldd (Ubuntu GLIBC 2.35-0ubuntu3.11) 2.35

=== FIRMWARE & MICROCODE ===
# dmidecode 3.3
Scanning /dev/mem for entry point.
# No SMBIOS nor DMI entry point found, sorry.

thinking
**Listing directories for copy preparation**
exec
/bin/bash -lc 'ls data/src' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 13ms:
bt-omp
cg-omp
ep-omp
ft-omp
lu-omp
mg-omp

thinking
**Locating source file for copying**

I'm locating the mg.c file in golden_labels/src/mg-serial to prepare for copying it.
exec
/bin/bash -lc 'ls golden_labels/src/mg-serial' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 8ms:
Makefile
README
common
common copy
config
globals.h
mg.c
mg.config
mg.llvm
sys

thinking
**Planning copy of mg.c to mg-omp**

Planning to copy mg.c into data/src/mg-omp with a note to always clean before building, ensuring the copy occurs first before other steps.
exec
/bin/bash -lc 'cp golden_labels/src/mg-serial/mg.c data/src/mg-omp/' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 8ms:


thinking
**Inspecting mg.c for OpenMP GPU offload**
exec
/bin/bash -lc "sed -n '1,200p' data/src/mg-omp/mg.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 12ms:

#ifdef __PGIC__
#undef __GNUC__
#else
#define num_workers(a)
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "globals.h"

#include "timers.h"
#include "print_results.h"

#define I3D(array,n1,n2,i3,i2,i1) (array[(i3)*n2*n1 + (i2)*n1 + (i1)])

static void setup(int *n1, int *n2, int *n3);
static void mg3P(double u[], double v[], double r[],

thinking
**Analyzing code for GPU offload**

I'm identifying static global arrays and existing parallelism, noting no current pragmas and a serial state, to prepare wrapping rest functions with target data and teams loops for GPU offload while ensuring correctness.
exec
/bin/bash -lc 'rg -n "#pragma" -n data/src/mg-omp/mg.c' in /root/codex_baseline/serial_omp_nas_workdir exited 1 in 21ms:


thinking
**Identifying need for pragmas**

I noticed no pragma directives are present and plan to add them after understanding the main loops by continuing to read further.
exec
/bin/bash -lc "sed -n '200,400p' data/src/mg-omp/mg.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 8ms:
    resid(u, v, r, n1, n2, n3, a, k);
  }

  norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
}
  timer_stop(T_bench);

  t = timer_read(T_bench);

  verified = false;
  verify_value = 0.0;

  printf("\n Benchmark completed\n");

  epsilon = 1.0e-8;
  if (Class != 'U') {
    if (Class == 'S') {
      verify_value = 0.5307707005734e-04;
    } else if (Class == 'W') {
      verify_value = 0.6467329375339e-05;
exec
/bin/bash -lc "sed -n '400,800p' data/src/mg-omp/mg.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 12ms:
  }
  for (i3 = 1; i3 < n3-1; i3++) {
    for (i2 = 1; i2 < n2-1; i2++) {
      for (i1 = 1; i1 < n1-1; i1++) {
	  
        I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                    + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                    + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
                                             + I3D(orr, n1, n2, i3, i2, i1+1)
											 + I3D(r1, n1, n2, i3, i2, i1) )
									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
									         + I3D(r1, n1, n2, i3, i2, i1-1)
											 + I3D(r1, n1, n2, i3, i2, i1+1));

      }
    }
  }
  if (timeron) timer_stop(T_psinv);

 free(r1);

thinking
**Planning OpenMP offload strategy**

I'm targeting key compute loops for OpenMP target teams loop offload with data mapping via target data regions around main iterative operations to minimize data movement. Temporary arrays allocated per function will be device-allocated using omp_target_alloc and accessed with is_device_ptr clauses to integrate smoothly with mapped base arrays.
exec
/bin/bash -lc "sed -n '800,1200p' data/src/mg-omp/mg.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 15ms:
					+ I3D(oz, mm1, mm2, i3-1, i2,   i1-1)
					+ I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
       }
     }
    for (i3 = 1; i3 <= mm3-1; i3++) {
      for (i2 = 1; i2 <= mm2-1; i2++) {
        for (i1 = 1; i1 <= mm1-1; i1++) {
		
		  I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-t2-1, 2*i1-t1-1) = 
		    I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-t2-1, 2*i1-t1-1)
			+ 0.125 * (I3D(oz, mm1, mm2, i3,   i2,   i1)
			         + I3D(oz, mm1, mm2, i3,   i2-1, i1)
					 + I3D(oz, mm1, mm2, i3,   i2,   i1-1)
					 + I3D(oz, mm1, mm2, i3,   i2-1, i1-1)
					 + I3D(oz, mm1, mm2, i3-1, i2,   i1)
					 + I3D(oz, mm1, mm2, i3-1, i2-1, i1)
					 + I3D(oz, mm1, mm2, i3-1, i2,   i1-1)
					 + I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }

thinking
**Planning OpenMP GPU offloading approach**

Analyzed major compute loops for GPU offloading with `#pragma omp target teams loop collapse`, deciding to wrap main computational phases inside an outer `target data` region for persistent data mapping and use `map(present:...)` inside functions for device pointers. Will keep complex host-only parts on host with explicit `target update` calls for correctness, convert simple init loops like zero3 to target offload, and remove manual host malloc/free in favor of OpenMP device allocation and map clauses. Next steps include adding omp.h, restructuring main with an outer target data region, and incrementally applying patches to the compute kernels accordingly.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -10,2 +10,3 @@
 #include <math.h>
+#include <omp.h>
 
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..46dc3113dc23f29a3eb5d34dac36a34059740c7e
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..46dc3113dc23f29a3eb5d34dac36a34059740c7e
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 


thinking
**Wrapping main with target data**

I'm adding target data around the computation block starting at `lb=1; k=lt;` by applying a patch to properly scope the changes.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -157,2 +157,3 @@
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
@@ -205,2 +206,3 @@
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..6bd44f02d34a9f3de67bf5582e4bde2cfa478749
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..6bd44f02d34a9f3de67bf5582e4bde2cfa478749
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);


thinking
**Planning target update integration**

I'm deciding to add the target update inside the zero3 function to ensure device modifications from the zran3 host are maintained and results properly reflected before exit. Next, I'll locate and modify zero3, likely near its existing prototype, to integrate this update.
exec
/bin/bash -lc 'rg -n "zero3" -n data/src/mg-omp/mg.c' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 22ms:
41:static void zero3(double *oz, int n1, int n2, int n3);
161:  zero3(u, n1, n2, n3);
178:  zero3(u, n1, n2, n3);
355:  zero3(&u[ir[k]], m1[k], m2[k], m3[k]);
361:    zero3(&u[ir[k]], m1[k], m2[k], m3[k]);
1018:  zero3(oz, n1, n2, n3);
1239:static void zero3(double *oz, int n1, int n2, int n3)
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..6bd44f02d34a9f3de67bf5582e4bde2cfa478749
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);

exec
/bin/bash -lc "sed -n '1230,1280p' data/src/mg-omp/mg.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 9ms:
        j3[i+1][ind] = j3[i][ind];
        j3[i][ind] = j_temp;
      } else {
        return;
      }
    }
  }
}

static void zero3(double *oz, int n1, int n2, int n3)
{

  int i1, i2, i3;

{
  for (i3 = 0; i3 < n3; i3++) {
    for (i2 = 0; i2 < n2; i2++) {
      for (i1 = 0; i1 < n1; i1++) {
   
   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..6bd44f02d34a9f3de67bf5582e4bde2cfa478749
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);


thinking
**Refactoring loop and cleanup**

I'm collapsing the target teams loop using map with the presence check and removing unnecessary braces for cleaner code.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -1243,3 +1243,3 @@
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
@@ -1247,4 +1247,3 @@
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
@@ -1252,3 +1251,2 @@
   }
-}
 }
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..42bc20a917b44d7dd9e71f81f8ed5af35eb838b4
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -1238,14 +1241,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..42bc20a917b44d7dd9e71f81f8ed5af35eb838b4
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -1238,14 +1241,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Modifying psinv to remove malloc and use target data loops**
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -387,6 +387,8 @@
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
@@ -394,3 +396,2 @@
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
@@ -399,3 +400,2 @@
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
@@ -403,2 +403,3 @@
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
@@ -406,3 +407,2 @@
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
@@ -415,3 +415,2 @@
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
@@ -419,6 +418,4 @@
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..a6d3b973b608ff8ebeeb72284dc62819f4b74fc3
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -1238,14 +1238,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..a6d3b973b608ff8ebeeb72284dc62819f4b74fc3
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -1238,14 +1238,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Refactoring memory management and data handling**

I'm replacing mallocs and accelerator memory with target data directives and ensuring that map clauses use len with size_t types correctly while firstprivate is acceptable for related variables.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -447,13 +447,8 @@
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
@@ -461,3 +456,2 @@
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
@@ -466,3 +460,2 @@
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
@@ -470,4 +463,3 @@
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
@@ -475,3 +467,2 @@
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
@@ -485,12 +476,3 @@
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..9362c897a179feea567724fd0faa25d6d759d2ac
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
+  size_t len = (size_t)n3*n2*n1;
+
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
-
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -1238,14 +1220,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..9362c897a179feea567724fd0faa25d6d759d2ac
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
+  size_t len = (size_t)n3*n2*n1;
+
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
-
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -1238,14 +1220,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Confirming map presence for pointers**

The mapping appears present for target data and for `orr` pointers by referencing mapped regions. This suggests the existing update logic for ensuring map presence should work, including for `rprj3` device data.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -499,9 +499,3 @@
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
@@ -526,3 +520,5 @@
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
@@ -542,2 +538,3 @@
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
@@ -577,9 +574,3 @@
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..59b4da7ce5f63f72d43f500249ebcffe003721e1
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +413,12 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -1238,14 +1211,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..59b4da7ce5f63f72d43f500249ebcffe003721e1
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +413,12 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -1238,14 +1211,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Refactoring memory handling in mapping function**

Planning to remove accelerator malloc usage by converting interpreterâ€™s large map expressions to the target data map with appropriate size handling.
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..59b4da7ce5f63f72d43f500249ebcffe003721e1
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +413,12 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -1238,14 +1211,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Splitting patch due to conflicts**

I'll break the patch into smaller chunks to avoid conflicts and start by replacing the allocation area near the beginning of the interpreter display section around line 640.
exec
/bin/bash -lc "sed -n '600,700p' data/src/mg-omp/mg.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 9ms:

  {

  if (n1 != 3 && n2 != 3 && n3 != 3) {

    for (i3 = 0; i3 < mm3-1; i3++) {
      for (i2 = 0; i2 < mm2-1; i2++) {
        for (i1 = 0; i1 < mm1; i1++) {
		
          I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
		  I3D(z3, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2+1, i1) 
		  								+ I3D(oz, mm1, mm2, i3+1, i2, i1)
										+ I3D(z1, mm1, mm2, i3, i2, i1);

        }
      }
    }
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..59b4da7ce5f63f72d43f500249ebcffe003721e1
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +413,12 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -1238,14 +1211,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Preparing to patch function start**

I'm focusing on updating the initial allocation part of the function by examining the top lines around its start before applying smaller patches.
exec
/bin/bash -lc "sed -n '560,620p' data/src/mg-omp/mg.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 8ms:
  if (timeron) timer_stop(T_rprj3);

  j = k-1;
  
  comm3(os, m1j, m2j, m3j, j);

  if (debug_vec[0] >= 1) {
    
    rep_nrm(os, m1j, m2j, m3j, "   rprj3", k-1);
  }

  if (debug_vec[4] >= k) {
    
    showall(os, m1j, m2j, m3j);
  }
  }
}

static void interp(double *oz, int mm1, int mm2, int mm3,
                   double *ou, int n1, int n2, int n3, int k)
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..59b4da7ce5f63f72d43f500249ebcffe003721e1
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +413,12 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -1238,14 +1211,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Planning full function replacement**

Deciding to replace the entire function with a new version allocating host arrays dynamically, mapping device data properly, and using OpenMP target teams loops with collapse(3). Next, I'll carefully craft a single update patch covering the full function definition.
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..59b4da7ce5f63f72d43f500249ebcffe003721e1
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +413,12 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -1238,14 +1211,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Planning function replacement via patch**

I'm preparing to replace the old function by applying a patch that deletes the old version and adds the new one, using context boundaries from the function signature start to before the next function, to ensure accurate placement.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -583,16 +583,8 @@
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
@@ -600,2 +592,3 @@
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
@@ -604,2 +597,3 @@
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
@@ -619,2 +613,3 @@
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
@@ -632,2 +627,3 @@
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
@@ -644,2 +640,3 @@
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
@@ -657,2 +654,3 @@
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
@@ -694,2 +692,3 @@
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
@@ -704,2 +703,3 @@
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
@@ -715,2 +715,3 @@
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
@@ -726,2 +727,3 @@
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
@@ -740,2 +742,3 @@
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
@@ -751,2 +754,3 @@
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
@@ -764,2 +768,3 @@
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
@@ -777,2 +782,3 @@
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
@@ -798,11 +804,5 @@
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..58d7bb02757b8a0f2f6d1023cbed34d67e6015ab
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +413,12 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +581,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +611,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +625,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +638,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +652,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +690,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +701,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +713,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +725,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +740,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +752,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +766,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +780,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +802,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -1238,14 +1211,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..58d7bb02757b8a0f2f6d1023cbed34d67e6015ab
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +413,12 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +581,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +611,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +625,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +638,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +652,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +690,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +701,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +713,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +725,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +740,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +752,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +766,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +780,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +802,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -1238,14 +1211,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Updating mapping and normalization logic**

Adjusting the OS mapping length calculation to align with expected dimensions and planning to update the normalization function for target reduction accordingly.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -839,16 +839,3 @@
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
@@ -864,4 +851,2 @@
   }
-#endif
-}
   *rnmu = temp;
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..dc7fd30febe58d369e1c9cf5b037bbda3e18a869
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +581,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +611,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +625,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +638,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +652,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +690,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +701,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +713,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +725,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +740,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +752,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +766,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +780,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +802,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +837,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +849,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -1238,14 +1196,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..dc7fd30febe58d369e1c9cf5b037bbda3e18a869
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +581,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +611,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +625,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +638,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +652,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +690,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +701,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +713,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +725,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +740,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +752,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +766,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +780,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +802,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +837,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +849,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -1238,14 +1196,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Committing changes**
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -869,3 +869,3 @@
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
@@ -878,2 +878,3 @@
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
@@ -886,2 +887,3 @@
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
@@ -893,3 +895,2 @@
   }
-  } 
   if (timeron) timer_stop(T_comm3);
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..e7501b4c3152e3fcf3c8aa30572ddef7588815ba
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +581,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +611,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +625,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +638,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +652,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +690,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +701,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +713,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +725,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +740,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +752,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +766,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +780,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +802,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +837,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +849,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +867,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +876,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +885,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +893,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1238,14 +1197,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..e7501b4c3152e3fcf3c8aa30572ddef7588815ba
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +581,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +611,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +625,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +638,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +652,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +690,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +701,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +713,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +725,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +740,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +752,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +766,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +780,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +802,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +837,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +849,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +867,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +876,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +885,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +893,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1238,14 +1197,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Planning device data update**

I see that host loops modify device data without updating it, causing potential inconsistencies in the device's memory before a function relying on mapped data is called. I'll add a device update pragma right after these loops and just before the call that uses the target-mapped data to ensure synchronization.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -1092,2 +1092,3 @@
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0a324f690dfce2acd8f7bf52976f22747a86b64c
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +581,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +611,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +625,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +638,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +652,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +690,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +701,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +713,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +725,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +740,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +752,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +766,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +780,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +802,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +837,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +849,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +867,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +876,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +885,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +893,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1090,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1198,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0a324f690dfce2acd8f7bf52976f22747a86b64c
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +581,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +611,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +625,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +638,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +652,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +690,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +701,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +713,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +725,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +740,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +752,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +766,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +780,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +802,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +837,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +849,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +867,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +876,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +885,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +893,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1090,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1198,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Clarifying map usage and OpenACC cleanup**

Confirmed the mapping for zero3 happens before its usage inside target data, aligning with current calls. Planning to ensure mg3P functions use correct mapped data and to remove any leftover or unused OpenACC macros after checking all occurrences.
exec
/bin/bash -lc 'rg -n "_OPENACC" data/src/mg-omp/mg.c' in /root/codex_baseline/serial_omp_nas_workdir exited 1 in 16ms:

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0a324f690dfce2acd8f7bf52976f22747a86b64c
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +581,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +611,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +625,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +638,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +652,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +690,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +701,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +713,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +725,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +740,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +752,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +766,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +780,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +802,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +837,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +849,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +867,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +876,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +885,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +893,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1090,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1198,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Verifying OpenMP target data mappings and build process**

I'm ensuring all `map(present)` clauses align with array usage, including size_t casting and pointer subrange coverage. Next, I'll run `make clean` and build with the specified Makefile to verify successful compilation.
exec
/bin/bash -lc 'cd data/src/mg-omp && make clean' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 16ms:
rm -f *.o *~ ../common/*.o *.w2c.c *.w2c.h *.i *.B *.t *.w2c.cu *.w2c.ptx *.spin *.s *.x
rm -f npbparams.h core
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0a324f690dfce2acd8f7bf52976f22747a86b64c
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +581,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +611,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +625,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +638,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +652,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +690,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +701,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +713,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +725,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +740,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +752,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +766,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +780,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +802,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +837,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +849,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +867,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +876,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +885,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +893,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1090,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1198,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Building with specified compiler and class**
exec
/bin/bash -lc 'cd data/src/mg-omp && make CC=nvc++ CLASS=A' in /root/codex_baseline/serial_omp_nas_workdir exited 2 in 941ms:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams mg A && mv npbparams.h ..
nvc++  -c -Icommon -O3 -mp=gpu -gpu=ccall -Minfo=accel -mcmodel=medium mg.c
"mg.c", line 75: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_init] = "init";
                      ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"mg.c", line 76: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_bench] = "benchmk";
                       ^

"mg.c", line 77: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_mg3P] = "mg3P";
                      ^

"mg.c", line 78: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_psinv] = "psinv";
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0a324f690dfce2acd8f7bf52976f22747a86b64c
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +581,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +611,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +625,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +638,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +652,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +690,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +701,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +713,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +725,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +740,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +752,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +766,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +780,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +802,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +837,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +849,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +867,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +876,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +885,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +893,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1090,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1198,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Investigating brace mismatch around rprj3**

I'm inspecting the mg.c file near lines 540-580 to verify if the patch removed essential closing braces or pragma blocks around rprj3, causing the compilation error.
exec
/bin/bash -lc "sed -n '520,640p' data/src/mg-omp/mg.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 17ms:

  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
  {
  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
  for (j3 = 1; j3 < m3j-1; j3++) {
    i3 = 2*j3-d3;
    for (j2 = 1; j2 < m2j-1; j2++) {
      i2 = 2*j2-d2;
      for (j1 = 1; j1 < m1j; j1++) {
        i1 = 2*j1-d1;
		
        I3D(x1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3+1, i2, i1) + I3D(orr, m1k, m2k, i3+1, i2+2, i1)
               + I3D(orr, m1k, m2k, i3, i2+1, i1) + I3D(orr, m1k, m2k, i3+2, i2+1, i1);
        I3D(y1, m1k, m2k, i3, i2, i1) = I3D(orr, m1k, m2k, i3, i2, i1)   + I3D(orr, m1k, m2k, i3+2, i2, i1)
               + I3D(orr, m1k, m2k, i3, i2+2, i1) + I3D(orr, m1k, m2k, i3+2, i2+2, i1);
				
      }
    }
  }
  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0a324f690dfce2acd8f7bf52976f22747a86b64c
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +581,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +611,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +625,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +638,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +652,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +690,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +701,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +713,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +725,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +740,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +752,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +766,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +780,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +802,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +837,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +849,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +867,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +876,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +885,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +893,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1090,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1198,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Identifying and removing extra closing brace**

Found an extra closing curly brace at the end of the function around line 576, likely leftover from earlier edits; removing it will fix balancing errors. Next, I'll check similar brace issues near line 770 in the interp section.
exec
/bin/bash -lc "sed -n '560,620p' data/src/mg-omp/mg.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 11ms:
  if (timeron) timer_stop(T_rprj3);

  j = k-1;
  
  comm3(os, m1j, m2j, m3j, j);

  if (debug_vec[0] >= 1) {
    
    rep_nrm(os, m1j, m2j, m3j, "   rprj3", k-1);
  }

  if (debug_vec[4] >= k) {
    
    showall(os, m1j, m2j, m3j);
  }
  }
}

static void interp(double *oz, int mm1, int mm2, int mm3,
                   double *ou, int n1, int n2, int n3, int k)
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0a324f690dfce2acd8f7bf52976f22747a86b64c
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,7 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  }
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +581,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +611,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +625,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +638,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +652,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +690,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +701,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +713,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +725,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +740,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +752,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +766,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +780,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +802,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +837,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +849,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +867,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +876,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +885,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +893,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1090,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1198,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Fixing syntax error by removing extra brace**
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -574,3 +574,2 @@
   }
-  }
 }
apply_patch(auto_approved=true) exited 0 in 4ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..da275e8119085e8ab62df35172ee81fe2f618766
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +580,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +610,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +624,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +637,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +651,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +689,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +700,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +712,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +724,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +739,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +751,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +779,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +801,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +836,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +848,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +866,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +875,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +884,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +892,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1089,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1197,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..da275e8119085e8ab62df35172ee81fe2f618766
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +580,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +610,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +624,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +637,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +651,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +689,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +700,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +712,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +724,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +739,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +751,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +779,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +801,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +836,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +848,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +866,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +875,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +884,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +892,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1089,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1197,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Verifying proper closure of braces**
exec
/bin/bash -lc "sed -n '760,840p' data/src/mg-omp/mg.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 26ms:
		    I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-d2-1, 2*i1-t1-1)
			+ 0.25 * (I3D(oz, mm1, mm2, i3,   i2-1, i1)
			        + I3D(oz, mm1, mm2, i3,   i2-1, i1-1)
					+ I3D(oz, mm1, mm2, i3-1, i2-1, i1)
					+ I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
      }
    }
    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
    for (i3 = 1; i3 <= mm3-1; i3++) {
      for (i2 = 1; i2 <= mm2-1; i2++) {
        for (i1 = d1; i1 <= mm1-1; i1++) {
		
		  I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-t2-1, 2*i1-d1-1) = 
		    I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-t2-1, 2*i1-d1-1)
			+ 0.25 * (I3D(oz, mm1, mm2, i3,   i2,   i1-1)
			        + I3D(oz, mm1, mm2, i3,   i2-1, i1-1)
					+ I3D(oz, mm1, mm2, i3-1, i2,   i1-1)
					+ I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..da275e8119085e8ab62df35172ee81fe2f618766
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +580,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +610,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +624,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +637,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +651,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +689,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +700,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +712,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +724,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +739,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +751,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +779,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +801,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +836,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +848,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +866,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +875,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +884,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +892,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1089,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1197,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Confirming correct brace closures and preparing clean rebuild**

The brace count after loops and if/else looks correct with two closing braces matching else and target data blocks. Compile errors likely stem from misplaced or improperly preceded pragmas and possibly leftover code near comm3. I'll ensure pragmas are properly placed without preceding blanks, fix braces if needed, and then run a clean rebuild.
exec
/bin/bash -lc 'cd data/src/mg-omp && make clean' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 17ms:
rm -f *.o *~ ../common/*.o *.w2c.c *.w2c.h *.i *.B *.t *.w2c.cu *.w2c.ptx *.spin *.s *.x
rm -f npbparams.h core
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..da275e8119085e8ab62df35172ee81fe2f618766
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +580,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +610,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +624,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +637,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +651,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +689,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +700,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +712,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +724,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +739,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +751,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +779,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +801,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +836,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +848,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +866,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +875,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +884,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +892,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1089,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1197,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

exec
/bin/bash -lc 'cd data/src/mg-omp && make CC=nvc++ CLASS=A' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 10.50s:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams mg A && mv npbparams.h ..
nvc++  -c -Icommon -O3 -mp=gpu -gpu=ccall -Minfo=accel -mcmodel=medium mg.c
"mg.c", line 75: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_init] = "init";
                      ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"mg.c", line 76: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_bench] = "benchmk";
                       ^

"mg.c", line 77: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_mg3P] = "mg3P";
                      ^

"mg.c", line 78: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_psinv] = "psinv";
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..da275e8119085e8ab62df35172ee81fe2f618766
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +580,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +610,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +624,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +637,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +651,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +689,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +700,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +712,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +724,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +739,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +751,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +779,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +801,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +836,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +848,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +866,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +875,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +884,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +892,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1089,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1197,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Confirming run of built executable**

Build succeeded with warnings; now planning to run the executable from the data/src/mg-omp directory to verify its runtime behavior.
exec
/bin/bash -lc 'cd data/src/mg-omp && ./mg.A.x' in /root/codex_baseline/serial_omp_nas_workdir exited -1 in 0ms:
execution error: Sandbox(Signal(11))
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..da275e8119085e8ab62df35172ee81fe2f618766
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +580,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +610,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +624,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +637,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +651,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +689,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +700,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +712,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +724,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +739,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +751,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +779,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +801,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +836,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +848,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +866,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +875,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +884,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +892,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1089,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1197,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Identifying probable segfault cause**

The segfault likely stems from a target update outside the active target data region, where the mapping is destroyed before the update from executes; moving the target update inside the target data block before its closing brace should resolve this.
exec
/bin/bash -lc "sed -n '130,230p' data/src/mg-omp/mg.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 11ms:
    Class = 'D';
  } else if ( nx[lt] == 2048 && nit == 50 ) {  
    Class = 'E';
  } else {
    Class = 'U';
  }

  a[0] = -8.0/3.0;
  a[1] =  0.0;
  a[2] =  1.0/6.0;
  a[3] =  1.0/12.0;
      
  if (Class == 'A' || Class == 'S' || Class =='W') {

    c[0] =  -3.0/8.0;
    c[1] =  +1.0/32.0;
    c[2] =  -1.0/64.0;
    c[3] =   0.0;
  } else {

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..da275e8119085e8ab62df35172ee81fe2f618766
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -202,6 +204,7 @@
 
   norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
 }
+#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
 
   t = timer_read(T_bench);
@@ -382,26 +385,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +413,11 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +445,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +474,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +497,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +518,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +536,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +572,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +580,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +610,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +624,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +637,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +651,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +689,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +700,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +712,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +724,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +739,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +751,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +765,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +779,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +801,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +836,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +848,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +866,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +875,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +884,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +892,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1089,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1197,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Removing unnecessary target update**

Decided to remove the explicit target update line since exit target data copies back automatically with the tofrom map, avoiding potential crashes from updating outside the target region.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -206,3 +206,2 @@
 }
-#pragma omp target update from(u[0:NR], v[0:NR], r[0:NR])
   timer_stop(T_bench);
apply_patch(auto_approved=true) exited 0 in 25ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0893daa14dc19fd56430275744099ec67ea38fe8
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +412,12 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +444,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +473,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +496,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +517,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +535,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +571,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +579,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +609,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +623,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +636,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +650,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +688,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +699,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +711,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +723,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +738,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +750,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +764,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +778,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +800,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +835,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +847,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +865,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +874,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +883,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +891,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1088,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1196,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0893daa14dc19fd56430275744099ec67ea38fe8
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +412,12 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +444,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +473,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +496,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +517,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +535,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +571,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +579,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +609,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +623,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +636,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +650,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +688,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +699,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +711,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +723,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +738,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +750,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +764,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +778,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +800,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +835,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +847,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +865,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +874,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +883,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +891,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1088,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1196,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Verifying segfault resolution**

I'm rerunning a clean build and run to confirm if the segfault issue has been resolved.
exec
/bin/bash -lc 'cd data/src/mg-omp && make clean' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 35ms:
rm -f *.o *~ ../common/*.o *.w2c.c *.w2c.h *.i *.B *.t *.w2c.cu *.w2c.ptx *.spin *.s *.x
rm -f npbparams.h core
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0893daa14dc19fd56430275744099ec67ea38fe8
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +412,12 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +444,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +473,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +496,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +517,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +535,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +571,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +579,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +609,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +623,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +636,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +650,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +688,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +699,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +711,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +723,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +738,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +750,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +764,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +778,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +800,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +835,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +847,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +865,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +874,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +883,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +891,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1088,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1196,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

exec
/bin/bash -lc 'cd data/src/mg-omp && make CC=nvc++ CLASS=A' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 11.22s:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams mg A && mv npbparams.h ..
nvc++  -c -Icommon -O3 -mp=gpu -gpu=ccall -Minfo=accel -mcmodel=medium mg.c
"mg.c", line 75: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_init] = "init";
                      ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"mg.c", line 76: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_bench] = "benchmk";
                       ^

"mg.c", line 77: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_mg3P] = "mg3P";
                      ^

"mg.c", line 78: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_psinv] = "psinv";
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0893daa14dc19fd56430275744099ec67ea38fe8
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +412,12 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +444,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +473,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +496,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +517,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +535,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +571,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +579,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +609,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +623,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +636,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +650,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +688,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +699,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +711,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +723,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +738,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +750,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +764,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +778,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +800,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +835,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +847,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +865,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +874,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +883,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +891,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1088,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1196,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Retrying executable for segfault**
exec
/bin/bash -lc 'cd data/src/mg-omp && ./mg.A.x' in /root/codex_baseline/serial_omp_nas_workdir exited -1 in 0ms:
execution error: Sandbox(Signal(11))
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0893daa14dc19fd56430275744099ec67ea38fe8
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +412,12 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +444,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +473,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +496,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +517,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +535,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +571,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +579,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +609,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +623,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +636,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +650,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +688,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +699,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +711,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +723,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +738,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +750,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +764,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +778,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +800,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +835,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +847,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +865,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +874,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +883,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +891,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1088,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1196,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Planning debugging with gdb**

I'm considering running the program under gdb to get a stack trace and pinpoint the segfault cause, possibly involving device memory mappings or pointer issues. Running with host offload disabled may help isolate the problem before deeper runtime debugging.
exec
/bin/bash -lc 'cd data/src/mg-omp && gdb -q ./mg.A.x -ex run -ex backtrace -ex quit' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 1.75s:
Reading symbols from ./mg.A.x...
Starting program: /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.A.x 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[New Thread 0x7ffff25ff640 (LWP 649317)]
[New Thread 0x7ffff19ff640 (LWP 649318)]
[Thread 0x7ffff19ff640 (LWP 649318) exited]
[New Thread 0x7ffff19ff640 (LWP 649319)]
Present table dump for device[1]: NVIDIA Tesla GPU 0, compute capability 8.9, threadid=1
Hint: specify 0x800 bit in NV_ACC_DEBUG for verbose info.
host:0x6b1318 device:0x718c00000 size:157635904 presentcount:0+2 line:159 name:r[:]
host:0x9d06858 device:0x70f400000 size:157635904 presentcount:0+2 line:159 name:v[:]
host:0x1335bd98 device:0x705c00000 size:157635904 presentcount:0+2 line:159 name:u[:]
host:0x7fffffffd3d0 device:0x7058fa000 size:32 presentcount:0+1 line:159 name:a[:]
host:0x7fffffffd440 device:0x7058fa200 size:32 presentcount:0+1 line:159 name:c[:]
allocated block device:0x7058fa000 size:512 thread:1
allocated block device:0x7058fa200 size:512 thread:1
allocated block device:0x705c00000 size:157636096 thread:1
allocated block device:0x70f400000 size:157636096 thread:1
allocated block device:0x718c00000 size:157636096 thread:1
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0893daa14dc19fd56430275744099ec67ea38fe8
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,26 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +412,12 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +444,26 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +473,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +496,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +517,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +535,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +571,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +579,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +609,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +623,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +636,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +650,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +688,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +699,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +711,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +723,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +738,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +750,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +764,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +778,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +800,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +835,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +847,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +865,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +874,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +883,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +891,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1088,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1196,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Identifying missing host allocations causing partial mapping errors**

The device partial present error comes from mapping uninitialized host pointers without allocated memory; next, I'll add explicit host allocations and frees for these buffers (u1, u2, r1, r2, x1, y1) before target data mapping in resid, psinv, and rprj3 to fix mapping issues.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -387,2 +387,4 @@
   size_t len = (size_t)n3*n2*n1;
+  r1 = (double*)malloc(len*sizeof(double));
+  r2 = (double*)malloc(len*sizeof(double));
 
@@ -418,2 +420,4 @@
   }
+  free(r1);
+  free(r2);
   if (timeron) timer_stop(T_psinv);
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..4ec25a568f982a21897e0d2b455f81ac9fd2fa82
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,28 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
+  r1 = (double*)malloc(len*sizeof(double));
+  r2 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +414,14 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
+  free(r1);
+  free(r2);
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +448,26 @@
   a2 = a[2];
   a3 = a[3];
 
+  size_t len = (size_t)n3*n2*n1;
+
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
-
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +477,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +500,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +521,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +539,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +575,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +583,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +613,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +627,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +640,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +654,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +692,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +703,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +715,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +727,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +742,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +754,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +768,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +782,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +804,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +839,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +851,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +869,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +878,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +887,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +895,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1092,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1200,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..4ec25a568f982a21897e0d2b455f81ac9fd2fa82
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,28 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
+  r1 = (double*)malloc(len*sizeof(double));
+  r2 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +414,14 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
+  free(r1);
+  free(r2);
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +448,26 @@
   a2 = a[2];
   a3 = a[3];
 
+  size_t len = (size_t)n3*n2*n1;
+
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
-
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +477,7 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +500,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +521,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +539,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +575,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +583,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +613,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +627,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +640,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +654,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +692,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +703,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +715,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +727,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +742,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +754,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +768,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +782,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +804,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +839,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +851,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +869,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +878,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +887,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +895,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1092,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1200,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Adding malloc and free wrappers**
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -451,2 +451,4 @@
   size_t len = (size_t)n3*n2*n1;
+  u1 = (double*)malloc(len*sizeof(double));
+  u2 = (double*)malloc(len*sizeof(double));
 
@@ -480,2 +482,4 @@
   }
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..5e878880532ae5308b6b12479db21c5eadd88861
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,28 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
+  r1 = (double*)malloc(len*sizeof(double));
+  r2 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +414,14 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
+  free(r1);
+  free(r2);
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +448,28 @@
   a2 = a[2];
   a3 = a[3];
 
+  size_t len = (size_t)n3*n2*n1;
+  u1 = (double*)malloc(len*sizeof(double));
+  u2 = (double*)malloc(len*sizeof(double));
+
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
-
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +479,9 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +504,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +525,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +543,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +579,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +587,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +617,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +631,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +644,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +658,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +696,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +707,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +719,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +731,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +746,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +758,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +772,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +786,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +808,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +843,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +855,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +873,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +882,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +891,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +899,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1096,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1204,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..5e878880532ae5308b6b12479db21c5eadd88861
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,28 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
+  r1 = (double*)malloc(len*sizeof(double));
+  r2 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,15 +414,14 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
+  free(r1);
+  free(r2);
   if (timeron) timer_stop(T_psinv);
 
- free(r1);
- free(r2);
-
   comm3(ou, n1, n2, n3, k);
 
   if (debug_vec[0] >= 1) {
@@ -445,35 +448,28 @@
   a2 = a[2];
   a3 = a[3];
 
+  size_t len = (size_t)n3*n2*n1;
+  u1 = (double*)malloc(len*sizeof(double));
+  u2 = (double*)malloc(len*sizeof(double));
+
   if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
-
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +479,9 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +504,7 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +525,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +543,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +579,6 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +587,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +617,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +631,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +644,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +658,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +696,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +707,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +719,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +731,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +746,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +758,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +772,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +786,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +808,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +843,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +855,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +873,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +882,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +891,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +899,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1096,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1204,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Restoring malloc/free usage**

I'm adding malloc and free calls back in for host memory allocations after the length definition, as earlier removals are now needing host-side allocation again.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -507,2 +507,4 @@
   size_t len = (size_t)m3k*m2k*m1k;
+  x1 = (double*)malloc(len*sizeof(double));
+  y1 = (double*)malloc(len*sizeof(double));
 
@@ -581,2 +583,4 @@
   }
+  free(x1);
+  free(y1);
 }
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M data/src/mg-omp/mg.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0ee691a480e053649ad303d0353981772cecd9d7
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,28 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
+  r1 = (double*)malloc(len*sizeof(double));
+  r2 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +414,13 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
+  free(r1);
+  free(r2);
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +448,28 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
+  u1 = (double*)malloc(len*sizeof(double));
+  u2 = (double*)malloc(len*sizeof(double));
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +479,9 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +504,9 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
+  x1 = (double*)malloc(len*sizeof(double));
+  y1 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +527,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +545,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +581,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +591,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +621,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +635,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +648,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +662,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +700,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +711,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +723,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +735,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +750,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +762,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +776,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +790,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +812,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +847,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +859,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +877,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +886,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +895,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +903,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1100,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1208,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0ee691a480e053649ad303d0353981772cecd9d7
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,28 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
+  r1 = (double*)malloc(len*sizeof(double));
+  r2 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +414,13 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
+  free(r1);
+  free(r2);
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +448,28 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
+  u1 = (double*)malloc(len*sizeof(double));
+  u2 = (double*)malloc(len*sizeof(double));
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +479,9 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +504,9 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
+  x1 = (double*)malloc(len*sizeof(double));
+  y1 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +527,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +545,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +581,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +591,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +621,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +635,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +648,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +662,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +700,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +711,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +723,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +735,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +750,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +762,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +776,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +790,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +812,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +847,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +859,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +877,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +886,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +895,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +903,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1100,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1208,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Checking for memory leaks with clean rebuild**
exec
/bin/bash -lc 'cd data/src/mg-omp && make clean' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 29ms:
rm -f *.o *~ ../common/*.o *.w2c.c *.w2c.h *.i *.B *.t *.w2c.cu *.w2c.ptx *.spin *.s *.x
rm -f npbparams.h core
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0ee691a480e053649ad303d0353981772cecd9d7
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,28 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
+  r1 = (double*)malloc(len*sizeof(double));
+  r2 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +414,13 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
+  free(r1);
+  free(r2);
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +448,28 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
+  u1 = (double*)malloc(len*sizeof(double));
+  u2 = (double*)malloc(len*sizeof(double));
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +479,9 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +504,9 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
+  x1 = (double*)malloc(len*sizeof(double));
+  y1 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +527,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +545,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +581,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +591,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +621,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +635,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +648,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +662,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +700,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +711,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +723,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +735,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +750,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +762,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +776,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +790,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +812,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +847,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +859,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +877,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +886,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +895,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +903,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1100,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1208,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

exec
/bin/bash -lc 'cd data/src/mg-omp && make CC=nvc++ CLASS=A' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 8.76s:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams mg A && mv npbparams.h ..
nvc++  -c -Icommon -O3 -mp=gpu -gpu=ccall -Minfo=accel -mcmodel=medium mg.c
"mg.c", line 75: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_init] = "init";
                      ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"mg.c", line 76: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_bench] = "benchmk";
                       ^

"mg.c", line 77: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_mg3P] = "mg3P";
                      ^

"mg.c", line 78: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
      t_names[T_psinv] = "psinv";
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0ee691a480e053649ad303d0353981772cecd9d7
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,28 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
+  r1 = (double*)malloc(len*sizeof(double));
+  r2 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +414,13 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
+  free(r1);
+  free(r2);
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +448,28 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
+  u1 = (double*)malloc(len*sizeof(double));
+  u2 = (double*)malloc(len*sizeof(double));
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +479,9 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +504,9 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
+  x1 = (double*)malloc(len*sizeof(double));
+  y1 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +527,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +545,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +581,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +591,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +621,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +635,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +648,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +662,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +700,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +711,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +723,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +735,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +750,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +762,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +776,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +790,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +812,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +847,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +859,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +877,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +886,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +895,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +903,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1100,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1208,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Testing for segfault resolution**
exec
/bin/bash -lc 'cd data/src/mg-omp && ./mg.A.x' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 2.27s:


 NAS Parallel Benchmarks (NPB3.3-ACC-C) - MG Benchmark

 No input file. Using compiled defaults 
 Size:  256x 256x 256  (class A)
 Iterations:   4

 Initialization time:           1.692 seconds

  iter   1
  iter   4

 Benchmark completed
 VERIFICATION SUCCESSFUL
 L2 Norm is  2.4333653090695E-06
 Error is    2.0485164623715E-13


 MG Benchmark Completed.
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0ee691a480e053649ad303d0353981772cecd9d7
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,28 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
+  r1 = (double*)malloc(len*sizeof(double));
+  r2 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +414,13 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
+  free(r1);
+  free(r2);
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +448,28 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
+  u1 = (double*)malloc(len*sizeof(double));
+  u2 = (double*)malloc(len*sizeof(double));
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +479,9 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +504,9 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
+  x1 = (double*)malloc(len*sizeof(double));
+  y1 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +527,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +545,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +581,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +591,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +621,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +635,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +648,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +662,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +700,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +711,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +723,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +735,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +750,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +762,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +776,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +790,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +812,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +847,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +859,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +877,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +886,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +895,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +903,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1100,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1208,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }


thinking
**Summarizing modifications and test results**

I will prepare a final response outlining the changes made in the specified file path, noting that any warnings encountered are acceptable. I'll list the tests run, including `make clean` and `make`, and confirm their successful output before suggesting optional next steps.
codex
Added OpenMP GPU offload across MG kernels: introduced target data mapping for `u/v/r`, offloaded all heavy 3D loops with `target teams loop`, and replaced temporary buffer handling with device-mapped allocations for psinv, resid, rprj3, and interp. Boundary exchange, zeroing, and norm calculations now run on the GPU, with host/device synchronization handled via OpenMP directives. Initialization and execution stay within a single target data region for reduced transfers.

Key file: `data/src/mg-omp/mg.c`

Commands run:
- `make clean`
- `make CC=nvc++ CLASS=A`
- `./mg.A.x` (passes verification, Class A)

Warnings are from legacy string literals and unused locals; runtime completes and verifies successfully.
file update:
diff --git a/serial_omp_nas_workdir/data/src/mg-omp/mg.c b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
index 97b1d46904519ee2b87d1a8e386bf109c0b80915..0ee691a480e053649ad303d0353981772cecd9d7
--- a/serial_omp_nas_workdir/data/src/mg-omp/mg.c
+++ b/serial_omp_nas_workdir/data/src/mg-omp/mg.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <omp.h>
 
 #include "globals.h"
 
@@ -154,6 +155,7 @@
   lb = 1;
   k  = lt;
 
+#pragma omp target data map(tofrom:u[0:NR], v[0:NR], r[0:NR]) map(to:a[0:4], c[0:4])
 {
   setup(&n1, &n2, &n3);
   zero3(u, n1, n2, n3);
@@ -382,26 +384,28 @@
   c1 = c[1];
   c2 = c[2];
 
-r1 = (double*)malloc(n3*n2*n1*sizeof(double));
-r2 = (double*)malloc(n3*n2*n1*sizeof(double));
+  size_t len = (size_t)n3*n2*n1;
+  r1 = (double*)malloc(len*sizeof(double));
+  r2 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_psinv);
+  #pragma omp target data map(present:orr[0:len], ou[0:len]) map(alloc:r1[0:len], r2[0:len])
+  {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], r1[0:len], r2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(r1, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3, i2-1, i1) + I3D(orr, n1, n2, i3, i2+1, i1)
                + I3D(orr, n1, n2, i3-1, i2, i1) + I3D(orr, n1, n2, i3+1, i2, i1);
         I3D(r2, n1, n2, i3, i2, i1) = I3D(orr, n1, n2, i3-1, i2-1, i1) + I3D(orr, n1, n2, i3-1, i2+1, i1)
                + I3D(orr, n1, n2, i3+1, i2-1, i1) + I3D(orr, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ou[0:len], r1[0:len], r2[0:len]) firstprivate(c0,c1,c2,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
                                     + c0 * I3D(orr, n1, n2, i3, i2, i1)
                                     + c1 * ( I3D(orr, n1, n2, i3, i2, i1-1)
@@ -410,14 +414,13 @@
 									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
 									         + I3D(r1, n1, n2, i3, i2, i1-1)
 											 + I3D(r1, n1, n2, i3, i2, i1+1));
-
       }
     }
   }
+  }
+  free(r1);
+  free(r2);
   if (timeron) timer_stop(T_psinv);
-
- free(r1);
- free(r2);
 
   comm3(ou, n1, n2, n3, k);
 
@@ -445,35 +448,28 @@
   a2 = a[2];
   a3 = a[3];
 
-  if (timeron) timer_start(T_resid);
-  #ifdef _OPENACC
-  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
-  #else
-  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
-  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
-  #endif
+  size_t len = (size_t)n3*n2*n1;
+  u1 = (double*)malloc(len*sizeof(double));
+  u2 = (double*)malloc(len*sizeof(double));
 
+  if (timeron) timer_start(T_resid);
+  #pragma omp target data map(present:ou[0:len], ov[0:len], orr[0:len]) map(alloc:u1[0:len], u2[0:len])
   {
-{ 
+  #pragma omp target teams loop collapse(3) map(present:ou[0:len], u1[0:len], u2[0:len]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-	  
         I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
                + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
         I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
                + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);
-
       }
     }
   }
-}
-{
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], ov[0:len], ou[0:len], u1[0:len], u2[0:len]) firstprivate(a0,a2,a3,n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
-	  
         I3D(orr, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
 							 -a0 * I3D(ou, n1, n2, i3, i2, i1)
 
@@ -483,16 +479,9 @@
       }
     }
   }
-  } 
-  } 
-
-  #ifdef _OPENACC
-  	acc_free(u1);
-  	acc_free(u2);
-  #else
-  	free(u1);
-  	free(u2);
-  #endif
+  }
+  free(u1);
+  free(u2);
   if (timeron) timer_stop(T_resid);
 
   comm3(orr, n1, n2, n3, k);
@@ -515,13 +504,9 @@
   int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;
 
   double *x1, *y1, x2, y2;
-  #ifdef _OPENACC
-  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
-  #else
-  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
-  #endif
+  size_t len = (size_t)m3k*m2k*m1k;
+  x1 = (double*)malloc(len*sizeof(double));
+  y1 = (double*)malloc(len*sizeof(double));
 
   if (timeron) timer_start(T_rprj3);
   if (m1k == 3) {
@@ -542,7 +527,9 @@
     d3 = 1;
   }
 
+  #pragma omp target data map(present:orr[0:len]) map(present:os[0:(size_t)m3j*m2j*m1j]) map(alloc:x1[0:len], y1[0:len])
   {
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -558,6 +545,7 @@
       }
     }
   }
+  #pragma omp target teams loop collapse(3) map(present:orr[0:len], os[0:(size_t)m3j*m2j*m1j], x1[0:len], y1[0:len]) firstprivate(m1k,m2k,m3k,m1j,m2j,m3j,d1,d2,d3)
   for (j3 = 1; j3 < m3j-1; j3++) {
     i3 = 2*j3-d3;
     for (j2 = 1; j2 < m2j-1; j2++) {
@@ -593,13 +581,8 @@
     
     showall(os, m1j, m2j, m3j);
   }
-  #ifdef _OPENACC
-  	acc_free(x1);
-  	acc_free(y1);
-  #else
-  	free(x1);
-	free(y1);
-  #endif
+  free(x1);
+  free(y1);
 }
 
 static void interp(double *oz, int mm1, int mm2, int mm3,
@@ -608,27 +591,21 @@
 
   int i3, i2, i1, d1, d2, d3, t1, t2, t3;
 
-  static double *z1, *z2, *z3;
+  size_t len_fine = (size_t)n3*n2*n1;
+  size_t len_coarse = (size_t)mm3*mm2*mm1;
 
-  #ifdef _OPENACC
-	
-  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-	
-  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
-  #else
-  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
-  #endif
+  double *z1 = (double*)malloc(len_coarse*sizeof(double));
+  double *z2 = (double*)malloc(len_coarse*sizeof(double));
+  double *z3 = (double*)malloc(len_coarse*sizeof(double));
 
   if (timeron) timer_start(T_interp);
 
+  #pragma omp target data map(present:ou[0:len_fine], oz[0:len_coarse]) map(alloc:z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse])
   {
 
   if (n1 != 3 && n2 != 3 && n3 != 3) {
 
+    #pragma omp target teams loop collapse(3) map(present:oz[0:len_coarse], z1[0:len_coarse], z2[0:len_coarse], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1; i1++) {
@@ -644,6 +621,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -657,6 +635,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z1[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -669,6 +648,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z2[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -682,6 +662,7 @@
        }
      }
  
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], z3[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3)
     for (i3 = 0; i3 < mm3-1; i3++) {
       for (i2 = 0; i2 < mm2-1; i2++) {
         for (i1 = 0; i1 < mm1-1; i1++) {
@@ -719,6 +700,7 @@
       t3 = 0;
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -729,6 +711,7 @@
         }
        }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -740,6 +723,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -751,6 +735,7 @@
         }
 	  }
 	 }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2)
     for (i3 = d3; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -765,6 +750,7 @@
       }
     }
 
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -776,6 +762,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = d2; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -789,6 +776,7 @@
         }
       }
     }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = d1; i1 <= mm1-1; i1++) {
@@ -802,6 +790,7 @@
         }
        }
      }
+    #pragma omp target teams loop collapse(3) map(present:ou[0:len_fine], oz[0:len_coarse]) firstprivate(mm1,mm2,mm3,n1,n2,n3,d1,d2,d3,t1,t2,t3)
     for (i3 = 1; i3 <= mm3-1; i3++) {
       for (i2 = 1; i2 <= mm2-1; i2++) {
         for (i1 = 1; i1 <= mm1-1; i1++) {
@@ -823,15 +812,9 @@
   }
    }
 
-  #ifdef _OPENACC
-  	acc_free(z1);
-  	acc_free(z2);
-  	acc_free(z3);
-  #else
-  	free(z1);
-	free(z2);
-	free(z3);
-  #endif
+  free(z1);
+  free(z2);
+  free(z3);
   if (timeron) timer_stop(T_interp);
 
   if (debug_vec[0] >= 1) {
@@ -864,20 +847,7 @@
   s = 0.0;
   *rnmu = 0.0;
   temp = *rnmu;
-{
-#ifdef __PGIC__
-  for (i3 = 1; i3 < n3-1; i3++) {
-    for (i2 = 1; i2 < n2-1; i2++) {
-      for (i1 = 1; i1 < n1-1; i1++) {
-
-        s = s + pow(I3D(orr, n1, n2, i3, i2, i1), 2.0);
-        a = fabs(I3D(orr, n1, n2, i3, i2, i1));
-        
-        temp = max(temp, a);
-      }
-    }
-  }
-#else
+  #pragma omp target teams loop collapse(3) map(present:orr[0:(size_t)n1*n2*n3]) reduction(+:s) reduction(max:temp) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
       for (i1 = 1; i1 < n1-1; i1++) {
@@ -889,8 +859,6 @@
       }
     }
   }
-#endif
-}
   *rnmu = temp;
   *rnm2 = sqrt(s / dn);
   if (timeron) timer_stop(T_norm2);
@@ -909,7 +877,7 @@
 
   int i1, i2, i3;
   if (timeron) timer_start(T_comm3);
-  {
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i2 = 1; i2 < n2-1; i2++) {
 	
@@ -918,6 +886,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i3 = 1; i3 < n3-1; i3++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -926,6 +895,7 @@
     }
   }
 
+  #pragma omp target teams loop collapse(2) map(present:ou[0:(size_t)n1*n2*n3]) firstprivate(n1,n2,n3)
   for (i2 = 0; i2 < n2; i2++) {
     for (i1 = 0; i1 < n1; i1++) {
 	
@@ -933,7 +903,6 @@
 	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
     }
   }
-  } 
   if (timeron) timer_stop(T_comm3);
 }
 
@@ -1131,6 +1100,7 @@
     I3D(oz, n1, n2, i3, i2, i1) = +1.0;
   }
 
+  #pragma omp target update to(oz[0:(size_t)n1*n2*n3])
   comm3(oz, n1, n2, n3, k);
 
 }
@@ -1238,14 +1208,12 @@
 
   int i1, i2, i3;
 
-{
+#pragma omp target teams loop collapse(3) map(present:oz[0:n1*n2*n3])
   for (i3 = 0; i3 < n3; i3++) {
     for (i2 = 0; i2 < n2; i2++) {
       for (i1 = 0; i1 < n1; i1++) {
-   
-   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
+        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
       }
     }
   }
-}
 }

tokens used
475,765