Applied OpenMP GPU offload across the FT kernel with managed memory and team-based loops. Key updates:
- Added a device-visible `device_exp` helper and offloaded all heavy loops (initialization, evolution, 1D FFT stages, checksum) via `target teams loop`, relying on managed memory instead of explicit mapping (`data/src/ft-omp/ft.c`).
- Simplified data movement by removing the target data/update scaffolding; GPU accesses use managed allocations driven by OpenMP targets.
- Added a convenience `Makefile.nvc` wrapper to drive builds with the NVIDIA compiler (`data/src/ft-omp/Makefile.nvc`).

Build & run (cleaned first):
- `make -f Makefile.nvc clean`
- `make -f Makefile.nvc CC=nvc++ CLASS=B CFLAGS='-O3 -mp=gpu -gpu=ccall,mem:managed -Minfo=accel' CLINKFLAGS='-O3 -mp=gpu -gpu=ccall,mem:managed -Minfo=accel'`
- `./ft.B.x` → verification successful (Class B).

Notes: nvc++ emits benign warnings about string literal conversions and unused locals; no runtime issues observed. If you prefer, the `-gpu=ccall,mem:managed` flag can be adjusted to a specific SM (e.g., `-gpu=cc90,mem:managed`).

OpenAI Codex v0.71.0 (research preview)
--------
workdir: /root/codex_baseline/serial_omp_nas_workdir
model: gpt-5.1-codex-max
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: low
reasoning summaries: auto
session id: 019b1d9d-d5f0-7ba2-860e-7f978c8a2812
--------
user
## First Step: Copy Source Files
Copy source files = - ft.c from /root/codex_baseline/serial_omp_nas_workdir/golden_labels/src/ft-serial to /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp.

**Files:** - ft.c

**Your Task:**
1. Translate the code below to an OpenMP GPU-offloaded version.
2. Apply GPU offloading pragmas as needed. (`use teams loop` and not `teams distribute parallel for`)
3. Optimize the code for performance while preserving its original functionality.
4. make sure the code compiles with `make -f Makefile.nvc`, and runs with ./<executable
5. Deliver the modified code to /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp.

**Deliverable:**
- The complete, modified source code for - ft.c in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp, that can be compiled with `make CC=nvc++ CLASS=B` and runs with `./<executable>`.

** Rules **
- NO GIT COMMANDS.
- DO NOT READ/WRITE OUTSIDE THE WORKING DIRECTORY.
- ALWAYS CLEAN BEFORE BUILD.


mcp startup: no servers

thinking
**Preparing to copy after reading system info**
exec
/bin/bash -lc pwd in /root/codex_baseline/serial_omp_nas_workdir succeeded in 14ms:
/root/codex_baseline/serial_omp_nas_workdir
exec
/bin/bash -lc ls in /root/codex_baseline/serial_omp_nas_workdir succeeded in 16ms:
AGENTS.md
data
data_plan.md
ep.c.orig
gate_sdk
golden_labels
npb3.3.1.tar.gz
omp_test.o
system_info.txt
test_all_nas_kernels.sh

thinking
**Confirming need to read system info**
exec
/bin/bash -lc 'cat system_info.txt' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 14ms:
=== SYSTEM BASELINE ===
Linux ErelPC 6.6.87.2-microsoft-standard-WSL2 #1 SMP PREEMPT_DYNAMIC Thu Jun  5 18:30:46 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux
PRETTY_NAME="Ubuntu 22.04.3 LTS"
NAME="Ubuntu"
VERSION_ID="22.04"
VERSION="22.04.3 LTS (Jammy Jellyfish)"
VERSION_CODENAME=jammy
ID=ubuntu
ID_LIKE=debian
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
UBUNTU_CODENAME=jammy
ldd (Ubuntu GLIBC 2.35-0ubuntu3.11) 2.35

=== FIRMWARE & MICROCODE ===
# dmidecode 3.3
Scanning /dev/mem for entry point.
# No SMBIOS nor DMI entry point found, sorry.

thinking
**Locating directories for copying file**

I'm checking the source and destination directories to copy the ft.c file from golden to data source.
exec
/bin/bash -lc 'ls golden_labels/src/ft-serial' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 15ms:
Makefile
c_timers.c
c_timers.llvm
c_timers.o
common
config
ft.S.x
ft.c
ft.llvm
ft.lst
ft.o
ft_2.llvm
globals.h
npbparams.h
print_results.c
print_results.h
print_results.llvm
print_results.o
randdp.c
randdp.h

thinking
**Checking existence of target directory**
exec
/bin/bash -lc 'ls data/src/ft-omp' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 8ms:
Makefile
c_timers.c
c_timers.llvm
common
config
globals.h
print_results.c
print_results.h
print_results.llvm
randdp.c
randdp.h
randdp.llvm
serial_gold
sys
timers.h
wtime.c
wtime.h
wtime.llvm

thinking
**Copying missing source file**

I found that ft.c is missing and plan to copy it from the golden reference to the data directory using the cp command.
exec
/bin/bash -lc 'cp golden_labels/src/ft-serial/ft.c data/src/ft-omp/ft.c' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 23ms:


thinking
**Inspecting GPU offload potential in ft.c**
exec
/bin/bash -lc "sed -n '1,200p' data/src/ft-omp/ft.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 12ms:

#ifdef __PGIC__
#undef __GNUC__
#else
#define num_workers(a)
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <omp.h>
#include "npbparams.h"

#include "randdp.h"
#include "timers.h"
#include "print_results.h"
#include "type.h"

#define FFTBLOCKPAD   33

thinking
**Requesting more content**
exec
/bin/bash -lc "sed -n '200,400p' data/src/ft-omp/ft.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 17ms:
    mflops = 1.0e-6 * (double)NTOTAL *
            (14.8157 + 7.19641 * log((double)NTOTAL)
            + (5.23518 + 7.21113 * log((double)NTOTAL)) * niter)
            / total_time;
  } else {
    mflops = 0.0;
  }
  print_results("FT", Class, NX, NY, NZ, niter,
                total_time, mflops, "          floating point", verified, 
                NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);
  if (timers_enabled) print_timers();

free_arrays();
  return 0;
}

static void init_ui(int d1, int d2, int d3)
{
  int i, j, k;

exec
/bin/bash -lc "sed -n '400,800p' data/src/ft-omp/ft.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 9ms:
  tstrings[7] = "           ffty "; 
  tstrings[8] = "           fftz ";

  t_m = timer_read(T_total);
  if (t_m <= 0.0) t_m = 1.00;
  for (i = 1; i <= T_max; i++) {
    t = timer_read(i);
    printf(" timer %2d(%16s) :%9.4f (%6.2f%%)\n", 
        i, tstrings[i], t, t*100.0/t_m);
  }
}

static void fft_init(int n)
{
  int m, nu, ku, i, j, ln;
  double t, ti;

  nu = n;
  m = ilog2(n);
  
exec
/bin/bash -lc "sed -n '800,1200p' data/src/ft-omp/ft.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 11ms:

          for (i1 = 0; i1 <= li - 1; i1++) {
            for (k1 = 0; k1 <= lk - 1; k1++) {
              i11 = i1 * lk;
              i12 = i11 + n1;
              i21 = i1 * lj;
              i22 = i21 + lk;

              uu1_real = u_real[ku + i1];
              uu1_imag = -1.0 * u_imag[ku + i1];

              x11_real = GTY1_REAL(k, i11 + k1, i);
              x11_imag = GTY1_IMAG(k, i11 + k1, i);

              x21_real = GTY1_REAL(k, i12 + k1, i);
              x21_imag = GTY1_IMAG(k, i12 + k1, i);

              GTY2_REAL(k, i21 + k1, i) = x11_real + x21_real;
              GTY2_IMAG(k, i21 + k1, i) = x11_imag + x21_imag;

exec
/bin/bash -lc "sed -n '1200,1600p' data/src/ft-omp/ft.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 7ms:
    *Class = 'C';
    csum_ref[1]  = dcmplx(5.195078707457E+02, 5.149019699238E+02);
    csum_ref[2]  = dcmplx(5.155422171134E+02, 5.127578201997E+02);
    csum_ref[3]  = dcmplx(5.144678022222E+02, 5.122251847514E+02);
    csum_ref[4]  = dcmplx(5.140150594328E+02, 5.121090289018E+02);
    csum_ref[5]  = dcmplx(5.137550426810E+02, 5.121143685824E+02);
    csum_ref[6]  = dcmplx(5.135811056728E+02, 5.121496764568E+02);
    csum_ref[7]  = dcmplx(5.134569343165E+02, 5.121870921893E+02);
    csum_ref[8]  = dcmplx(5.133651975661E+02, 5.122193250322E+02);
    csum_ref[9]  = dcmplx(5.132955192805E+02, 5.122454735794E+02);
    csum_ref[10] = dcmplx(5.132410471738E+02, 5.122663649603E+02);
    csum_ref[11] = dcmplx(5.131971141679E+02, 5.122830879827E+02);
    csum_ref[12] = dcmplx(5.131605205716E+02, 5.122965869718E+02);
    csum_ref[13] = dcmplx(5.131290734194E+02, 5.123075927445E+02);
    csum_ref[14] = dcmplx(5.131012720314E+02, 5.123166486553E+02);
    csum_ref[15] = dcmplx(5.130760908195E+02, 5.123241541685E+02);
    csum_ref[16] = dcmplx(5.130528295923E+02, 5.123304037599E+02);
    csum_ref[17] = dcmplx(5.130310107773E+02, 5.123356167976E+02);
    csum_ref[18] = dcmplx(5.130103090133E+02, 5.123399592211E+02);
    csum_ref[19] = dcmplx(5.129905029333E+02, 5.123435588985E+02);

thinking
**Planning GPU offload with OpenMP teams loops**

I'm outlining GPU offloading by mapping large arrays once to the device via target data regions, offloading key loops like init, compute_indexmap, evolve, and FFT steps using teams loops with collapse clauses. Initialization currently runs on CPU due to sequential RNG, so I'll map data to GPU after that, minimizing transfers for performance.
Plan update
Implement OpenMP GPU offload version of FT while preserving functionality and ensuring build/run with make -f Makefile.nvc.
  → Understand code structure and identify loops/arrays needing GPU offload and data lifetimes
  • Apply OpenMP target data/lifetimes and offload directives using teams loop; adjust utility code as needed
  • Build with make -f Makefile.nvc cleanly and run executable to confirm correctness


thinking
**Planning OpenMP target data region and mappings**

I'm outlining how to insert a single OpenMP target data region in main after initial host computations, mapping main arrays with tofrom and scratch arrays with alloc. I'll wrap FFT and iteration loops inside this region, use target update to sync host modifications to device, and restructure loops with target teams loop collapse for efficient offloading. The checksum will be adapted to run device-side with reduction to minimize host-device transfers.
thinking
**Clarifying host-device sync and offloading init_ui**

I confirmed that host updates require explicit target update to sync device arrays before device use, especially for key arrays after compute_initial_conditions and compute_indexmap. I plan to offload init_ui with a target teams loop, applying patches stepwise to ensure proper mapping sizes and device execution without unnecessary host-device transfers.
file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -218,4 +218,7 @@
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
@@ -231,3 +234,2 @@
   }
- }
 }
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..2d5efef25de897e060c99255063449a6a04977cb
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +232,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)


thinking
**Offloading init and updating evolve function**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..2d5efef25de897e060c99255063449a6a04977cb
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +232,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -240,4 +240,7 @@
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
@@ -245,6 +248,8 @@
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
@@ -252,3 +257,2 @@
   }
- } 
 }
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..785b0fca53ea473a79469ae6082d31c762c0e57a
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)


thinking
**Deciding compute_initial_conditions execution**

Compute_initial_conditions should remain on the host due to sequential RNG and use of host arrays, while ensuring device updates happen afterward via the main target update; compute_indexmap will be updated with a target teams loop.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..785b0fca53ea473a79469ae6082d31c762c0e57a
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -374,2 +374,3 @@
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
@@ -377,3 +378,3 @@
 
-{
+#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
   for (k = 0; k < d3; k++) {
@@ -381,8 +382,8 @@
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
@@ -391,3 +392,2 @@
   }
- }
 }
apply_patch(auto_approved=true) exited 0 in 4ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..d4ead006b7232127a00db182fecdcbe8f63c0308
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()


thinking
**Planning OpenMP target offloading**

I'm deciding to keep initial FFT setup on host for simplicity but will modify core FFT functions to use OpenMP target teams with mapped arrays for performance. I'll add constants for array sizes and wrap long loops with target teams and map clauses, ensuring proper mapping of all involved arrays and confirming the legality of size constants like gsize in maps.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..d4ead006b7232127a00db182fecdcbe8f63c0308
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -476,4 +476,9 @@
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
@@ -563,3 +568,2 @@
   }
- }
 }
apply_patch(auto_approved=true) exited 0 in 4ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..b7dc80d6f6333a997d198c098fdb4dc629cbdaf2
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)


thinking
**Updating cffts1_neg similarly**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..b7dc80d6f6333a997d198c098fdb4dc629cbdaf2
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -584,4 +584,9 @@
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
@@ -668,3 +673,3 @@
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
@@ -672,3 +677,2 @@
     }
-  }
 }
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..b25e488d7bfa8a49b0949e7d16e91abc7a8457f4
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +582,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +671,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)


thinking
**Applying similar changes to related functions**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..b25e488d7bfa8a49b0949e7d16e91abc7a8457f4
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +582,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +671,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -693,4 +693,9 @@
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
@@ -777,3 +782,3 @@
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
@@ -781,3 +786,2 @@
     }
-  }
 }
@@ -798,4 +802,9 @@
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
@@ -882,3 +891,3 @@
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
@@ -886,3 +895,2 @@
     }
-  }
 }
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a41503b4ed2785a78fb657856e6654c039a56fab
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +582,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +671,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +691,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +780,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +800,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +889,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)


thinking
**Identifying missing test cases**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a41503b4ed2785a78fb657856e6654c039a56fab
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +582,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +671,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +691,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +780,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +800,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +889,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -911,4 +911,10 @@
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
@@ -999,3 +1005,2 @@
     }
-  }
 }
@@ -1016,4 +1021,10 @@
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
@@ -1104,3 +1115,2 @@
     }
-  }
 }
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..f5ff075635c4e28a6ae5da7c9f41f90a9959dfb6
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +582,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +671,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +691,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +780,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +800,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +889,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +909,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1003,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1019,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1113,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)


thinking
**Planning checksum offload reduction**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..f5ff075635c4e28a6ae5da7c9f41f90a9959dfb6
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +582,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +671,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +691,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +780,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +800,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +889,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +909,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1003,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1019,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1113,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -1135,2 +1135,3 @@
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
@@ -1143,3 +1144,3 @@
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
@@ -1148,6 +1149,5 @@
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..7e74a39e2a39dc671920614e1a3ca37a958c768f
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +582,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +671,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +691,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +780,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +800,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +889,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +909,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1003,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1019,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1113,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1133,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1142,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Planning main function rewrite**

I'm preparing to update the main function to include target data region setup, starting by inspecting the earlier main portion around timers to integrate these changes properly.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..7e74a39e2a39dc671920614e1a3ca37a958c768f
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +582,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +671,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +691,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +780,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +800,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +889,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +909,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1003,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1019,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1113,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1133,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1142,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "sed -n '40,140p' data/src/ft-omp/ft.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 16ms:
#define SEED          314159265.0
#define A             1220703125.0
#define PI            3.141592653589793238
#define ALPHA         1.0e-6

static dcomplex sums[NITER_DEFAULT+1];
static int niter;

#define dcmplx(r,i)       (dcomplex){r, i}
#define dcmplx_add(a,b)   (dcomplex){(a).real+(b).real, (a).imag+(b).imag}
#define dcmplx_sub(a,b)   (dcomplex){(a).real-(b).real, (a).imag-(b).imag}
#define dcmplx_mul(a,b)   (dcomplex){((a).real*(b).real)-((a).imag*(b).imag),\
                                     ((a).real*(b).imag)+((a).imag*(b).real)}
#define dcmplx_mul2(a,b)  (dcomplex){(a).real*(b), (a).imag*(b)}
static inline dcomplex dcmplx_div(dcomplex z1, dcomplex z2) {
  double a = z1.real;
  double b = z1.imag;
  double c = z2.real;
  double d = z2.imag;


thinking
**Planning main region adjustment**

I'm focusing on identifying the main area near the earlier start point to align modifications appropriately. Next, I'll locate and verify that main region for accurate updating.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..7e74a39e2a39dc671920614e1a3ca37a958c768f
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +582,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +671,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +691,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +780,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +800,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +889,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +909,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1003,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1019,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1113,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1133,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1142,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "sed -n '140,260p' data/src/ft-omp/ft.c" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 14ms:
    free(u0_real);
    free(u0_imag);
    free(u1_real);
    free(u1_imag);
    free(twiddle);

    free(gty1_real);
    free(gty1_imag);
    free(gty2_real);
    free(gty2_imag);
    free(host_u1_real);
    free(host_u1_imag);
}

int main(int argc, char *argv[])
{
  int i;
  int iter;
  double total_time, mflops;
  logical verified;

thinking
**Planning OpenMP target data restructuring**

I'm outlining a patch to wrap computation in a single target data region to reduce redundant mappings and offloads, adjusting map clauses—especially changing compute_indexmap from map(present) to map(tofrom) to handle calls both inside and outside the target data region safely.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..7e74a39e2a39dc671920614e1a3ca37a958c768f
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +582,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +671,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +691,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +780,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +800,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +889,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +909,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1003,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1019,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1113,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1133,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1142,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -378,3 +378,3 @@
 
-#pragma omp target teams loop collapse(3) map(present: twiddle[0:total])
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
apply_patch(auto_approved=true) exited 0 in 4ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..00c7a5f4dec927271e35321f3e9462499017421c
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +582,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +671,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +691,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +780,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +800,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +889,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +909,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1003,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1019,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1113,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1133,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1142,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Refactoring main to use patch application**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..00c7a5f4dec927271e35321f3e9462499017421c
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -216,8 +216,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +232,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +372,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +582,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +671,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +691,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +780,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +800,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +889,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +909,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1003,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1019,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1113,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1133,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1142,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -172,22 +172,33 @@
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a79e0f239378220724f3f2c92863a889d91c67fc
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +383,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +485,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +577,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +593,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +682,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +702,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +791,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +811,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +900,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +920,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1014,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1030,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1124,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1144,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1153,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Verifying OpenMP mapping and data transfers**

I'm confirming that compute_initial_conditions runs on host arrays with proper device updates afterward, while compute_indexmap uses target teams with map tofrom to manage device copies correctly. The plan includes ensuring target data regions use map(present) to avoid remapping overhead and that arrays are consistently allocated with correct sizes and mappings, followed by cleaning before build and updating plan statuses.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a79e0f239378220724f3f2c92863a889d91c67fc
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +383,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +485,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +577,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +593,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +682,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +702,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +791,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +811,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +900,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +920,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1014,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1030,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1124,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1144,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1153,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

Plan update
  ✓ Understand code structure and identify loops/arrays needing GPU offload and data lifetimes
  → Apply OpenMP target data/lifetimes and offload directives using teams loop; adjust utility code as needed
  • Build with make -f Makefile.nvc cleanly and run executable to confirm correctness

thinking
**Ensuring proper target data mapping and cleaning before build**

I'm verifying that compute_initial_conditions uses the correct host and target data updates, confirming macro-sized host arrays are mapped correctly, and ensuring no leftover unmatched braces after prepatch. Also planning to clean before building from the correct working directory with "make -f Makefile.nvc clean" inside data/src/ft-omp.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a79e0f239378220724f3f2c92863a889d91c67fc
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +383,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +485,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +577,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +593,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +682,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +702,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +791,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +811,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +900,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +920,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1014,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1030,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1124,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1144,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1153,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp exited 2 in 8ms:
make: Makefile.nvc: No such file or directory
make: *** No rule to make target 'Makefile.nvc'.  Stop.

thinking
**Confirming Makefile.nvc absence**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a79e0f239378220724f3f2c92863a889d91c67fc
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +383,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +485,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +577,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +593,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +682,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +702,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +791,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +811,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +900,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +920,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1014,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1030,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1124,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1144,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1153,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'ls /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 8ms:
Makefile
c_timers.c
c_timers.llvm
common
config
ft.c
globals.h
print_results.c
print_results.h
print_results.llvm
randdp.c
randdp.h
randdp.llvm
serial_gold
sys
timers.h
wtime.c
wtime.h
wtime.llvm

thinking
**Checking presence and role of Makefile.nvc**

I'm investigating if Makefile.nvc exists or needs creating since instructions specify compiling with it; the golden directory only has Makefile, so next I'll locate any Makefile.nvc across the repo or consider symlinking or creating one based on the existing Makefile.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a79e0f239378220724f3f2c92863a889d91c67fc
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +383,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +485,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +577,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +593,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +682,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +702,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +791,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +811,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +900,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +920,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1014,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1030,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1124,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1144,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1153,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "find .. -name 'Makefile.nvc'" in /root/codex_baseline/serial_omp_nas_workdir/data/src succeeded in 22ms:


thinking
**Planning creation of Makefile.nvc**

I'm considering creating a Makefile.nvc that includes the existing Makefile but overrides the compiler to nvc++ and adds necessary flags, ensuring compatibility with the instruction to compile using `make -f Makefile.nvc` without duplicating build rules. Next, I'll verify the current Makefile to align overrides properly.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a79e0f239378220724f3f2c92863a889d91c67fc
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +383,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +485,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +577,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +593,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +682,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +702,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +791,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +811,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +900,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +920,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1014,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1030,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1124,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1144,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1153,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "sed -n '1,160p' /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/Makefile" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 7ms:
SHELL=/bin/sh
BENCHMARK=ft
BENCHMARKU=FT

include config/make.def

include sys/make.common

OBJS = ft.o ${RAND}.o print_results.o \
       c_timers.o wtime.o

${PROGRAM}: config ${OBJS}
	${CLINK} ${CLINKFLAGS} -o ${PROGRAM} ${OBJS} ${C_LIB}

.c.o:
	${CCOMPILE} $<

ft.o:             ft.c npbparams.h globals.h
#ft_2.o:           ft_2.c npbparams.h globals.h


thinking
**Checking for make.def presence**

I'm verifying whether the config/make.def file exists to determine if additional configuration setups are needed next.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a79e0f239378220724f3f2c92863a889d91c67fc
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +383,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +485,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +577,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +593,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +682,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +702,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +791,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +811,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +900,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +920,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1014,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1030,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1124,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1144,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1153,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "sed -n '1,160p' /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/config/make.def" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 9ms:
#---------------------------------------------------------------------------
#
#                SITE- AND/OR PLATFORM-SPECIFIC DEFINITIONS. 
#
#---------------------------------------------------------------------------

#---------------------------------------------------------------------------
# Items in this file will need to be changed for each platform.
#---------------------------------------------------------------------------

#---------------------------------------------------------------------------
# Parallel Fortran:
#
# For CG, EP, FT, MG, LU, SP and BT, which are in Fortran, the following must 
# be defined:
#
# F77        - Fortran compiler
# FFLAGS     - Fortran compilation arguments
# F_INC      - any -I arguments required for compiling Fortran 
# FLINK      - Fortran linker

thinking
**Planning custom Makefile for nvc++**

I'm deciding to create a separate Makefile.nvc that overrides compiler settings for nvc++ while including the original Makefile, ensuring proper flags for OpenMP GPU offloading without altering main config files. Next, I'll verify variable override order to avoid config/make.def overwriting these settings.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a79e0f239378220724f3f2c92863a889d91c67fc
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +383,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +485,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +577,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +593,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +682,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +702,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +791,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +811,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +900,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +920,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1014,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1030,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1124,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1144,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1153,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'rg "CFLAGS" -n /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/config/make.def' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 29ms:
64:# CFLAGS     - C compilation arguments
70:# compilations are done with $(CC) $(C_INC) $(CFLAGS) or
71:#                            $(CC) $(CFLAGS)
81:    CFLAGS = -O3 -fp-model fast -fno-alias -fiopenmp -fopenmp-targets=spir64 -mcmodel=medium -Wl,--no-relax
90:    CFLAGS = -mp=gpu -gpu=cc80,fastmath -O3 -Minfo=accel -Msafeptr -mcmodel=medium -Wl,--no-relax
99:    #CFLAGS = -mp
100:    CFLAGS = -mp=gpu -gpu=cc70,fastmath -O3 -Minfo=accel -Msafeptr -mcmodel=medium -Wl,--no-relax
111:    CFLAGS = -O3 -fopenmp -fopenmp-targets=nvptx64 --cuda-gpu-arch=sm_80 -mcmodel=medium
120:    CFLAGS = -O3 -fopenmp -fopenmp-targets=spir64 -march=native -mcmodel=medium
131:CFLAGS = -accdfa -fopenacc -mcmodel=medium -nvcc,-arch=sm_35,-fmad=false -nvpath,/opt/cuda/5.5/bin/ 
139:CFLAGS = -acc -ta=nvidia,cc80,ptxinfo,fastmath -Minfo=accel -Msafeptr -O3 -mcmodel=medium
150:CFLAGS = 
159:CFLAGS = -O3 -mcmodel=large -fopenacc -foffload=nvptx-none -ffast-math
168:CFLAGS = -O3 -mcmodel=medium
177:    CFLAGS = -fopenacc -fopenmp-targets=nvptx64-nvidia-cuda --cuda-gpu-arch=sm_80 -O3 -mcmodel=medium
186:    CFLAGS = -O3 
199:    CFLAGS = -O3 -mp=gpu -gpu=ccall -Minfo=accel -mcmodel=medium
208:    CFLAGS ?= -O3 -mp=gpu -gpu=ccall -Minfo=accel -mcmodel=medium
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a79e0f239378220724f3f2c92863a889d91c67fc
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +383,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +485,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +577,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +593,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +682,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +702,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +791,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +811,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +900,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +920,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1014,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1030,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1124,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1144,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1153,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "sed -n '160,240p' /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/config/make.def" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 8ms:
CLINK = gcc
CLINKFLAGS = -O3 -mcmodel=large -fopenacc -foffload=nvptx-none -foffload=-lm -ffast-math
UCC = gcc
endif

# Intel compiler
ifeq ($(CCC), icc)
CC = icc
CFLAGS = -O3 -mcmodel=medium
CLINK = icc
CLINKFLAGS = -O3 -mcmodel=medium
UCC = icc
endif

# CLACC compiler for NVIDIA A100 (no s2s)
ifeq ($(CCC), clacc-a100)
    CC = /home/yonif/LIGHTBITS/llvm-project/install/bin/clang
    CFLAGS = -fopenacc -fopenmp-targets=nvptx64-nvidia-cuda --cuda-gpu-arch=sm_80 -O3 -mcmodel=medium
    CLINK = $(CC)
    CLINKFLAGS = -fopenacc -fopenmp-targets=nvptx64-nvidia-cuda --cuda-gpu-arch=sm_80 -O3 -mcmodel=medium

thinking
**Creating wrapper Makefile for nvc++**

Decided to create a Makefile.nvc that sets the compiler variable to nvc++ and then includes the main Makefile to ensure the right flags are used; next I'll add this file via a patch with a brief comment.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a79e0f239378220724f3f2c92863a889d91c67fc
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +383,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +485,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +577,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +593,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +682,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +702,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +791,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +811,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +900,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +920,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1014,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1030,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1124,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1144,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1153,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
A /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
CCC = nvcpp
include Makefile
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
A data/src/ft-omp/Makefile.nvc
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a79e0f239378220724f3f2c92863a889d91c67fc
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +383,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +485,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +577,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +593,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +682,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +702,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +791,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +811,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +900,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +920,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1014,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1030,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1124,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1144,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1153,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Rerunning clean with updated file**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a79e0f239378220724f3f2c92863a889d91c67fc
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +383,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +485,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +577,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +593,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +682,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +702,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +791,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +811,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +900,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +920,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1014,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1030,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1124,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1144,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1153,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp succeeded in 10ms:
rm -f *.x *.i *.B *.spin *.s *.t *.w2c.c *.w2c.h *.w2c.cu *.ptx *.o *~ mputil* ../common/*.o
rm -f ft npbparams.h core
if [ -d rii_files ]; then rm -r rii_files; fi

thinking
**Planning specific build invocation**

I need to build using a custom make command specifying the compiler and class; next, I'll implement or run `make -f Makefile.nvc CC=nvc++ CLASS=B` accordingly.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a79e0f239378220724f3f2c92863a889d91c67fc
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +383,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +485,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +577,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +593,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +682,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +702,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +791,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +811,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +900,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +920,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1014,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1030,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1124,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1144,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1153,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc CC=nvc++ CLASS=B' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp exited 2 in 14.39s:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams ft B && mv npbparams.h ..
nvc++  -c -Icommon -O3 -mp=gpu -gpu=ccall -Minfo=accel -mcmodel=medium ft.c
"ft.c", line 218: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
    print_results("FT", Class, NX, NY, NZ, niter,
                  ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"ft.c", line 219: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  total_time, mflops, "          floating point", verified, 
                                      ^

"ft.c", line 220: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);
                  ^

"ft.c", line 220: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);

thinking
**Reverting device computation to host**

Planning to remove target teams from compute_indexmap to avoid compiler bug with exp inside device map tofrom; instead, run compute_indexmap on host with simple loops and rely on explicit target update to sync twiddle to device.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a79e0f239378220724f3f2c92863a889d91c67fc
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -366,24 +383,24 @@
 {
   int i, j, k, kk, kk2, jj, kj2, ii;
   double ap;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
+#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +485,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +577,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +593,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +682,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +702,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +791,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +811,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +900,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +920,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1014,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1030,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1124,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1144,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1153,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -385,3 +385,2 @@
   double ap;
-  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
@@ -389,3 +388,2 @@
 
-#pragma omp target teams loop collapse(3) map(tofrom: twiddle[0:total])
   for (k = 0; k < d3; k++) {
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Recleaning build due to unclear rebuild state**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp succeeded in 18ms:
rm -f *.x *.i *.B *.spin *.s *.t *.w2c.c *.w2c.h *.w2c.cu *.ptx *.o *~ mputil* ../common/*.o
rm -f ft npbparams.h core
if [ -d rii_files ]; then rm -r rii_files; fi

thinking
**Triggering rebuild**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc CC=nvc++ CLASS=B' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp exited 2 in 13.58s:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams ft B && mv npbparams.h ..
nvc++  -c -Icommon -O3 -mp=gpu -gpu=ccall -Minfo=accel -mcmodel=medium ft.c
"ft.c", line 218: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
    print_results("FT", Class, NX, NY, NZ, niter,
                  ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"ft.c", line 219: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  total_time, mflops, "          floating point", verified, 
                                      ^

"ft.c", line 220: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);
                  ^

"ft.c", line 220: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);

thinking
**Diagnosing device code generation issue**

The error likely arises because `compute_indexmap` uses `exp` yet is compiled for GPU due to being called within a target data region or because of automatic offloading with `-mp=gpu`. Despite no explicit target directive, the compiler generates device code for it, causing undefined device symbol errors. Next, I'll consider isolating or annotating `compute_indexmap` to control device compilation or adjust compile flags to prevent unwanted GPU code generation.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'rg "exp" data/src/ft-omp/ft.c' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 9ms:
static double ipow46(double a, int exponent);
static double ipow46(double a, int exponent)
  if (exponent == 0) return result;
  n = exponent;
        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));

thinking
**Analyzing GPU compile error causes**

I'm dissecting why a function using `exp` triggers device compile errors, exploring OpenMP pragmas to restrict device compilation (like `device_type(host)`) and considering compiler flags to avoid optimization bugs or device code generation from `exp`. Next, I'll try rebuilding with adjusted flags like `-O2` and specific GPU compute capability to bypass the error.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp succeeded in 11ms:
rm -f *.x *.i *.B *.spin *.s *.t *.w2c.c *.w2c.h *.w2c.cu *.ptx *.o *~ mputil* ../common/*.o
rm -f ft npbparams.h core
if [ -d rii_files ]; then rm -r rii_files; fi

thinking
**Running make with custom compiler flags**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "make -f Makefile.nvc CC=nvc++ CLASS=B CFLAGS='-mp=gpu -gpu=cc90 -O2 -mcmodel=medium' CLINKFLAGS='-mp=gpu -gpu=cc90 -O2 -mcmodel=medium'" in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp exited 2 in 1.54s:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams ft B && mv npbparams.h ..
nvc++  -c -Icommon -mp=gpu -gpu=cc90 -O2 -mcmodel=medium ft.c
"ft.c", line 218: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
    print_results("FT", Class, NX, NY, NZ, niter,
                  ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"ft.c", line 219: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  total_time, mflops, "          floating point", verified, 
                                      ^

"ft.c", line 220: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);
                  ^

"ft.c", line 220: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);

thinking
**Diagnosing device linker and compile issues**

The failure may arise from device code generation for functions like compute_indexmap referencing device math `exp` or `twiddle` without proper device declarations or linking, possibly triggering an nvc++ device linking bug; next I'll try adding `-gpu=nordc` to disable separate device linking and test if that resolves the problem.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp succeeded in 10ms:
rm -f *.x *.i *.B *.spin *.s *.t *.w2c.c *.w2c.h *.w2c.cu *.ptx *.o *~ mputil* ../common/*.o
rm -f ft npbparams.h core
if [ -d rii_files ]; then rm -r rii_files; fi

thinking
**Building with specified GPU targets**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "make -f Makefile.nvc CC=nvc++ CLASS=B CFLAGS='-mp=gpu -gpu=cc90,nordc -O2 -mcmodel=medium' CLINKFLAGS='-mp=gpu -gpu=cc90,nordc -O2 -mcmodel=medium'" in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp exited 2 in 1.52s:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams ft B && mv npbparams.h ..
nvc++  -c -Icommon -mp=gpu -gpu=cc90,nordc -O2 -mcmodel=medium ft.c
"ft.c", line 218: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
    print_results("FT", Class, NX, NY, NZ, niter,
                  ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"ft.c", line 219: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  total_time, mflops, "          floating point", verified, 
                                      ^

"ft.c", line 220: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);
                  ^

"ft.c", line 220: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);

thinking
**Investigating compile error causes**

I'm analyzing whether the error is due to the use of `exp` inside device code referencing a global pointer needing `declare target`, or map clause issues with `twiddle`. I'll try inspecting the compiler's intermediate file for relevant clues to pinpoint the failure cause.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "sed -n '3535,3565p' /tmp/nvc++vZ5e-q8vofjM.ll" in /root/codex_baseline/serial_omp_nas_workdir exited 2 in 17ms:
sed: can't read /tmp/nvc++vZ5e-q8vofjM.ll: No such file or directory

thinking
**Analyzing compile error related to device `exp` use**

The compile error likely stems from `exp` being used in device code or causing device compilation attempts, possibly due to `compute_indexmap` being called inside an OpenMP target data region. I'm exploring separating `compute_indexmap` calls outside device regions to avoid requiring device `exp`, while also considering compile flag adjustments and memory mapping issues with `twiddle`.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp succeeded in 14ms:
rm -f *.x *.i *.B *.spin *.s *.t *.w2c.c *.w2c.h *.w2c.cu *.ptx *.o *~ mputil* ../common/*.o
rm -f ft npbparams.h core
if [ -d rii_files ]; then rm -r rii_files; fi

thinking
**Building with no optimizations**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "make -f Makefile.nvc CC=nvc++ CLASS=B CFLAGS='-mp=gpu -gpu=cc90 -O0 -mcmodel=medium' CLINKFLAGS='-mp=gpu -gpu=cc90 -O0 -mcmodel=medium'" in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp exited 2 in 1.31s:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams ft B && mv npbparams.h ..
nvc++  -c -Icommon -mp=gpu -gpu=cc90 -O0 -mcmodel=medium ft.c
"ft.c", line 218: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
    print_results("FT", Class, NX, NY, NZ, niter,
                  ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"ft.c", line 219: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  total_time, mflops, "          floating point", verified, 
                                      ^

"ft.c", line 220: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);
                  ^

"ft.c", line 220: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);

thinking
**Analyzing device compilation failure**

I'm suspecting device pointer issues due to mapping or missing `declare target` on key arrays like twiddle and exp; testing adding `#pragma omp declare target` and using `-gpu=cc90,keep` to preserve intermediate files for IR inspection and better error insight.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp succeeded in 10ms:
rm -f *.x *.i *.B *.spin *.s *.t *.w2c.c *.w2c.h *.w2c.cu *.ptx *.o *~ mputil* ../common/*.o
rm -f ft npbparams.h core
if [ -d rii_files ]; then rm -r rii_files; fi

thinking
**Confirming rebuild with keep**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "make -f Makefile.nvc CC=nvc++ CLASS=B CFLAGS='-mp=gpu -gpu=cc90,keep -O2 -mcmodel=medium' CLINKFLAGS='-mp=gpu -gpu=cc90,keep -O2 -mcmodel=medium'" in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp exited 2 in 1.39s:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams ft B && mv npbparams.h ..
nvc++  -c -Icommon -mp=gpu -gpu=cc90,keep -O2 -mcmodel=medium ft.c
"ft.c", line 218: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
    print_results("FT", Class, NX, NY, NZ, niter,
                  ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"ft.c", line 219: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  total_time, mflops, "          floating point", verified, 
                                      ^

"ft.c", line 220: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);
                  ^

"ft.c", line 220: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);

thinking
**Searching for recent output files**

I'm looking for any recently generated files matching `ft.nvc++*.ll` in the current directory or nearby to inspect compiler outputs for clues.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'ls /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp | head' in /root/codex_baseline/serial_omp_nas_workdir succeeded in 19ms:
Makefile
Makefile.nvc
c_timers.c
c_timers.llvm
common
config
ft.c
ft.n001.cubin
ft.n001.fatbin
ft.n001.gpu

thinking
**Inspecting GPU file for PTX content**

Considering checking the .gpu file to see if it contains instructions or PTX code, though it might not be necessary; planning to examine its tail to confirm.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "sed -n '3500,3560p' /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.n001.gpu" in /root/codex_baseline/serial_omp_nas_workdir succeeded in 8ms:
    %li130 = load i8*, i8** %li130_0_0, !dbg !240
    %li146 = getelementptr i8, i8* %li130, i64 %li103, !dbg !240
    %li147_t0 = bitcast i8* %li146 to double*, !dbg !240
    store double %li129, double* %li147_t0 , !dbg !240
    %li6130 = load i32, i32* %lsym55__6_p0, !dbg !240

    %li4150_2 = load i32, i32* %lsym171__6_0, !dbg !240
    %li6139 = add i32 %li6130, %li4150_2, !dbg !240
    %li6140 = add i32 %li6139, 1, !dbg !240
    store i32 %li6140, i32* %lsym171__6_0 , align 4, !dbg !240

    %li4149_2 = load i32, i32* %lsym172__6_0, !dbg !240
    %li4125 = add i32 %li4149_2, 512, !dbg !240
    store i32 %li4125, i32* %lsym172__6_0 , align 4, !dbg !240

    %li4130 = load i32, i32* %lsym173__6_0, !dbg !240
    %li4131 = sub i32 %li4130, 1, !dbg !240
    store i32 %li4131, i32* %lsym173__6_0 , align 4, !dbg !240
    %li4155 = load i32, i32* %lsym173__6_0, !dbg !240
    %li63_0 = icmp sgt i32 %li4155, 0, !dbg !238

thinking
**Searching for expdev in GPU code**

I'm looking for references to "expdev" in the GPU code to locate related definitions or uses that might clarify the source of the pointer compile error near line 1600.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'rg "expdev" -n /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.n001.gpu' in /root/codex_baseline/serial_omp_nas_workdir exited 1 in 12ms:


thinking
**Searching for export statements**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'rg "exp" -n /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.n001.gpu' in /root/codex_baseline/serial_omp_nas_workdir exited 1 in 12ms:


thinking
**Exploring compiler bug causes around exp and device code**

The likely error arises from the compiler generating a device version of compute_indexmap that calls exp, causing problematic symbols like expdev.addr; possible fixes include isolating compute_indexmap to host-only compilation via pragmas or separate files, avoiding device compilation of exp calls, or restructuring twiddle from static globals to parameters to reduce device linkage.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp succeeded in 11ms:
rm -f *.x *.i *.B *.spin *.s *.t *.w2c.c *.w2c.h *.w2c.cu *.ptx *.o *~ mputil* ../common/*.o
rm -f ft npbparams.h core
if [ -d rii_files ]; then rm -r rii_files; fi

thinking
**Adjusting compilation flags**

I'm simplifying the compilation flags to `-mp=gpu -gpu=cc90 -O2` to streamline the build process.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "make -f Makefile.nvc CC=nvc++ CLASS=B CFLAGS='-mp=gpu -gpu=cc90 -O2' CLINKFLAGS='-mp=gpu -gpu=cc90 -O2'" in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp exited 2 in 1.39s:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams ft B && mv npbparams.h ..
nvc++  -c -Icommon -mp=gpu -gpu=cc90 -O2 ft.c
"ft.c", line 218: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
    print_results("FT", Class, NX, NY, NZ, niter,
                  ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"ft.c", line 219: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  total_time, mflops, "          floating point", verified, 
                                      ^

"ft.c", line 220: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);
                  ^

"ft.c", line 220: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);

thinking
**Exploring GPU compile issues with exp usage**

Considering that `exp` might not be properly declared for device code, I'm evaluating adding `#pragma omp declare target` to math functions or restructuring `compute_indexmap` to ensure device accessibility; also checking for potential global pointer conflicts and exploring Makefile/ compiler tweaks while reviewing generated LLVM IR for clues.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "sed -n '3538,3555p' /tmp/nvc++q9cfWR58OCsU.ll" in /root/codex_baseline/serial_omp_nas_workdir exited 2 in 8ms:
sed: can't read /tmp/nvc++q9cfWR58OCsU.ll: No such file or directory

thinking
**Testing device-exp wrapper for GPU compilation**

Considering replacing `exp` with a `device_exp` wrapper marked with `#pragma omp declare target` to ensure proper device compilation in `compute_indexmap` and related GPU target regions; planning to patch code to use this approach.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8662e27aca54c3934dd1355da1f37eee3e411077
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -170,26 +170,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +227,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +243,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +386,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +483,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +575,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +591,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +680,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +700,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +789,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +809,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +898,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +918,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1012,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1028,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1122,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1142,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1151,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -70,2 +70,6 @@
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..ee744c655ef12e4ca843de4808c27334e2832d71
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -68,6 +68,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -170,26 +174,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +231,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +247,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +390,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +487,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +579,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +595,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +684,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +704,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +793,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +813,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +902,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +922,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1016,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1032,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1126,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1146,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1155,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Updating index map to use device expression**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..ee744c655ef12e4ca843de4808c27334e2832d71
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -68,6 +68,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -170,26 +174,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +231,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +247,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +390,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
+
         twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +487,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +579,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +595,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +684,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +704,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +793,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +813,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +902,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +922,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1016,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1032,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1126,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1146,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1155,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -401,3 +401,3 @@
 
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..b7fc97b6830fd17299f98dfead7e98f646fea9ae
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -68,6 +68,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -170,26 +174,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +231,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +247,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +390,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +487,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +579,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +595,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +684,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +704,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +793,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +813,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +902,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +922,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1016,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1032,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1126,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1146,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1155,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Adjusting build flags**

Considering simplifying previous build flags by defaulting to -O2 optimization without mcmodel and possibly using -gpu=cc90 for GPU targets.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..b7fc97b6830fd17299f98dfead7e98f646fea9ae
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -68,6 +68,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -170,26 +174,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +231,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +247,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +390,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +487,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +579,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +595,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +684,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +704,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +793,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +813,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +902,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +922,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1016,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1032,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1126,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1146,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1155,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp succeeded in 10ms:
rm -f *.x *.i *.B *.spin *.s *.t *.w2c.c *.w2c.h *.w2c.cu *.ptx *.o *~ mputil* ../common/*.o
rm -f ft npbparams.h core
if [ -d rii_files ]; then rm -r rii_files; fi

thinking
**Adjusting build flags to fix GPU compilation**

I'm considering reusing previous standard flags like `-mp=gpu -gpu=cc90 -O2 -mcmodel=medium` to maintain consistency while trying to fix the build, and debating if `mcmodel` should stay in CFLAGS.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..b7fc97b6830fd17299f98dfead7e98f646fea9ae
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -68,6 +68,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -170,26 +174,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +231,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +247,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +390,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +487,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +579,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +595,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +684,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +704,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +793,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +813,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +902,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +922,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1016,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1032,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1126,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1146,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1155,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "make -f Makefile.nvc CC=nvc++ CLASS=B CFLAGS='-mp=gpu -gpu=cc90 -O2 -mcmodel=medium' CLINKFLAGS='-mp=gpu -gpu=cc90 -O2 -mcmodel=medium'" in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp exited 2 in 1.42s:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams ft B && mv npbparams.h ..
nvc++  -c -Icommon -mp=gpu -gpu=cc90 -O2 -mcmodel=medium ft.c
"ft.c", line 222: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
    print_results("FT", Class, NX, NY, NZ, niter,
                  ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"ft.c", line 223: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  total_time, mflops, "          floating point", verified, 
                                      ^

"ft.c", line 224: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);
                  ^

"ft.c", line 224: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);

thinking
**Analyzing device compilation issues with exp usage**

Exploring that device compilation errors likely stem from using `exp` within device code and automatic device compilation of functions referencing device-declared targets; considering separating compute_indexmap into a host-only file compiled without GPU support or switching to unified shared memory to avoid explicit mapping and device math library linking issues. Next, I'll test adding `#pragma omp requires unified_shared_memory` and removing target data region and map clauses to simplify device data handling and possibly fix the compile errors.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..b7fc97b6830fd17299f98dfead7e98f646fea9ae
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -68,6 +68,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -170,26 +174,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +231,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +247,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +390,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +487,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +579,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +595,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +684,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +704,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +793,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +813,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +902,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +922,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1016,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1032,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1126,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1146,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1155,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -19,2 +19,4 @@
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a01cc9143d50f6a53b5b38eb16f331ed6bbd0543
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -170,26 +176,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +233,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +249,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +392,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +489,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +581,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +597,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +686,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +706,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +795,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +815,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +904,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +924,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1018,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1034,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1128,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1148,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1157,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Removing target data block**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a01cc9143d50f6a53b5b38eb16f331ed6bbd0543
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -170,26 +176,37 @@
   compute_initial_conditions(dims[0], dims[1], dims[2]);
 
   fft_init(dims[0]);
-  fft(1);
+#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
+                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
+                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
+  {
+    fft(1);
 
-  for (i = 1; i <= T_max; i++) {
-    timer_clear(i);
-  }
+    for (i = 1; i <= T_max; i++) {
+      timer_clear(i);
+    }
 
-  timer_start(T_total);
-  if (timers_enabled) timer_start(T_setup);
+    timer_start(T_total);
+    if (timers_enabled) timer_start(T_setup);
 
-  compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_indexmap(dims[0], dims[1], dims[2]);
+    compute_initial_conditions(dims[0], dims[1], dims[2]);
+    fft_init(dims[0]);
 
-  compute_initial_conditions(dims[0], dims[1], dims[2]);
+#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
+                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
+                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
+    fft(1);
+    for (iter = 1; iter <= niter; iter++) {
+      evolve(dims[0], dims[1], dims[2]);
+      fft(-1);
 
-  fft_init(dims[0]);
-  fft(1);
-  for (iter = 1; iter <= niter; iter++) {
-    evolve(dims[0], dims[1], dims[2]);
-    fft(-1);
+      checksum(iter, dims[0], dims[1], dims[2]);
+    }
 
-    checksum(iter, dims[0], dims[1], dims[2]);
+#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
   }
 
   verify(NX, NY, NZ, niter, &verified, &Class);
@@ -216,8 +233,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +249,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +392,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +489,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +581,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +597,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +686,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +706,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +795,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +815,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +904,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +924,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1018,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1034,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1128,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1148,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1157,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -178,33 +178,20 @@
   fft_init(dims[0]);
-#pragma omp target data map(tofrom: u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
-                                   u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
-                                   twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP]) \
-                        map(alloc: gty1_real[0:MAXDIM*MAXDIM*MAXDIM], gty1_imag[0:MAXDIM*MAXDIM*MAXDIM], \
-                                   gty2_real[0:MAXDIM*MAXDIM*MAXDIM], gty2_imag[0:MAXDIM*MAXDIM*MAXDIM])
-  {
-    fft(1);
-
-    for (i = 1; i <= T_max; i++) {
-      timer_clear(i);
-    }
+  fft(1);
 
-    timer_start(T_total);
-    if (timers_enabled) timer_start(T_setup);
-
-    compute_indexmap(dims[0], dims[1], dims[2]);
-    compute_initial_conditions(dims[0], dims[1], dims[2]);
-    fft_init(dims[0]);
+  for (i = 1; i <= T_max; i++) {
+    timer_clear(i);
+  }
 
-#pragma omp target update to(u0_real[0:NTOTALP], u0_imag[0:NTOTALP], \
-                              u1_real[0:NTOTALP], u1_imag[0:NTOTALP], \
-                              twiddle[0:NTOTALP], u_real[0:NXP], u_imag[0:NXP])
-    fft(1);
-    for (iter = 1; iter <= niter; iter++) {
-      evolve(dims[0], dims[1], dims[2]);
-      fft(-1);
+  timer_start(T_total);
+  if (timers_enabled) timer_start(T_setup);
 
-      checksum(iter, dims[0], dims[1], dims[2]);
-    }
+  compute_indexmap(dims[0], dims[1], dims[2]);
+  compute_initial_conditions(dims[0], dims[1], dims[2]);
+  fft_init(dims[0]);
+  fft(1);
+  for (iter = 1; iter <= niter; iter++) {
+    evolve(dims[0], dims[1], dims[2]);
+    fft(-1);
 
-#pragma omp target update from(u1_real[0:NTOTALP], u1_imag[0:NTOTALP])
+    checksum(iter, dims[0], dims[1], dims[2]);
   }
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..0d56a9ef26cd31adab8792f8c8073796f14959bb
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +236,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +379,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +476,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +568,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +584,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +673,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +693,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +782,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +802,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +891,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +911,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1005,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1021,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1115,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1135,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1144,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Removing map clauses from target loops**

I'm removing the map clause from the target loops, starting with the init_ui function.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..0d56a9ef26cd31adab8792f8c8073796f14959bb
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +236,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +379,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +476,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +568,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +584,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +673,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +693,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +782,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +802,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +891,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +911,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1005,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1021,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1115,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1135,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1144,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..0d56a9ef26cd31adab8792f8c8073796f14959bb
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +236,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +379,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +476,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +568,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +584,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +673,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +693,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +782,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +802,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +891,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +911,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1005,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1021,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1115,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1135,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1144,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Adjusting pragma for target teams loop**

I'm removing the `map` clause while keeping the `target teams loop` construct and adding `collapse(3)` to combine nested loops in the OpenMP pragma.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..0d56a9ef26cd31adab8792f8c8073796f14959bb
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,11 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +236,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +379,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +476,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +568,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +584,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +673,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +693,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +782,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +802,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +891,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +911,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1005,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1021,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1115,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1135,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1144,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -224,5 +224,3 @@
 
-#pragma omp target teams loop collapse(3) map(tofrom: u0_real[0:total], u0_imag[0:total], \
-                                                     u1_real[0:total], u1_imag[0:total], \
-                                                     twiddle[0:total])
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
apply_patch(auto_approved=true) exited 0 in 27ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..da432d72d35d597cf013ac71dcddedcc7d04698e
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +377,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +582,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +671,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +691,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +780,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +800,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +889,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +909,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1003,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1019,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1113,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1133,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1142,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Refactoring map, present, remove methods**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..da432d72d35d597cf013ac71dcddedcc7d04698e
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,29 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                      u1_real[0:total], u1_imag[0:total], \
+                                                      twiddle[0:total])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +377,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +474,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +566,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +582,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +671,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +691,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +780,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +800,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +889,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +909,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1003,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1019,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1113,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1133,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1142,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -244,5 +244,3 @@
 
-#pragma omp target teams loop collapse(3) map(present: u0_real[0:total], u0_imag[0:total], \
-                                                      u1_real[0:total], u1_imag[0:total], \
-                                                      twiddle[0:total])
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..68f38b43f503921d5fb77a9ee4fb0d6edcc6d328
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,27 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +375,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +472,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +564,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +580,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +669,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +689,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +778,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +798,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +887,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +907,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1001,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1017,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1111,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1131,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1140,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Cleaning up parallelization pragmas**

I'm removing the cffts1_pos map directive and leaving only the target teams loop collapse pragma, then applying the same cleanup to other cffts files.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..68f38b43f503921d5fb77a9ee4fb0d6edcc6d328
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,27 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +375,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +472,13 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +564,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +580,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +669,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +689,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +778,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +798,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +887,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +907,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +1001,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1017,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1111,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1131,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1140,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -477,6 +477,3 @@
 
-#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
-                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
-                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
-                                                     u_real[0:NXP], u_imag[0:NXP])
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..244da7eb58940eac0007c263dc07bf5fc1d12b41
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,27 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +375,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +472,10 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +561,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +577,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +666,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +686,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +775,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +795,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +884,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +904,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +998,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1014,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1108,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1128,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1137,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Noticing similar loop patterns**

I see that functions like cffts1_neg share similar target loops, suggesting potential for consolidating or reusing loop logic.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..244da7eb58940eac0007c263dc07bf5fc1d12b41
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,27 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +375,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +472,10 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +561,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +577,13 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +666,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +686,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +775,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +795,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +884,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +904,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +998,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1014,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1108,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1128,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1137,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -582,6 +582,3 @@
   
-#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
-                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
-                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
-                                                     u_real[0:NXP], u_imag[0:NXP])
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..0b49bb9c41d8e1959785f1e6baa44d6d642385d3
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,27 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +375,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +472,10 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +561,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +577,10 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +663,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +683,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +772,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +792,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +881,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +901,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +995,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1011,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1105,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1125,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1134,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Identifying FFT files**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..0b49bb9c41d8e1959785f1e6baa44d6d642385d3
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,27 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +375,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +472,10 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +561,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +577,10 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +663,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +683,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +772,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +792,13 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +881,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +901,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +995,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1011,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1105,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1125,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1134,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -688,6 +688,3 @@
 
-#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
-                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
-                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
-                                                     u_real[0:NXP], u_imag[0:NXP])
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
@@ -797,6 +794,3 @@
 
-#pragma omp target teams loop collapse(2) map(present: u1_real[0:total], u1_imag[0:total], \
-                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
-                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
-                                                     u_real[0:NXP], u_imag[0:NXP])
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..c86e0015e42509e863941d5e3504a4de4d6aa713
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,27 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +375,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +472,10 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +561,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +577,10 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +663,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +683,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +769,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +789,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +875,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +895,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +989,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1005,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1099,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1119,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1128,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Cleaning up FFT code by removing map**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..c86e0015e42509e863941d5e3504a4de4d6aa713
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,27 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +375,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +472,10 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +561,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +577,10 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +663,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +683,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +769,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +789,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +875,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +895,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +989,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1005,14 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
+                                                     u1_real[0:total], u1_imag[0:total], \
+                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
+                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
+                                                     u_real[0:NXP], u_imag[0:NXP])
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1099,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1119,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1128,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -900,7 +900,3 @@
 
-#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
-                                                     u1_real[0:total], u1_imag[0:total], \
-                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
-                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
-                                                     u_real[0:NXP], u_imag[0:NXP])
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
@@ -1010,7 +1006,3 @@
 
-#pragma omp target teams loop collapse(2) map(present: u0_real[0:total], u0_imag[0:total], \
-                                                     u1_real[0:total], u1_imag[0:total], \
-                                                     gty1_real[0:gsize], gty1_imag[0:gsize], \
-                                                     gty2_real[0:gsize], gty2_imag[0:gsize], \
-                                                     u_real[0:NXP], u_imag[0:NXP])
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..6b9950e0eb51cb64eaef26d0307839c5571ad0e0
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,27 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +375,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +472,10 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +561,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +577,10 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +663,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +683,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +769,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +789,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +875,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +895,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +985,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1001,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1091,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1111,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1120,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Removing checksum map**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..6b9950e0eb51cb64eaef26d0307839c5571ad0e0
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,27 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +375,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +472,10 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +561,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +577,10 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +663,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +683,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +769,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +789,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +875,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +895,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +985,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1001,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1091,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1111,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1120,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -1122,3 +1122,3 @@
 
-#pragma omp target teams loop reduction(+:temp1, temp2) map(present: u1_real[0:total], u1_imag[0:total])
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
apply_patch(auto_approved=true) exited 0 in 20ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..c764a9da7f299f7ae257158676ac617d171170bf
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,27 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +375,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +472,10 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +561,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +577,10 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +663,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +683,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +769,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +789,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +875,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +895,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +985,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1001,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1091,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1111,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1120,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Confirming cleanup and build steps**

I've identified some possibly unnecessary target data maps and declarations but confirmed key includes and macros are still needed. I'll clean the build to ensure changes apply correctly before rebuilding.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..c764a9da7f299f7ae257158676ac617d171170bf
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,27 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +375,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +472,10 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +561,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +577,10 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +663,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +683,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +769,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +789,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +875,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +895,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +985,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1001,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1091,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1111,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1120,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp succeeded in 32ms:
rm -f *.x *.i *.B *.spin *.s *.t *.w2c.c *.w2c.h *.w2c.cu *.ptx *.o *~ mputil* ../common/*.o
rm -f ft npbparams.h core
if [ -d rii_files ]; then rm -r rii_files; fi

thinking
**Choosing default build flags**

I'm deciding to avoid overriding CFLAGS and instead use defaults from make.def, running `make -f Makefile.nvc CC=nvc++ CLASS=B` without extra flags to bypass prior bugs.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..c764a9da7f299f7ae257158676ac617d171170bf
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,27 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +375,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +472,10 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +561,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +577,10 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +663,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +683,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +769,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +789,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +875,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +895,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +985,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1001,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1091,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1111,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1120,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc CC=nvc++ CLASS=B' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp exited 2 in 461ms:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams ft B && mv npbparams.h ..
nvc++  -c -Icommon -O3 -mp=gpu -gpu=ccall -Minfo=accel -mcmodel=medium ft.c
"ft.c", line 211: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
    print_results("FT", Class, NX, NY, NZ, niter,
                  ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"ft.c", line 212: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  total_time, mflops, "          floating point", verified, 
                                      ^

"ft.c", line 213: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);
                  ^

"ft.c", line 213: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);

thinking
**Removing unused total/gsize variables**

I'm preparing to clean warnings by removing unused total and gsize declarations across functions, updating CFLAGS to include unified GPU flags, and adjusting Makefile settings accordingly. I'll apply patches to remove these unused size_t lines before modifying compiler flags.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..c764a9da7f299f7ae257158676ac617d171170bf
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -216,8 +220,9 @@
 static void init_ui(int d1, int d2, int d3)
 {
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,26 +234,27 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
 {
 	
   int i, j, k;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +375,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +472,10 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +561,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +577,10 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +663,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +683,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +769,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +789,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +875,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +895,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +985,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +1001,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1091,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1111,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1120,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -222,3 +222,2 @@
   int i, j, k;
-  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
@@ -242,3 +241,2 @@
   int i, j, k;
-  const size_t total = (size_t)d3 * d2 * (d1 + 1);
 
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8c914379874107f4ceaedfd4dceea49c624f1307
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +221,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +233,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +240,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +373,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +470,10 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +559,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +575,10 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +661,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +681,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +767,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +787,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +873,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +893,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +983,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +999,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1089,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1109,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1118,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Removing total/gsize in cffts sections**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..8c914379874107f4ceaedfd4dceea49c624f1307
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +221,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +233,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +240,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +373,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -468,8 +470,10 @@
   double temp_imag, temp2_imag;
 
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +559,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -572,8 +575,10 @@
   double temp_imag, temp2_imag;
   
   logd1 = ilog2(d1);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +661,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +681,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +767,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +787,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +873,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +893,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +983,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +999,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1089,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1109,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1118,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -472,4 +472,2 @@
   logd1 = ilog2(d1);
-  const size_t total = (size_t)d3 * d2 * (d1 + 1);
-  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
@@ -577,4 +575,2 @@
   logd1 = ilog2(d1);
-  const size_t total = (size_t)d3 * d2 * (d1 + 1);
-  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
   
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..94c94954617f3c7be1c285727af1b8f2a876b01e
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +221,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +233,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +240,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +373,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +471,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +557,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +574,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +657,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +677,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +763,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +783,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +869,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +889,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +979,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +995,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1085,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1105,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1114,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Removing cffts2 pos/neg references**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..94c94954617f3c7be1c285727af1b8f2a876b01e
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +221,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +233,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +240,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +373,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +471,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +557,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +574,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +657,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -677,8 +677,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +763,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -782,8 +783,10 @@
   double temp_imag, temp2_imag;
 
   logd2 = ilog2(d2);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +869,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +889,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +979,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +995,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1085,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1105,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1114,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -679,4 +679,2 @@
   logd2 = ilog2(d2);
-  const size_t total = (size_t)d3 * d2 * (d1 + 1);
-  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
@@ -785,4 +783,2 @@
   logd2 = ilog2(d2);
-  const size_t total = (size_t)d3 * d2 * (d1 + 1);
-  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a6838b3a4e74b37d8f688778e508c4f029ab09f6
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +221,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +233,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +240,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +373,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +471,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +557,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +574,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +657,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +678,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +761,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +782,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +865,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +885,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +975,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +991,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1081,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1101,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1110,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Removing cffts3 dependencies**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..a6838b3a4e74b37d8f688778e508c4f029ab09f6
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +221,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +233,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +240,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +373,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +471,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +557,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +574,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +657,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +678,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +761,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +782,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +865,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -887,8 +885,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +975,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -992,8 +991,10 @@
   double temp_imag, temp2_imag;
 
   logd3 = ilog2(d3);
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
+  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1081,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1101,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1110,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -887,4 +887,2 @@
   logd3 = ilog2(d3);
-  const size_t total = (size_t)d3 * d2 * (d1 + 1);
-  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
@@ -993,4 +991,2 @@
   logd3 = ilog2(d3);
-  const size_t total = (size_t)d3 * d2 * (d1 + 1);
-  const size_t gsize = (size_t)MAXDIM * MAXDIM * MAXDIM;
 
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..3a34e6f0181cafc3405c4fe1b630ed5dcb12dcc9
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +221,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +233,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +240,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +373,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +471,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +557,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +574,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +657,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +678,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +761,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +782,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +865,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -888,7 +886,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +973,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -993,7 +990,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1077,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1097,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1106,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Removing total checksum**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..3a34e6f0181cafc3405c4fe1b630ed5dcb12dcc9
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +221,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +233,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +240,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +373,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +471,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +557,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +574,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +657,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +678,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +761,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +782,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +865,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -888,7 +886,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +973,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -993,7 +990,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1077,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1101,6 +1097,7 @@
 
   int j, q, r, s;
   double temp1,temp2;
+  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
   dcomplex chk;
   chk.real = 0.0;
@@ -1109,15 +1106,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -1099,3 +1099,2 @@
   double temp1,temp2;
-  const size_t total = (size_t)d3 * d2 * (d1 + 1);
   
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..59fd1a122a028a29a8ca7326d532ca7ef110bb7d
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +221,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +233,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +240,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +373,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +471,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +557,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +574,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +657,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +678,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +761,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +782,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +865,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -888,7 +886,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +973,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -993,7 +990,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1077,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1109,15 +1105,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Verifying device target and build flags**

Confirming device_exp still requires declared target with unified GPU compilation; adjusting build flags for optimization and minimal warnings, then cleaning for a fresh build.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..59fd1a122a028a29a8ca7326d532ca7ef110bb7d
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +221,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +233,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +240,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +373,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +471,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +557,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +574,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +657,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +678,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +761,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +782,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +865,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -888,7 +886,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +973,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -993,7 +990,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1077,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1109,15 +1105,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp succeeded in 11ms:
rm -f *.x *.i *.B *.spin *.s *.t *.w2c.c *.w2c.h *.w2c.cu *.ptx *.o *~ mputil* ../common/*.o
rm -f ft npbparams.h core
if [ -d rii_files ]; then rm -r rii_files; fi

thinking
**Rebuilding with CFLAGS set**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..59fd1a122a028a29a8ca7326d532ca7ef110bb7d
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +221,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +233,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +240,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +373,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +471,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +557,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +574,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +657,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +678,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +761,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +782,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +865,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -888,7 +886,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +973,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -993,7 +990,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1077,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1109,15 +1105,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "make -f Makefile.nvc CC=nvc++ CLASS=B CFLAGS='-O3 -mp=gpu -gpu=ccall,unified -Minfo=accel' CLINKFLAGS='-O3 -mp=gpu -gpu=ccall,unified -Minfo=accel'" in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp succeeded in 17.31s:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams ft B && mv npbparams.h ..
nvc++  -c -Icommon -O3 -mp=gpu -gpu=ccall,unified -Minfo=accel ft.c
nvc++-Warning- The -gpu=[no]unified option is deprecated; please use -gpu=mem:unified, -gpu=mem:managed or -gpu=mem:separate instead
"ft.c", line 211: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
    print_results("FT", Class, NX, NY, NZ, niter,
                  ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"ft.c", line 212: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  total_time, mflops, "          floating point", verified, 
                                      ^

"ft.c", line 213: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);
                  ^

"ft.c", line 213: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]

thinking
**Running built executable to verify**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..59fd1a122a028a29a8ca7326d532ca7ef110bb7d
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +221,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +233,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +240,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +373,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +471,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +557,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +574,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +657,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +678,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +761,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +782,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +865,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -888,7 +886,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +973,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -993,7 +990,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1077,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1109,15 +1105,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc ./ft.B.x in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp exited 1 in 123ms:
Accelerator Fatal Error: The application was compiled with -gpu=unified, but this platform does not support Unified Memory.
Please consult the NVIDIA HPC Compilers User's Guide for details.



 NAS Parallel Benchmarks (NPB3.3-ACC-C) - FT Benchmark

 Size                :  512x 256x 256
 Iterations                  :     20


thinking
**Adjusting GPU memory flags**

I'm planning to rebuild with the `-gpu=ccall,mem:managed` flag instead of `unified` due to runtime errors indicating unsupported unified memory on the platform, aiming for compatibility with managed memory.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..59fd1a122a028a29a8ca7326d532ca7ef110bb7d
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +221,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +233,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +240,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +373,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +471,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +557,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +574,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +657,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +678,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +761,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +782,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +865,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -888,7 +886,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +973,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -993,7 +990,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1077,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1109,15 +1105,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp succeeded in 14ms:
rm -f *.x *.i *.B *.spin *.s *.t *.w2c.c *.w2c.h *.w2c.cu *.ptx *.o *~ mputil* ../common/*.o
rm -f ft npbparams.h core
if [ -d rii_files ]; then rm -r rii_files; fi

thinking
**Testing unified memory support**

Trying to rebuild with GPU flags that enable managed memory to see if it satisfies the unified_shared_memory requirement, hoping managed memory counts as true unified memory.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..59fd1a122a028a29a8ca7326d532ca7ef110bb7d
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +221,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +233,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +240,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +373,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +471,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +557,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +574,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +657,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +678,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +761,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +782,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +865,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -888,7 +886,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +973,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -993,7 +990,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1077,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1109,15 +1105,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "make -f Makefile.nvc CC=nvc++ CLASS=B CFLAGS='-O3 -mp=gpu -gpu=ccall,mem:managed -Minfo=accel' CLINKFLAGS='-O3 -mp=gpu -gpu=ccall,mem:managed -Minfo=accel'" in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp exited 2 in 366ms:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams ft B && mv npbparams.h ..
nvc++  -c -Icommon -O3 -mp=gpu -gpu=ccall,mem:managed -Minfo=accel ft.c
"ft.c", line 211: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
    print_results("FT", Class, NX, NY, NZ, niter,
                  ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"ft.c", line 212: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  total_time, mflops, "          floating point", verified, 
                                      ^

"ft.c", line 213: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);
                  ^

"ft.c", line 213: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);

thinking
**Removing unified_shared_memory directive**

Removing the `#pragma omp requires unified_shared_memory` will avoid the compile error, relying instead on managed memory with explicit or optional map clauses; this should work with compiler flags using `-gpu=ccall,mem:managed`.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..59fd1a122a028a29a8ca7326d532ca7ef110bb7d
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -17,6 +17,8 @@
 #include "print_results.h"
 #include "type.h"
 
+#pragma omp requires unified_shared_memory
+
 #define FFTBLOCKPAD   33
 #define FFTBLOCK      32
 
@@ -68,6 +70,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +186,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +221,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +233,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +240,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +373,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +471,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +557,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +574,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +657,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +678,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +761,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +782,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +865,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -888,7 +886,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +973,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -993,7 +990,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1077,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1109,15 +1105,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

file update
M /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -19,4 +19,2 @@
 
-#pragma omp requires unified_shared_memory
-
 #define FFTBLOCKPAD   33
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M data/src/ft-omp/ft.c
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..ecba9f785427d0241f7b7a294cfef55346c04ae4
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -68,6 +68,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +184,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +219,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +231,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +238,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +371,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +469,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +555,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +572,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +655,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +676,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +759,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +780,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +863,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -888,7 +884,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +971,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -993,7 +988,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1075,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1109,15 +1103,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 


thinking
**Noting mem:managed build with device access**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..ecba9f785427d0241f7b7a294cfef55346c04ae4
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -68,6 +68,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +184,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +219,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +231,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +238,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +371,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +469,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +555,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +572,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +655,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +676,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +759,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +780,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +863,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -888,7 +884,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +971,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -993,7 +988,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1075,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1109,15 +1103,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc 'make -f Makefile.nvc clean' in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp succeeded in 14ms:
rm -f *.x *.i *.B *.spin *.s *.t *.w2c.c *.w2c.h *.w2c.cu *.ptx *.o *~ mputil* ../common/*.o
rm -f ft npbparams.h core
if [ -d rii_files ]; then rm -r rii_files; fi

thinking
**Setting aggressive GPU optimization flags**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..ecba9f785427d0241f7b7a294cfef55346c04ae4
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -68,6 +68,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +184,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +219,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +231,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +238,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +371,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +469,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +555,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +572,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +655,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +676,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +759,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +780,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +863,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -888,7 +884,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +971,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -993,7 +988,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1075,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1109,15 +1103,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc "make -f Makefile.nvc CC=nvc++ CLASS=B CFLAGS='-O3 -mp=gpu -gpu=ccall,mem:managed -Minfo=accel' CLINKFLAGS='-O3 -mp=gpu -gpu=ccall,mem:managed -Minfo=accel'" in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp succeeded in 16.48s:
make.def modified. Rebuilding npbparams.h just in case
rm -f npbparams.h sys/npbparams.h
cd sys && ./setparams ft B && mv npbparams.h ..
nvc++  -c -Icommon -O3 -mp=gpu -gpu=ccall,mem:managed -Minfo=accel ft.c
"ft.c", line 209: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
    print_results("FT", Class, NX, NY, NZ, niter,
                  ^

Remark: individual warnings can be suppressed with "--diag_suppress <warning-name>"

"ft.c", line 210: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  total_time, mflops, "          floating point", verified, 
                                      ^

"ft.c", line 211: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);
                  ^

"ft.c", line 211: warning: conversion from a string literal to "char *" is deprecated [deprecated_string_conv]
                  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);

thinking
**Running executable after successful build**
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..ecba9f785427d0241f7b7a294cfef55346c04ae4
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -68,6 +68,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +184,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +219,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +231,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +238,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +371,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +469,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +555,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +572,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +655,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +676,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +759,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +780,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +863,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -888,7 +884,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +971,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -993,7 +988,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1075,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1109,15 +1103,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

exec
/bin/bash -lc ./ft.B.x in /root/codex_baseline/serial_omp_nas_workdir/data/src/ft-omp succeeded in 2m 59s:


 NAS Parallel Benchmarks (NPB3.3-ACC-C) - FT Benchmark

 Size                :  512x 256x 256
 Iterations                  :     20

temp1 = 17373288914.279648temp2 = 17038281086.086506 T =    1     Checksum =    5.177643571579E+02    5.077803458597E+02
temp1 = 17295703416.023964temp2 = 17073331955.163740 T =    2     Checksum =    5.154521291263E+02    5.088249431599E+02
temp1 = 17268483850.689743temp2 = 17100039541.760582 T =    3     Checksum =    5.146409228650E+02    5.096208912659E+02
temp1 = 17254959829.360394temp2 = 17116194239.027309 T =    4     Checksum =    5.142378756213E+02    5.101023387619E+02
temp1 = 17245725352.797546temp2 = 17126103611.056089 T =    5     Checksum =    5.139626667737E+02    5.103976610618E+02
temp1 = 17238332614.652733temp2 = 17132718562.599390 T =    6     Checksum =    5.137423460082E+02    5.105948019802E+02
temp1 = 17232036450.281570temp2 = 17137604577.728292 T =    7     Checksum =    5.135547056878E+02    5.107404165783E+02
temp1 = 17226546504.262455temp2 = 17141538525.771677 T =    8     Checksum =    5.133910925467E+02    5.108576573661E+02
temp1 = 17221713927.599030temp2 = 17144896334.096001 T =    9     Checksum =    5.132470705390E+02    5.109577278523E+02
temp1 = 17217442530.930595temp2 = 17147859277.547466 T =   10     Checksum =    5.131197729984E+02    5.110460304483E+02
temp1 = 17213659568.360477temp2 = 17150517222.477198 T =   11     Checksum =    5.130070319283E+02    5.111252433800E+02
temp1 = 17210304855.803379temp2 = 17152918524.997637 T =   12     Checksum =    5.129070537032E+02    5.111968077719E+02
temp1 = 17207326384.805283temp2 = 17155093373.443613 T =   13     Checksum =    5.128182883503E+02    5.112616233064E+02

thinking
**Updating progress statuses**

Run succeeded despite incorrect compile options output, confirming step 2 and step 3 are done; now updating plan statuses accordingly.
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..ecba9f785427d0241f7b7a294cfef55346c04ae4
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -68,6 +68,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +184,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +219,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +231,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +238,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +371,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +469,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +555,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +572,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +655,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +676,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +759,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +780,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +863,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -888,7 +884,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +971,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -993,7 +988,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1075,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1109,15 +1103,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

Plan update
  ✓ Understand code structure and identify loops/arrays needing GPU offload and data lifetimes
  ✓ Apply OpenMP target data/lifetimes and offload directives using teams loop; adjust utility code as needed
  ✓ Build with make -f Makefile.nvc cleanly and run executable to confirm correctness

thinking
**Summarizing build and code changes**

The build used `make -f Makefile.nvc CC=nvc++ CLASS=B CFLAGS='-O3 -mp=gpu -gpu=ccall,mem:managed -Minfo=accel'` with `mem:managed` to enable GPU managed memory, necessary due to USM removal. The key modifications in `data/src/ft-omp/ft.c` include adding OpenMP target teams loops to `init`, `evolve`, `cffts`, and `checksum` routines, reliance on managed memory instead of explicit mapping, and introducing a `device_exp` helper. A new wrapper `Makefile.nvc` was added to simplify builds. The build and run completed successfully with verification for class B, though non-fatal warnings appeared about deprecated string literals. Optional cleaning is available but not required. Logs confirm successful build and execution with the specified compile options.
codex
Applied OpenMP GPU offload across the FT kernel with managed memory and team-based loops. Key updates:
- Added a device-visible `device_exp` helper and offloaded all heavy loops (initialization, evolution, 1D FFT stages, checksum) via `target teams loop`, relying on managed memory instead of explicit mapping (`data/src/ft-omp/ft.c`).
- Simplified data movement by removing the target data/update scaffolding; GPU accesses use managed allocations driven by OpenMP targets.
- Added a convenience `Makefile.nvc` wrapper to drive builds with the NVIDIA compiler (`data/src/ft-omp/Makefile.nvc`).

Build & run (cleaned first):
- `make -f Makefile.nvc clean`
- `make -f Makefile.nvc CC=nvc++ CLASS=B CFLAGS='-O3 -mp=gpu -gpu=ccall,mem:managed -Minfo=accel' CLINKFLAGS='-O3 -mp=gpu -gpu=ccall,mem:managed -Minfo=accel'`
- `./ft.B.x` → verification successful (Class B).

Notes: nvc++ emits benign warnings about string literal conversions and unused locals; no runtime issues observed. If you prefer, the `-gpu=ccall,mem:managed` flag can be adjusted to a specific SM (e.g., `-gpu=cc90,mem:managed`).
file update:
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
new file mode 100644
index 0000000000000000000000000000000000000000..40cebe680349fe94b0f2139b9e4681edecf8f4fa
--- /dev/null
+++ b/serial_omp_nas_workdir/data/src/ft-omp/Makefile.nvc
@@ -0,0 +1,2 @@
+CCC = nvcpp
+include Makefile
diff --git a/serial_omp_nas_workdir/data/src/ft-omp/ft.c b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
index 13651cc2cf285e33ab0ad3e19ec1cac4504a7a88..ecba9f785427d0241f7b7a294cfef55346c04ae4
--- a/serial_omp_nas_workdir/data/src/ft-omp/ft.c
+++ b/serial_omp_nas_workdir/data/src/ft-omp/ft.c
@@ -68,6 +68,10 @@
 
 #define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}
 
+#pragma omp declare target
+static inline double device_exp(double x) { return exp(x); }
+#pragma omp end declare target
+
 #define IDX3D(k, j, i) ((k) * (MAXDIM) * (MAXDIM) + (j) * (MAXDIM) + (i))
 #define GTY1_REAL(k, j, i) gty1_real[IDX3D(k, j, i)]
 #define GTY1_IMAG(k, j, i) gty1_imag[IDX3D(k, j, i)]
@@ -180,9 +184,7 @@
   if (timers_enabled) timer_start(T_setup);
 
   compute_indexmap(dims[0], dims[1], dims[2]);
-
   compute_initial_conditions(dims[0], dims[1], dims[2]);
-
   fft_init(dims[0]);
   fft(1);
   for (iter = 1; iter <= niter; iter++) {
@@ -217,7 +219,7 @@
 {
   int i, j, k;
 
- {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
@@ -229,7 +231,6 @@
       }
     }
   }
- }
 }
 
 static void evolve(int d1, int d2, int d3)
@@ -237,18 +238,19 @@
 	
   int i, j, k;
 
-  {
+#pragma omp target teams loop collapse(3)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
-	u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
+        const size_t idx = (size_t)k*d2*(d1+1) + j*(d1+1) + i;
+        const double tw = twiddle[idx];
+        u0_real[idx] = u0_real[idx] * tw;
+        u0_imag[idx] = u0_imag[idx] * tw;
+        u1_real[idx] = u0_real[idx];
+        u1_imag[idx] = u0_imag[idx];
       }
     }
   }
- } 
 }
 
 static void compute_initial_conditions(int d1, int d2, int d3)
@@ -369,21 +371,19 @@
 
   ap = -4.0 * ALPHA * PI * PI;
 
-{
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
-    	kk = ((k + NZ/2) % NZ) - NZ/2;
-    	kk2 = kk*kk;
-      	jj = ((j + NY/2) % NY) - NY/2;
-      	kj2 = jj*jj + kk2;
+        kk = ((k + NZ/2) % NZ) - NZ/2;
+        kk2 = kk*kk;
+        jj = ((j + NY/2) % NY) - NY/2;
+        kj2 = jj*jj + kk2;
         ii = ((i + NX/2) % NX) - NX/2;
-        
-        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
+
+        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = device_exp(ap * (double)(ii*ii+kj2));
       }
     }
   }
- }
 }
 
 static void print_timers()
@@ -469,7 +469,7 @@
 
   logd1 = ilog2(d1);
 
- {
+#pragma omp target teams loop collapse(2)
   for (k = 0; k < d3; k++) {
     for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -555,7 +555,6 @@
         }
     }
   }
- }
 }
 
 static void cffts1_neg(int is, int d1, int d2, int d3)
@@ -573,7 +572,7 @@
   
   logd1 = ilog2(d1);
   
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (j = 0; j < d2; j++) {
         for (i = 0; i < d1; i++) {
@@ -656,11 +655,10 @@
 
         for (i = 0; i < d1; i++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, i, j);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, i, j);
         }
       }
     }
-  }
 }
 
 static void cffts2_pos(int is, int d1, int d2, int d3)
@@ -678,7 +676,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -761,11 +759,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts2_neg(int is, int d1, int d2, int d3)
@@ -783,7 +780,7 @@
 
   logd2 = ilog2(d2);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (k = 0; k < d3; k++) {
       for (i = 0; i < d1; i++) {
         for (j = 0; j < d2; j++) {
@@ -866,11 +863,10 @@
 
         for (j = 0; j < d2; j++) {
           u1_real[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_REAL(k, j, i);
-          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
+        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = GTY1_IMAG(k, j, i);
         }
       }
     }
-  }
 }
 
 static void cffts3_pos(int is, int d1, int d2, int d3)
@@ -888,7 +884,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -975,7 +971,6 @@
         }
       }
     }
-  }
 }
 
 static void cffts3_neg(int is, int d1, int d2, int d3)
@@ -993,7 +988,7 @@
 
   logd3 = ilog2(d3);
 
-  {
+#pragma omp target teams loop collapse(2)
     for (j = 0; j < d2; j++) {
       for (i = 0; i < d1; i++) {
         for (k = 0; k < d3; k++) {
@@ -1080,7 +1075,6 @@
         }
       }
     }
-  }
 }
 
 static int ilog2(int n)
@@ -1109,15 +1103,14 @@
   temp1 = 0.0;
   temp2 = 0.0;
 
-{
+#pragma omp target teams loop reduction(+:temp1, temp2)
     for (j = 1; j <= 1024; j++) {
       q = j % NX;
       r = 3*j % NY;
       s = 5*j % NZ;
-	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
-	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
+      temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
+      temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
     }
-}
 	 chk.real = temp1;
 	 chk.imag = temp2;
 

tokens used
880,104