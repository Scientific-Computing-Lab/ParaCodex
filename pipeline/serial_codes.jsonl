// {"kernel_name": "atomicCost", "parallel_api": "serial", "code": {"main.cpp": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <chrono>\n\n#define BLOCK_SIZE 256\n\n\n\ntemplate <typename T>\nvoid woAtomicOnGlobalMem(T* result, int size, int n)\n{\n    for (unsigned int tid = 0; tid < n; tid++) {\n    for ( unsigned int i = tid * size; i < (tid + 1) * size; i++) {\n      result[tid] += i % 2;\n    }\n  }\n}\n\n\n\ntemplate <typename T>\nvoid wiAtomicOnGlobalMem(T* result, int size, int n)\n{\n    for (unsigned int tid = 0; tid < n; tid++) {\n    for ( unsigned int i = tid * size; i < (tid + 1) * size; i++) {\n            result[tid] += i % 2;\n    }\n  }\n}\n\ntemplate <typename T>\nvoid atomicCost (int length, int size, int repeat)\n{\n  printf(\"\\n\\n\");\n  printf(\"Each thread sums up %d elements\\n\", size);\n\n  int num_threads = length / size;\n  assert(length % size == 0);\n  assert(num_threads % BLOCK_SIZE == 0);\n\n  size_t result_size = sizeof(T) * num_threads;\n\n  T* result_wi = (T*) malloc (result_size);\n  T* result_wo = (T*) malloc (result_size);\n  memset(result_wi, 0, result_size);\n  memset(result_wo, 0, result_size);\n\n    {\n    auto start = std::chrono::steady_clock::now();\n    for(int i=0; i<repeat; i++)\n    {\n      wiAtomicOnGlobalMem<T>(result_wi, size, num_threads);\n    }\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average execution time of WithAtomicOnGlobalMem: %f (us)\\n\",\n            time * 1e-3f / repeat);\n    \n    start = std::chrono::steady_clock::now();\n    for(int i=0; i<repeat; i++)\n    {\n      woAtomicOnGlobalMem<T>(result_wo, size, num_threads);\n    }\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average execution time of WithoutAtomicOnGlobalMem: %f (us)\\n\",\n            time * 1e-3f / repeat);\n    \n    int diff = memcmp(result_wi, result_wo, result_size);\n    printf(\"%s\\n\", diff ? \"FAIL\" : \"PASS\");\n  }\n\n  free(result_wi);\n  free(result_wo);\n}\n\nint main(int argc, char* argv[])\n{\n  if (argc != 3) {\n    printf(\"Usage: %s <N> <repeat>\\n\", argv[0]);\n    printf(\"N: the number of elements to sum per thread (1 - 16)\\n\");\n    return 1;\n  }\n  const int nelems = atoi(argv[1]);\n  const int repeat = atoi(argv[2]);\n\n  const int length = 922521600;\n  assert(length % BLOCK_SIZE == 0);\n\n  printf(\"\\nFP64 atomic add\\n\");\n  atomicCost<double>(length, nelems, repeat);\n\n  printf(\"\\nINT32 atomic add\\n\");\n  atomicCost<int>(length, nelems, repeat);\n\n  printf(\"\\nFP32 atomic add\\n\");\n  atomicCost<float>(length, nelems, repeat);\n\n  return 0;\n}"}}
// {"kernel_name": "bsearch", "parallel_api": "serial", "code": {"main.cpp": "#include <cstdlib>\n#include <chrono>\n#include <iostream>\n\n#ifndef Real_t \n#define Real_t float\n#endif\n\ntemplate <typename T>\nvoid bs ( const size_t aSize,\n    const size_t zSize,\n    const T *acc_a,  \n\n    const T *acc_z,  \n\n    size_t *acc_r,  \n\n    const size_t n,\n    const int repeat )\n{\n  auto start = std::chrono::steady_clock::now();\n  for (int i= 0; i < repeat; i++) {\n        for (int i = 0; i < zSize; i++) { \n      T z = acc_z[i];\n      size_t low = 0;\n      size_t high = n;\n      while (high - low > 1) {\n        size_t mid = low + (high - low)/2;\n        if (z < acc_a[mid])\n          high = mid;\n        else\n          low = mid;\n      }\n      acc_r[i] = low;\n    }\n  }\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  std::cout << \"Average device execution time (bs1) \" << (time * 1e-9f) / repeat << \" (s)\\n\";\n}\n\ntemplate <typename T>\nvoid bs2 ( const size_t aSize,\n    const size_t zSize,\n    const T *acc_a,  \n\n    const T *acc_z,  \n\n    size_t *acc_r,  \n\n    const size_t n,\n    const int repeat )\n{\n  auto start = std::chrono::steady_clock::now();\n  for (int i= 0; i < repeat; i++) {\n        for (int i = 0; i < zSize; i++) { \n      unsigned  nbits = 0;\n      while (n >> nbits) nbits++;\n      size_t k = 1ULL << (nbits - 1);\n      T z = acc_z[i];\n      size_t idx = (acc_a[k] <= z) ? k : 0;\n      while (k >>= 1) {\n        size_t r = idx | k;\n        if (r < n && z >= acc_a[r]) { \n          idx = r;\n        }\n      }\n      acc_r[i] = idx;\n    }\n  }\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  std::cout << \"Average device execution time (bs2) \" << (time * 1e-9f) / repeat << \" (s)\\n\";\n}\n\ntemplate <typename T>\nvoid bs3 ( const size_t aSize,\n    const size_t zSize,\n    const T *acc_a,  \n\n    const T *acc_z,  \n\n    size_t *acc_r,  \n\n    const size_t n,\n    const int repeat )\n{\n  auto start = std::chrono::steady_clock::now();\n  for (int i= 0; i < repeat; i++) {\n        for (int i = 0; i < zSize; i++) { \n      unsigned nbits = 0;\n      while (n >> nbits) nbits++;\n      size_t k = 1ULL << (nbits - 1);\n      T z = acc_z[i];\n      size_t idx = (acc_a[k] <= z) ? k : 0;\n      while (k >>= 1) {\n        size_t r = idx | k;\n        size_t w = r < n ? r : n; \n        if (z >= acc_a[w]) { \n          idx = r;\n        }\n      }\n      acc_r[i] = idx;\n    }\n  }\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  std::cout << \"Average device execution time (bs3) \" << (time * 1e-9f) / repeat << \" (s)\\n\";\n}\n\ntemplate <typename T>\nvoid bs4 ( const size_t aSize,\n    const size_t zSize,\n    const T *acc_a,  \n\n    const T *acc_z,  \n\n    size_t *acc_r,  \n\n    const size_t n,\n    const int repeat )\n{\n  auto start = std::chrono::steady_clock::now();\n  for (int i= 0; i < repeat; i++) {\n        {\n      size_t k;\n            {\n        size_t lid = omp_get_thread_num();\n        size_t gid = omp_get_team_num()*omp_get_num_threads()+lid;\n        if (lid == 0) {\n          unsigned nbits = 0;\n          while (n >> nbits) nbits++;\n          k = 1ULL << (nbits - 1);\n        }\n        \n        size_t p = k;\n        T z = acc_z[gid];\n        size_t idx = (acc_a[p] <= z) ? p : 0;\n        while (p >>= 1) {\n          size_t r = idx | p;\n          size_t w = r < n ? r : n;\n          if (z >= acc_a[w]) { \n            idx = r;\n          }\n        }\n        acc_r[gid] = idx;\n      }\n    }\n  }\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  std::cout << \"Average device execution time (bs4) \" << (time * 1e-9f) / repeat << \" (s)\\n\";\n}\n\n#ifdef DEBUG\nvoid verify(Real_t *a, Real_t *z, size_t *r, size_t aSize, size_t zSize, std::string msg)\n{\n  for (size_t i = 0; i < zSize; ++i)\n  {\n    \n\n    if (!(r[i]+1 < aSize && a[r[i]] <= z[i] && z[i] < a[r[i] + 1]))\n    {\n      std::cout << msg << \": incorrect result:\" << std::endl;\n      std::cout << \"index = \" << i << \" r[index] = \" << r[i] << std::endl;\n      std::cout << a[r[i]] << \" <= \" << z[i] << \" < \" << a[r[i] + 1] << std::endl;\n      break;\n    }\n    \n\n    r[i] = 0xFFFFFFFF;\n  }\n}\n#endif\n\nint main(int argc, char* argv[])\n{\n  if (argc != 3) {\n    std::cout << \"Usage ./main <number of elements> <repeat>\\n\";\n    return 1;\n  }\n\n  size_t numElem = atol(argv[1]);\n  uint repeat = atoi(argv[2]);\n\n  srand(2);\n  size_t aSize = numElem;\n  size_t zSize = 2*aSize;\n  Real_t *a = NULL;\n  Real_t *z = NULL;\n  size_t *r = NULL;\n  posix_memalign((void**)&a, 1024, aSize * sizeof(Real_t));\n  posix_memalign((void**)&z, 1024, zSize * sizeof(Real_t));\n  posix_memalign((void**)&r, 1024, zSize * sizeof(size_t));\n\n  size_t N = aSize-1;\n\n  \n\n  for (size_t i = 0; i < aSize; i++) a[i] = i;\n\n  \n\n  for (size_t i = 0; i < zSize; i++) { \n    z[i] = rand() % N;\n  }\n\n    {\n    bs(aSize, zSize, a, z, r, N, repeat);\n  \n  #ifdef DEBUG\n        verify(a, z, r, aSize, zSize, \"bs1\");\n  #endif\n  \n    bs2(aSize, zSize, a, z, r, N, repeat);\n  \n  #ifdef DEBUG\n        verify(a, z, r, aSize, zSize, \"bs2\");\n  #endif\n  \n    bs3(aSize, zSize, a, z, r, N, repeat);\n  \n  #ifdef DEBUG\n        verify(a, z, r, aSize, zSize, \"bs3\");\n  #endif\n  \n    bs4(aSize, zSize, a, z, r, N, repeat);\n  \n  #ifdef DEBUG\n        verify(a, z, r, aSize, zSize, \"bs4\");\n  #endif\n  }\n\n  free(a);\n  free(z);\n  free(r);\n  return 0;\n}"}}
// {"kernel_name": "colorwheel", "parallel_api": "serial", "code": {"main.cpp": "#include <chrono>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n\n\n\n\n\n\n\n\n\n\n\n#define RY  15\n#define YG  6\n#define GC  4\n#define CB  11\n#define BM  13\n#define MR  6\n#define MAXCOLS  (RY + YG + GC + CB + BM + MR)\ntypedef unsigned char uchar;\n\nvoid setcols(int cw[MAXCOLS][3], int r, int g, int b, int k)\n{\n  cw[k][0] = r;\n  cw[k][1] = g;\n  cw[k][2] = b;\n}\n\nvoid computeColor(float fx, float fy, uchar *pix)\n{\n  int cw[MAXCOLS][3];  \n\n\n  \n\n  \n\n  \n\n  \n\n  int i;\n  int k = 0;\n  for (i = 0; i < RY; i++) setcols(cw, 255,     255*i/RY,   0,       k++);\n  for (i = 0; i < YG; i++) setcols(cw, 255-255*i/YG, 255,     0,     k++);\n  for (i = 0; i < GC; i++) setcols(cw, 0,       255,     255*i/GC,   k++);\n  for (i = 0; i < CB; i++) setcols(cw, 0,       255-255*i/CB, 255,   k++);\n  for (i = 0; i < BM; i++) setcols(cw, 255*i/BM,     0,     255,     k++);\n  for (i = 0; i < MR; i++) setcols(cw, 255,     0,     255-255*i/MR, k++);\n\n  float rad = sqrtf(fx * fx + fy * fy);\n  float a = atan2f(-fy, -fx) / (float)M_PI;\n  float fk = (a + 1.f) / 2.f * (MAXCOLS-1);\n  int k0 = (int)fk;\n  int k1 = (k0 + 1) % MAXCOLS;\n  float f = fk - k0;\n  for (int b = 0; b < 3; b++) {\n    float col0 = cw[k0][b] / 255.f;\n    float col1 = cw[k1][b] / 255.f;\n    float col = (1.f - f) * col0 + f * col1;\n    if (rad <= 1)\n      col = 1.f - rad * (1.f - col); \n\n    else\n      col *= .75f; \n\n    pix[2 - b] = (int)(255.f * col);\n  }\n}\n\nint main(int argc, char **argv)\n{\n  if (argc != 4) {\n    printf(\"Usage: %s <range> <size> <repeat>\\n\", argv[0]);\n    exit(1);\n  }\n  const float truerange = atof(argv[1]);\n  const int size = atoi(argv[2]);\n  const int repeat = atoi(argv[3]);\n\n  \n\n  float range = 1.04f * truerange;\n\n  const int half_size = size/2;\n\n  \n\n  size_t imgSize = size * size * 3;\n  uchar* pix = (uchar*) malloc (imgSize);\n  uchar* res = (uchar*) malloc (imgSize);\n\n  memset(pix, 0, imgSize);\n\n  for (int y = 0; y < size; y++) {\n    for (int x = 0; x < size; x++) {\n      float fx = (float)x / (float)half_size * range - range;\n      float fy = (float)y / (float)half_size * range - range;\n      if (x == half_size || y == half_size) continue; \n\n      size_t idx = (y * size + x) * 3;\n      computeColor(fx/truerange, fy/truerange, pix+idx);\n    }\n  }\n\n  printf(\"Start execution on a device\\n\");\n  uchar *d_pix = (uchar*) malloc(imgSize);\n  memset(d_pix, 0, imgSize);\n\n    {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++) {\n            for (int y = 0; y < size; y++) {\n        for (int x = 0; x < size; x++) {\n          float fx = (float)x / (float)half_size * range - range;\n          float fy = (float)y / (float)half_size * range - range;\n          if (x != half_size && y != half_size) {\n            size_t idx = (y * size + x) * 3;\n            computeColor(fx/truerange, fy/truerange, d_pix+idx);\n          }\n        }\n      }\n    }\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time : %f (ms)\\n\", (time * 1e-6f) / repeat);\n  }\n\n  \n\n  int fail = memcmp(pix, d_pix, imgSize);\n  if (fail) {\n    int max_error = 0;\n    for (size_t i = 0; i < imgSize; i++) {\n       int e = abs(d_pix[i] - pix[i]);\n       if (e > max_error) max_error = e;\n    }\n    printf(\"Maximum error between host and device results: %d\\n\", max_error);\n  }\n  else {\n    printf(\"%s\\n\", \"PASS\");\n  }\n  \n  free(d_pix);\n  free(pix);\n  free(res);\n  return 0;\n}"}}
// {"kernel_name": "dense-embedding", "parallel_api": "serial", "code": {"main.cpp": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <chrono>\n#include <random>\n\ntemplate <typename T>\nvoid reference(\n    const T* input,\n    const T* dense,\n    T* output,\n    int embedding_dim,\n    int batch_size,\n    const int* offset)\n{\n  for (int batch_idx = 0; batch_idx < batch_size; batch_idx++) {\n    const int range = offset[batch_idx + 1] - offset[batch_idx];\n    for (int idx = 0; idx < embedding_dim; idx++) {\n      const T dense_elem = dense[batch_idx * embedding_dim + idx];\n      for (int nested_idx = idx; nested_idx < range; nested_idx += embedding_dim) {\n        output[offset[batch_idx] + nested_idx] =\n          input[offset[batch_idx] + nested_idx] + dense_elem;\n      }\n    }\n  }\n}\n\nint main(int argc, char* argv[])\n{\n  if (argc != 4) {\n    printf(\"Usage: %s <number of rows> <batch size> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  const int nrows = atoi(argv[1]);\n  const int batch_size = atoi(argv[2]);\n  const int repeat = atoi(argv[3]);\n  assert(nrows > batch_size * batch_size);\n\n  printf(\"Number of rows in the embedding table: %d\\n\", nrows);\n  printf(\"Batch size: %d\\n\", batch_size);\n\n  const int embed_dims[] = {768, 2048, 12288};\n\n  for (size_t n = 0; n < sizeof(embed_dims)/sizeof(int); n++) {\n    int ncols = embed_dims[n];\n    printf(\"\\nEmbedding dimension: %d\\n\", ncols);\n\n    int input_size = nrows * ncols;  \n\n    size_t input_size_bytes = input_size * sizeof(float);\n\n    int dense_size = batch_size * ncols ;\n    int dense_size_bytes = dense_size * sizeof(float);\n\n    int batch_size_bytes = (batch_size + 1) * sizeof(float);\n\n    float *input, *dense, *output_k1, *output_k2, *output_ref;\n    input = (float*) malloc (input_size_bytes); \n\n    dense = (float*) malloc (dense_size_bytes); \n\n    output_k1 = (float*) malloc (input_size_bytes); \n\n    output_k2 = (float*) malloc (input_size_bytes); \n\n    output_ref = (float*) malloc (input_size_bytes); \n\n    int *offset = (int*) malloc (batch_size_bytes);  \n\n\n    \n\n    \n\n    \n\n    \n\n    srand(123);\n    offset[0] = 0;\n    for (int i = 1; i <= batch_size; i++)\n      offset[i] = offset[i-1] + (rand() % batch_size + 1) * ncols;\n\n    std::default_random_engine g (123);\n    std::uniform_real_distribution<float> distr (-1.f, 1.f);\n    for (int i = 0; i < dense_size; i++) {\n      dense[i] = distr(g);\n    }\n\n    for (int i = 0; i < input_size; i++) {\n      input[i] = distr(g);\n      output_k1[i] = output_k2[i] = output_ref[i] = 0;\n    }\n\n    reference(input, dense, output_ref, ncols, batch_size, offset);\n\n        {\n      for (int block_size = 128; block_size <= 1024; block_size = block_size * 2) {\n        printf(\"block size: %d\\n\", block_size);\n\n        auto start = std::chrono::steady_clock::now();\n\n        for (int i = 0; i < repeat; i++) {\n                    {\n                        {\n              const int batch_idx  = omp_get_team_num(); \n\n              const int grain_size = omp_get_num_threads();\n              const int tid = omp_get_thread_num();\n              const int range = offset[batch_idx + 1] - offset[batch_idx];\n              for (int idx = tid; idx < ncols; idx += grain_size) {\n                const auto dense_elem = dense[batch_idx * ncols + idx];\n                for (int nested_idx = idx; nested_idx < range; nested_idx += ncols) {\n                  output_k1[offset[batch_idx] + nested_idx] = input[offset[batch_idx] + nested_idx] + dense_elem;\n                }\n              }\n            }\n          }\n        }\n\n        auto end = std::chrono::steady_clock::now();\n        auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n        printf(\"Average execution time of dense embedding kernel (k1): %f (us)\\n\", (time * 1e-3f) / repeat);\n\n        \n        start = std::chrono::steady_clock::now();\n\n        for (int i = 0; i < repeat; i++) {\n                    {\n                        {\n              const int batch_idx  = omp_get_team_num(); \n\n              const int start = offset[batch_idx];\n              const int range = offset[batch_idx + 1] - start;\n              for (int idx = omp_get_thread_num(); idx < ncols; idx += omp_get_num_threads()) {\n                const auto dense_elem = dense[batch_idx * ncols + idx];\n                for (int nested_idx = idx; nested_idx < range; nested_idx += ncols) {\n                  output_k2[start + nested_idx] = input[start + nested_idx] + dense_elem;\n                }\n              }\n            }\n          }\n        }\n\n        end = std::chrono::steady_clock::now();\n        time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n        printf(\"Average execution time of dense embedding kernel (k2): %f (us)\\n\", (time * 1e-3f) / repeat);\n\n        \n        bool ok = true;\n        for (int i = 0; i < input_size; i++) {\n          if (fabsf(output_k1[i] - output_ref[i]) > 1e-3f ||\n              fabsf(output_k2[i] - output_ref[i]) > 1e-3f) {\n            ok = false;\n            break;\n          }\n        }\n        printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n      }\n    }\n\n    free(input);\n    free(dense);\n    free(output_k1);\n    free(output_k2);\n    free(output_ref);\n    free(offset);\n  }\n\n  return 0;\n}"}}
// {"kernel_name": "entropy", "parallel_api": "serial", "code": {"main.cpp": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <chrono>\n#include \"reference.h\"\n\nvoid entropy(\n      float *__restrict d_entropy,\n  const char*__restrict d_val, \n  int height, int width)\n{\n    for (int y = 0; y < height; y++) {\n    for (int x = 0; x < width; x++) {\n      \n\n      char count[16];\n      for (int i = 0; i < 16; i++) count[i] = 0;\n\n      \n\n      char total = 0;\n\n      \n\n      for(int dy = -2; dy <= 2; dy++) {\n        for(int dx = -2; dx <= 2; dx++) {\n          int xx = x + dx;\n          int yy = y + dy;\n          if(xx >= 0 && yy >= 0 && yy < height && xx < width) {\n            count[d_val[yy * width + xx]]++;\n            total++;\n          }\n        }\n      }\n\n      float entropy = 0;\n      if (total < 1) {\n        total = 1;\n      } else {\n        for(int k = 0; k < 16; k++) {\n          float p = (float)count[k] / (float)total;\n          entropy -= p * log2f(p);\n        }\n      }\n\n      d_entropy[y * width + x] = entropy;\n    }\n  }\n}\n\ntemplate<int bsize_x, int bsize_y>\nvoid entropy_opt(\n       float *__restrict d_entropy,\n  const  char*__restrict d_val, \n  const float*__restrict d_logTable,\n  int m, int n)\n{\n  const int teamX = (n+bsize_x-1)/bsize_x;\n  const int teamY = (m+bsize_y-1)/bsize_y;\n  const int numTeams = teamX * teamY;\n\n    {\n    int sd_count[16][bsize_x*bsize_y];\n        {\n      const int threadIdx_x = omp_get_num_threads() % bsize_x;\n      const int threadIdx_y = omp_get_num_threads() / bsize_x;\n      const int teamIdx_x = omp_get_num_teams() % teamX;\n      const int teamIdx_y = omp_get_num_teams() / teamX;\n      const int x = teamIdx_x * bsize_x + threadIdx_x;\n      const int y = teamIdx_y * bsize_y + threadIdx_y;\n\n      const int idx = threadIdx_y*bsize_x + threadIdx_x;\n\n      for(int i = 0; i < 16; i++) sd_count[i][idx] = 0;\n\n      char total = 0;\n      for(int dy = -2; dy <= 2; dy++) {\n        for(int dx = -2; dx <= 2; dx++) {\n          int xx = x + dx,\n              yy = y + dy;\n\n          if(xx >= 0 && yy >= 0 && yy < m && xx < n) {\n            sd_count[d_val[yy*n+xx]][idx]++;\n            total++;\n          }\n        }\n      }\n\n      float entropy = 0;\n      for(int k = 0; k < 16; k++)\n        entropy -= d_logTable[sd_count[k][idx]];\n      \n      entropy = entropy / total + log2f(total);\n      if(y < m && x < n) d_entropy[y*n+x] = entropy;\n    }\n  }\n}\n\nint main(int argc, char* argv[]) {\n  if (argc != 4) {\n    printf(\"Usage: %s <width> <height> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  const int width = atoi(argv[1]); \n  const int height = atoi(argv[2]); \n  const int repeat = atoi(argv[3]); \n\n  const int input_bytes = width * height * sizeof(char);\n  const int output_bytes = width * height * sizeof(float);\n  char* input = (char*) malloc (input_bytes);\n  float* output = (float*) malloc (output_bytes);\n  float* output_ref = (float*) malloc (output_bytes);\n\n  float logTable[26];\n  for (int i = 0; i <= 25; i++) logTable[i] = i <= 1 ? 0 : i*log2f(i);\n\n  srand(123);\n  for (int i = 0; i < height; i++)\n    for (int j = 0; j < width; j++)\n      input[i * width + j] = rand() % 16;\n\n    {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      entropy(output, input, height, width);\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel (baseline) execution time %f (s)\\n\", (time * 1e-9f) / repeat);\n\n    start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      entropy_opt<16, 16>(output, input, logTable, height, width);\n\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel (optimized) execution time %f (s)\\n\", (time * 1e-9f) / repeat);\n  }\n\n  \n\n  reference(output_ref, input, height, width);\n\n  bool ok = true;\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      if (fabsf(output[i * width + j] - output_ref[i * width + j]) > 1e-3f) {\n        ok = false; \n        break;\n      }\n    }\n    if (!ok) break;\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n \n  free(input);\n  free(output);\n  free(output_ref);\n  return 0;\n}"}}
// {"kernel_name": "jacobi", "parallel_api": "serial", "code": {"main.cpp": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <chrono>\n\n\n\n#define N 2048\n\n#define IDX(i, j) ((i) + (j) * N)\n\nvoid initialize_data (float* f) {\n  \n\n  for (int j = 0; j < N; ++j) {\n    for (int i = 0; i < N; ++i) {\n\n      if (i == 0 || i == N-1) {\n        f[IDX(i,j)] = sinf(j * 2 * M_PI / (N - 1));\n      }\n      else if (j == 0 || j == N-1) {\n        f[IDX(i,j)] = sinf(i * 2 * M_PI / (N - 1));\n      }\n      else {\n        f[IDX(i,j)] = 0.0f;\n      }\n\n    }\n  }\n}\n\nint main () {\n  \n\n  std::clock_t start_time = std::clock();\n\n  \n\n  float* f = (float*) aligned_alloc(64, N * N * sizeof(float));\n  float* f_old = (float*) aligned_alloc(64, N * N * sizeof(float));\n  \n\n  float error = {std::numeric_limits<float>::max()};\n  const float tolerance = 1.e-5f;\n\n  \n\n  \n\n  initialize_data(f);\n  initialize_data(f_old);\n\n  \n\n  \n\n  const int max_iters = 10000;\n  int num_iters = 0;\n\n{\n  auto start = std::chrono::steady_clock::now();\n\n  while (error > tolerance && num_iters < max_iters) {\n    \n\n    \n\n    error = 0.f;\n    \n        for (int i = 1; i <= N-2; i++) {\n      for (int j = 1; j <= N-2; j++) {\n        float t = 0.25f * (f_old[IDX(i-1,j)] +\n                           f_old[IDX(i+1,j)] +\n                           f_old[IDX(i,j-1)] +\n                           f_old[IDX(i,j+1)]);\n        float df = t - f_old[IDX(i, j)];\n        f[IDX(i,j)] = t;\n        error += df * df;\n      }\n    }\n      \n    \n\n    \n\n    \n\n        for (int j = 0; j < N; j++) \n      for (int i = 0; i < N; i++) \n        if (j >= 1 && j <= N-2 && i >= 1 && i <= N-2)\n          f_old[IDX(i,j)] = f[IDX(i,j)];\n\n    \n\n    \n\n    error = sqrtf(error / (N * N));\n\n    \n\n    if (num_iters % 1000 == 0) {\n      std::cout << \"Error after iteration \" << num_iters << \" = \" << error << std::endl;\n    }\n\n    \n\n    ++num_iters;\n  }\n\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  std::cout << \"Average execution time per iteration: \" << (time * 1e-9f) / num_iters << \" (s)\\n\";\n}\n\n  \n\n  \n\n\n  if (error <= tolerance && num_iters < max_iters) {\n    std::cout << \"PASS\" << std::endl;\n  }\n  else {\n    std::cout << \"FAIL\" << std::endl;\n    return -1;\n  }\n\n  \n\n  free(f);\n  free(f_old);\n\n  \n\n  double duration = (std::clock() - start_time) / (double) CLOCKS_PER_SEC;\n  std::cout << \"Total elapsed time: \" << std::setprecision(4) << duration << \" seconds\" << std::endl;\n\n  return 0;\n}"}}
// {"kernel_name": "layout", "parallel_api": "serial", "code": {"main.cpp": "\n\n\n\n#include <iostream>\n#include <stdlib.h>\n#include <string.h>\n#include <chrono>\n\n#define TREE_NUM 4096\n#define TREE_SIZE 4096\n#define GROUP_SIZE 256\n\nstruct AppleTree\n{\n  int apples[TREE_SIZE];\n};\n\nstruct ApplesOnTrees\n{\n  int trees[TREE_NUM];\n};\n\nint main(int argc, char * argv[])\n{\n  if (argc != 2) {\n    printf(\"Usage: %s <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  \n  const int iterations = atoi(argv[1]); \n\n  const int treeSize = TREE_SIZE;\n  const int treeNumber = TREE_NUM;\n  bool fail = false;\n\n  if(iterations < 1)\n  {\n    std::cout<<\"Iterations cannot be 0 or negative. Exiting..\\n\";\n    return -1;\n  }\n\n  if(treeNumber < GROUP_SIZE)\n  {\n    std::cout<<\"treeNumber should be larger than the work group size\"<<std::endl;\n    return -1;\n  }\n  if(treeNumber % 256 !=0)\n  {\n    std::cout<<\"treeNumber should be a multiple of 256\"<<std::endl;\n    return -1;\n  }\n\n  const int elements = treeSize * treeNumber;\n  size_t inputSize = elements * sizeof(int);\n  size_t outputSize = treeNumber * sizeof(int);\n\n  \n\n  int* data = (int*) malloc (inputSize);\n\n  \n\n  int *output = (int *)malloc(outputSize);\n\n  \n\n  int *reference = (int *)malloc(outputSize);\n  memset(reference,0,outputSize);\n  for(int i=0; i < treeNumber; i++)\n    for(int j=0; j < treeSize; j++)\n      reference[i] += i * treeSize + j;\n\n{\n  \n\n  for (int i = 0; i < treeNumber; i++)\n    for(int j = 0; j < treeSize; j++)\n      data[j + i* treeSize] = j + i* treeSize;\n\n  \n  AppleTree *trees = (AppleTree*) data;\n\n  auto start = std::chrono::steady_clock::now();\n\n  for (int n = 0; n < iterations; n++) {\n        for (uint gid = 0; gid < treeNumber; gid++) \n    {\n      uint res = 0;\n      for(int i = 0; i < treeSize; i++)\n      {\n        res += trees[gid].apples[i];\n      }\n      output[gid] = res;\n    }\n  }\n\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  std::cout << \"Average kernel execution time (AoS): \"\n            << (time * 1e-3f) / iterations << \" (us)\\n\";\n\n  \n  for(int i=0; i< treeNumber; i++)\n  {\n    if(output[i] != reference[i])\n    {\n      fail = true;\n      break;\n    }\n  }\n\n  if (fail)\n    std::cout << \"FAIL\\n\";\n  else\n    std::cout << \"PASS\\n\";\n\n  \n\n  for (int i = 0; i < treeNumber; i++)\n    for(int j = 0; j < treeSize; j++)\n      data[i + j* treeNumber] = j + i* treeSize;\n\n  \n  ApplesOnTrees *applesOnTrees = (ApplesOnTrees*) data;\n\n  start = std::chrono::steady_clock::now();\n\n  for (int n = 0; n < iterations; n++) {\n        for (uint gid = 0; gid < treeNumber; gid++) \n    {\n      uint res = 0;\n      for(int i = 0; i < treeSize; i++)\n      {\n        res += applesOnTrees[i].trees[gid];\n      }\n      output[gid] = res;\n    }\n  }\n\n  end = std::chrono::steady_clock::now();\n  time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  std::cout << \"Average kernel execution time (SoA): \"\n            << (time * 1e-3f) / iterations << \" (us)\\n\";\n\n  \n  for(int i=0; i< treeNumber; i++)\n  {\n    if(output[i] != reference[i])\n    {\n      fail = true;\n      break;\n    }\n  }\n\n  if (fail)\n    std::cout << \"FAIL\\n\";\n  else\n    std::cout << \"PASS\\n\";\n\n}\n\n  free(output);\n  free(reference);\n  free(data);\n  return 0;\n}\n"}}
{"kernel_name": "matrix-rotate", "parallel_api": "serial", "code": {"main.cpp": "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <chrono>\n\nvoid rotate_matrix_parallel (float *matrix, const int n, const int repeat) {\n    {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++) {\n            for (int layer = 0; layer < n / 2; ++layer) {\n        int first = layer;\n        int last = n - 1 - layer;\n        for(int i = first; i < last; ++i) {\n          int offset = i - first;\n\n          float top = matrix[first*n+i]; \n\n          \n\n          matrix[first*n+i] = matrix[(last-offset)*n+first];\n\n          \n\n          matrix[(last-offset)*n+first] = matrix[last*n+(last-offset)];\n\n          \n\n          matrix[last*n+(last-offset)] = matrix[i*n+last];\n\n          \n\n          matrix[i*n+last] = top; \n\n        }\n      }\n    }\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time: %f (s)\\n\", (time * 1e-9f) / repeat);\n  }\n}\n\nvoid rotate_matrix_serial(float *matrix, const int n) {\n  for (int layer = 0; layer < n / 2; ++layer) {\n    int first = layer;\n    int last = n - 1 - layer;\n    for(int i = first; i < last; ++i) {\n      int offset = i - first;\n        float top = matrix[first*n+i]; \n\n        \n\n        matrix[first*n+i] = matrix[(last-offset)*n+first];\n\n        \n\n        matrix[(last-offset)*n+first] = matrix[last*n+(last-offset)];\n\n        \n\n        matrix[last*n+(last-offset)] = matrix[i*n+last];\n\n        \n\n        matrix[i*n+last] = top; \n\n    }\n  }\n}\n\nint main(int argc, char** argv) {\n  if (argc != 3) {\n    printf(\"Usage: %s <matrix size> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  const int n = atoi(argv[1]);\n  const int repeat = atoi(argv[2]);\n\n  float *serial_res = (float*) aligned_alloc(1024, n*n*sizeof(float));\n  float *parallel_res = (float*) aligned_alloc(1024, n*n*sizeof(float));\n\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++)\n      serial_res[i*n+j] = parallel_res[i*n+j] = i*n+j;\n\n  for (int i = 0; i < repeat; i++) {\n    rotate_matrix_serial(serial_res, n);\n  }\n\n  rotate_matrix_parallel (parallel_res, n, repeat);\n\n  bool ok = true;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (serial_res[i*n+j] != parallel_res[i*n+j]) {\n        ok = false;\n        break;\n      }\n    }\n  }\n\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n\n  free(serial_res);\n  free(parallel_res);\n  return 0;\n}"}}
// {"kernel_name": "pathfinder", "parallel_api": "serial", "code": {"main.cpp": "\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n#include <iostream>\n#include <sys/time.h>\n#include <string.h>\n\nusing namespace std;\n\n\n\n#define HALO     1\n#define STR_SIZE 256\n#define DEVICE   0\n#define M_SEED   9\n#define IN_RANGE(x, min, max)  ((x)>=(min) && (x)<=(max))\n#define CLAMP_RANGE(x, min, max) x = (x<(min)) ? min : ((x>(max)) ? max : x )\n#define MIN(a, b) ((a)<=(b) ? (a) : (b))\n\n\nvoid fatal(char *s)\n{\n  fprintf(stderr, \"error: %s\\n\", s);\n}\n\ndouble get_time() {\n  struct timeval t;\n  gettimeofday(&t,NULL);\n  return t.tv_sec+t.tv_usec*1e-6;\n}\n\nint main(int argc, char** argv)\n{\n  \n\n  int   rows, cols;\n  int*  data;\n  int** wall;\n  int*  result;\n  int   pyramid_height;\n\n  if (argc == 4)\n  {\n    cols = atoi(argv[1]);\n    rows = atoi(argv[2]);\n    pyramid_height = atoi(argv[3]);\n  }\n  else\n  {\n    printf(\"Usage: %s <column length> <row length> <pyramid_height>\\n\", argv[0]);\n\n    exit(0);\n  }\n\n  data = new int[rows * cols];\n  wall = new int*[rows];\n  for (int n = 0; n < rows; n++)\n  {\n    \n\n    wall[n] = data + cols * n;\n  }\n  result = new int[cols];\n\n  int seed = M_SEED;\n  srand(seed);\n\n  for (int i = 0; i < rows; i++)\n  {\n    for (int j = 0; j < cols; j++)\n    {\n      wall[i][j] = rand() % 10;\n    }\n  }\n#ifdef BENCH_PRINT\n  for (int i = 0; i < rows; i++)\n  {\n    for (int j = 0; j < cols; j++)\n    {\n      printf(\"%d \", wall[i][j]);\n    }\n    printf(\"\\n\");\n  }\n#endif\n\n  \n\n  const int borderCols = (pyramid_height) * HALO;\n\n  \n\n\n  const int size = rows * cols;  \n\n  const int lws = 250;\n  const int gws = size/lws;  \n\n  int theHalo = HALO;\n  int* outputBuffer = (int*)calloc(16384, sizeof(int));\n\n  double offload_start = get_time();\n\n  \n\n  int* gpuWall = data+cols;\n  \n\n  \n\n  int* gpuSrc = (int*) malloc (sizeof(int)*cols);\n  int* gpuResult = (int*) malloc (sizeof(int)*cols);\n  memcpy(gpuSrc, data, cols*sizeof(int));\n\n  {\n    double kstart = 0.0;\n\n    for (int t = 0; t < rows - 1; t += pyramid_height)\n    {\n      if (t == pyramid_height) {\n        kstart = get_time();\n      }\n\n      \n\n      int iteration = MIN(pyramid_height, rows-t-1);\n\n            {\n        int prev[lws];\n        int result[lws];\n                {\n          \n\n          int BLOCK_SIZE = omp_get_num_threads();\n          int bx = omp_get_team_num();\n          int tx = omp_get_thread_num();\n\n          \n\n          \n\n          \n\n          \n\n\n          \n\n          int small_block_cols = BLOCK_SIZE - (iteration*theHalo*2);\n\n          \n\n          \n\n          int blkX = (small_block_cols*bx) - borderCols;\n          int blkXmax = blkX+BLOCK_SIZE-1;\n\n          \n\n          int xidx = blkX+tx;\n\n          \n\n          \n\n          \n\n          int validXmin = (blkX < 0) ? -blkX : 0;\n          int validXmax = (blkXmax > cols-1) ? BLOCK_SIZE-1-(blkXmax-cols+1) : BLOCK_SIZE-1;\n\n          int W = tx-1;\n          int E = tx+1;\n\n          W = (W < validXmin) ? validXmin : W;\n          E = (E > validXmax) ? validXmax : E;\n\n          bool isValid = IN_RANGE(tx, validXmin, validXmax);\n\n          if(IN_RANGE(xidx, 0, cols-1))\n          {\n            prev[tx] = gpuSrc[xidx];\n          }\n\n          \n          bool computed;\n          for (int i = 0; i < iteration; i++)\n          {\n            computed = false;\n\n            if( IN_RANGE(tx, i+1, BLOCK_SIZE-i-2) && isValid )\n            {\n              computed = true;\n              int left = prev[W];\n              int up = prev[tx];\n              int right = prev[E];\n              int shortest = MIN(left, up);\n              shortest = MIN(shortest, right);\n\n              int index = cols*(t+i)+xidx;\n              result[tx] = shortest + gpuWall[index];\n\n              \n\n              \n\n              if (tx==11 && i==0)\n              {\n                \n\n                int bufIndex = gpuSrc[xidx];\n                \n\n                outputBuffer[bufIndex] = 1;\n              }\n              \n\n            }\n\n            \n            if(i==iteration-1)\n            {\n              \n\n              \n\n              break;\n            }\n\n            if(computed)\n            {\n              \n\n              prev[tx] = result[tx];\n            }\n                      }\n\n          \n\n          \n\n          \n\n          if (computed)\n          {\n            gpuResult[xidx] = result[tx];\n          }\n        }\n      } \n      int *temp = gpuResult;\n      gpuResult = gpuSrc;\n      gpuSrc = temp;\n    }\n\n    double kend = get_time();\n    printf(\"Total kernel execution time: %lf (s)\\n\", kend - kstart);\n\n      }\n\n  double offload_end = get_time();\n  printf(\"Device offloading time = %lf(s)\\n\", offload_end - offload_start);\n\n  \n\n  outputBuffer[16383] = '\\0';\n\n#ifdef BENCH_PRINT\n  for (int i = 0; i < cols; i++)\n    printf(\"%d \", data[i]);\n  printf(\"\\n\");\n  for (int i = 0; i < cols; i++)\n    printf(\"%d \", gpuSrc[i]);\n  printf(\"\\n\");\n#endif\n\n  \n\n  delete[] data;\n  delete[] wall;\n  delete[] result;\n  free(outputBuffer);\n  free(gpuSrc);\n  free(gpuResult);\n\n  return EXIT_SUCCESS;\n}"}}
// {"kernel_name": "randomAccess", "parallel_api": "serial", "code": {"main.cpp": "#include <stdio.h>\n#include <stdlib.h>\n#include <chrono>\n\ntypedef unsigned long long int u64Int;\ntypedef long long int s64Int;\n\n\n\n#define POLY 0x0000000000000007UL\n#define PERIOD 1317624576693539401L\n\n#define NUPDATE (4 * TableSize)\n\nu64Int\nHPCC_starts(s64Int n)\n{\n  int i, j;\n  u64Int m2[64];\n  u64Int temp, ran;\n\n  while (n < 0) n += PERIOD;\n  while (n > PERIOD) n -= PERIOD;\n  if (n == 0) return 0x1;\n\n  temp = 0x1;\n\n    for (i=0; i<64; i++) {\n    m2[i] = temp;\n    temp = (temp << 1) ^ ((s64Int) temp < 0 ? POLY : 0);\n    temp = (temp << 1) ^ ((s64Int) temp < 0 ? POLY : 0);\n  }\n\n  for (i=62; i>=0; i--)\n    if ((n >> i) & 1)\n      break;\n\n  ran = 0x2;\n  while (i > 0) {\n    temp = 0;\n        for (j=0; j<64; j++)\n      if ((ran >> j) & 1)\n        temp ^= m2[j];\n    ran = temp;\n    i -= 1;\n    if ((n >> i) & 1)\n      ran = (ran << 1) ^ ((s64Int) ran < 0 ? POLY : 0);\n  }\n\n  return ran;\n}\n\n\nint main(int argc, char** argv) {\n  if (argc != 2) {\n    printf(\"Usage: %s <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  const int repeat = atoi(argv[1]);\n\n  int failure;\n  u64Int i;\n  u64Int temp;\n  double totalMem;\n  u64Int *Table = NULL;\n  u64Int logTableSize, TableSize;\n\n  \n\n  totalMem = 1024*1024*512;\n  totalMem /= sizeof(u64Int);\n\n  \n\n  for (totalMem *= 0.5, logTableSize = 0, TableSize = 1;\n       totalMem >= 1.0;\n       totalMem *= 0.5, logTableSize++, TableSize <<= 1)\n    ; \n\n\n   printf(\"Table size = %llu\\n\",  TableSize);\n\n   posix_memalign((void**)&Table, 1024, TableSize * sizeof(u64Int));\n\n  if (! Table ) {\n    fprintf( stderr, \"Failed to allocate memory for the update table %llu\\n\", TableSize);\n    return 1;\n  }\n\n  \n\n  fprintf(stdout, \"Main table size   = 2^%llu = %llu words\\n\", logTableSize,TableSize);\n  fprintf(stdout, \"Number of updates = %llu\\n\", NUPDATE);\n\n  u64Int ran[128];\n\n{\n  auto start = std::chrono::steady_clock::now();\n\n  for (int i = 0; i < repeat; i++) {\n    \n\n        for (i=0; i<TableSize; i++) {\n      Table[i] = i;\n    }\n        for (int j=0; j<128; j++)\n      ran[j] = HPCC_starts ((NUPDATE/128) * j);\n\n        for (int j=0; j<128; j++) {\n      for (u64Int i=0; i<NUPDATE/128; i++) {\n        ran[j] = (ran[j] << 1) ^ ((s64Int) ran[j] < 0 ? POLY : 0);\n                Table[ran[j] & (TableSize-1)] ^= ran[j];\n      }\n    }\n  }\n\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Average kernel execution time: %f (s)\\n\", (time * 1e-9f) / repeat);\n\n}\n\n  \n\n  temp = 0x1;\n  for (i=0; i<NUPDATE; i++) {\n    temp = (temp << 1) ^ (((s64Int) temp < 0) ? POLY : 0);\n    Table[temp & (TableSize-1)] ^= temp;\n  }\n  \n  temp = 0;\n  for (i=0; i<TableSize; i++)\n    if (Table[i] != i) {\n      temp++;\n    }\n\n  fprintf( stdout, \"Found %llu errors in %llu locations (%s).\\n\",\n           temp, TableSize, (temp <= 0.01*TableSize) ? \"passed\" : \"failed\");\n  if (temp <= 0.01*TableSize) failure = 0;\n  else failure = 1;\n\n  free( Table );\n  return failure;\n\n}\n"}}
