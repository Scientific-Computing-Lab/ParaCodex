// {"kernel_name": "ace", "parallel_api": "serial", "code": {"main.cpp": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <chrono>\n\n\n\n#define DATAXSIZE 400\n#define DATAYSIZE 400\n#define DATAZSIZE 400\n\n#define SQ(x) ((x)*(x))\n\ntypedef double nRarray[DATAYSIZE][DATAXSIZE];\n\n#ifdef VERIFY\n#include <string.h>\n#include \"reference.h\"\n#endif\n\ndouble dFphi(double phi, double u, double lambda)\n{\n  return (-phi*(1.0-phi*phi)+lambda*u*(1.0-phi*phi)*(1.0-phi*phi));\n}\n\n\ndouble GradientX(double phi[][DATAYSIZE][DATAXSIZE], \n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  return (phi[x+1][y][z] - phi[x-1][y][z]) / (2.0*dx);\n}\n\n\ndouble GradientY(double phi[][DATAYSIZE][DATAXSIZE], \n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  return (phi[x][y+1][z] - phi[x][y-1][z]) / (2.0*dy);\n}\n\n\ndouble GradientZ(double phi[][DATAYSIZE][DATAXSIZE], \n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  return (phi[x][y][z+1] - phi[x][y][z-1]) / (2.0*dz);\n}\n\n\ndouble Divergence(double phix[][DATAYSIZE][DATAXSIZE], \n                  double phiy[][DATAYSIZE][DATAXSIZE],\n                  double phiz[][DATAYSIZE][DATAXSIZE], \n                  double dx, double dy, double dz, int x, int y, int z)\n{\n  return GradientX(phix,dx,dy,dz,x,y,z) + \n         GradientY(phiy,dx,dy,dz,x,y,z) +\n         GradientZ(phiz,dx,dy,dz,x,y,z);\n}\n\n\ndouble Laplacian(double phi[][DATAYSIZE][DATAXSIZE],\n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  double phixx = (phi[x+1][y][z] + phi[x-1][y][z] - 2.0 * phi[x][y][z]) / SQ(dx);\n  double phiyy = (phi[x][y+1][z] + phi[x][y-1][z] - 2.0 * phi[x][y][z]) / SQ(dy);\n  double phizz = (phi[x][y][z+1] + phi[x][y][z-1] - 2.0 * phi[x][y][z]) / SQ(dz);\n  return phixx + phiyy + phizz;\n}\n\n\ndouble An(double phix, double phiy, double phiz, double epsilon)\n{\n  if (phix != 0.0 || phiy != 0.0 || phiz != 0.0){\n    return ((1.0 - 3.0 * epsilon) * (1.0 + (((4.0 * epsilon) / (1.0-3.0*epsilon))*\n           ((SQ(phix)*SQ(phix)+SQ(phiy)*SQ(phiy)+SQ(phiz)*SQ(phiz)) /\n           ((SQ(phix)+SQ(phiy)+SQ(phiz))*(SQ(phix)+SQ(phiy)+SQ(phiz)))))));\n  }\n  else\n  {\n    return (1.0-((5.0/3.0)*epsilon));\n  }\n}\n\n\ndouble Wn(double phix, double phiy, double phiz, double epsilon, double W0)\n{\n  return (W0*An(phix,phiy,phiz,epsilon));\n}\n\n\ndouble taun(double phix, double phiy, double phiz, double epsilon, double tau0)\n{\n  return tau0 * SQ(An(phix,phiy,phiz,epsilon));\n}\n\n\ndouble dFunc(double l, double m, double n)\n{\n  if (l != 0.0 || m != 0.0 || n != 0.0){\n    return (((l*l*l*(SQ(m)+SQ(n)))-(l*(SQ(m)*SQ(m)+SQ(n)*SQ(n)))) /\n            ((SQ(l)+SQ(m)+SQ(n))*(SQ(l)+SQ(m)+SQ(n))));\n  }\n  else\n  {\n    return 0.0;\n  }\n}\n\nvoid calculateForce(double phi[][DATAYSIZE][DATAXSIZE], \n                    double Fx[][DATAYSIZE][DATAXSIZE],\n                    double Fy[][DATAYSIZE][DATAXSIZE],\n                    double Fz[][DATAYSIZE][DATAXSIZE],\n                    double dx, double dy, double dz,\n                    double epsilon, double W0, double tau0)\n{\n    for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n\n        if ((ix < (DATAXSIZE-1)) && (iy < (DATAYSIZE-1)) && \n            (iz < (DATAZSIZE-1)) && (ix > (0)) && \n            (iy > (0)) && (iz > (0))) {\n\n          double phix = GradientX(phi,dx,dy,dz,ix,iy,iz);\n          double phiy = GradientY(phi,dx,dy,dz,ix,iy,iz);\n          double phiz = GradientZ(phi,dx,dy,dz,ix,iy,iz);\n          double sqGphi = SQ(phix) + SQ(phiy) + SQ(phiz);\n          double c = 16.0 * W0 * epsilon;\n          double w = Wn(phix,phiy,phiz,epsilon,W0);\n          double w2 = SQ(w);\n          \n\n          Fx[ix][iy][iz] = w2 * phix + sqGphi * w * c * dFunc(phix,phiy,phiz);\n          Fy[ix][iy][iz] = w2 * phiy + sqGphi * w * c * dFunc(phiy,phiz,phix);\n          Fz[ix][iy][iz] = w2 * phiz + sqGphi * w * c * dFunc(phiz,phix,phiy);\n        }\n        else\n        {\n          Fx[ix][iy][iz] = 0.0;\n          Fy[ix][iy][iz] = 0.0;\n          Fz[ix][iy][iz] = 0.0;\n        }\n      }\n    }\n  }\n}\n\n\n\nvoid allenCahn(double phinew[][DATAYSIZE][DATAXSIZE], \n               double phiold[][DATAYSIZE][DATAXSIZE],\n               double uold[][DATAYSIZE][DATAXSIZE],\n               double Fx[][DATAYSIZE][DATAXSIZE],\n               double Fy[][DATAYSIZE][DATAXSIZE],\n               double Fz[][DATAYSIZE][DATAXSIZE],\n               double epsilon, double W0, double tau0, double lambda,\n               double dt, double dx, double dy, double dz)\n{\n    for (int ix = 1; ix < DATAXSIZE-1; ix++) {\n    for (int iy = 1; iy < DATAYSIZE-1; iy++) {\n      for (int iz = 1; iz < DATAZSIZE-1; iz++) {\n\n        double phix = GradientX(phiold,dx,dy,dz,ix,iy,iz);\n        double phiy = GradientY(phiold,dx,dy,dz,ix,iy,iz);\n        double phiz = GradientZ(phiold,dx,dy,dz,ix,iy,iz); \n\n        phinew[ix][iy][iz] = phiold[ix][iy][iz] + \n         (dt / taun(phix,phiy,phiz,epsilon,tau0)) * \n         (Divergence(Fx,Fy,Fz,dx,dy,dz,ix,iy,iz) - \n          dFphi(phiold[ix][iy][iz], uold[ix][iy][iz],lambda));\n      }\n    }\n  }\n}\n\nvoid boundaryConditionsPhi(double phinew[][DATAYSIZE][DATAXSIZE])\n{\n    for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n\n        if (ix == 0){\n          phinew[ix][iy][iz] = -1.0;\n        }\n        else if (ix == DATAXSIZE-1){\n          phinew[ix][iy][iz] = -1.0;\n        }\n        else if (iy == 0){\n          phinew[ix][iy][iz] = -1.0;\n        }\n        else if (iy == DATAYSIZE-1){\n          phinew[ix][iy][iz] = -1.0;\n        }\n        else if (iz == 0){\n          phinew[ix][iy][iz] = -1.0;\n        }\n        else if (iz == DATAZSIZE-1){\n          phinew[ix][iy][iz] = -1.0;\n        }\n      }\n    }\n  }\n}\n\nvoid thermalEquation(double unew[][DATAYSIZE][DATAXSIZE],\n                     double uold[][DATAYSIZE][DATAXSIZE],\n                     double phinew[][DATAYSIZE][DATAXSIZE],\n                     double phiold[][DATAYSIZE][DATAXSIZE],\n                     double D, double dt, double dx, double dy, double dz)\n{\n    for (int ix = 1; ix < DATAXSIZE-1; ix++) {\n    for (int iy = 1; iy < DATAYSIZE-1; iy++) {\n      for (int iz = 1; iz < DATAZSIZE-1; iz++) {\n\n        unew[ix][iy][iz] = uold[ix][iy][iz] + \n          0.5*(phinew[ix][iy][iz]-\n               phiold[ix][iy][iz]) +\n          dt * D * Laplacian(uold,dx,dy,dz,ix,iy,iz);\n      }\n    }\n  }\n}\n\nvoid boundaryConditionsU(double unew[][DATAYSIZE][DATAXSIZE], double delta)\n{\n    for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n\n        if (ix == 0){\n          unew[ix][iy][iz] =  -delta;\n        }\n        else if (ix == DATAXSIZE-1){\n          unew[ix][iy][iz] =  -delta;\n        }\n        else if (iy == 0){\n          unew[ix][iy][iz] =  -delta;\n        }\n        else if (iy == DATAYSIZE-1){\n          unew[ix][iy][iz] =  -delta;\n        }\n        else if (iz == 0){\n          unew[ix][iy][iz] =  -delta;\n        }\n        else if (iz == DATAZSIZE-1){\n          unew[ix][iy][iz] =  -delta;\n        }\n      }\n    }\n  }\n}\n\nvoid swapGrid(double cnew[][DATAYSIZE][DATAXSIZE],\n              double cold[][DATAYSIZE][DATAXSIZE])\n{\n    for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n        double tmp = cnew[ix][iy][iz];\n        cnew[ix][iy][iz] = cold[ix][iy][iz];\n        cold[ix][iy][iz] = tmp;\n      }\n    }\n  }\n}\n\nvoid initializationPhi(double phi[][DATAYSIZE][DATAXSIZE], double r0)\n{\n    for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n        double r = std::sqrt(SQ(ix-0.5*DATAXSIZE) + SQ(iy-0.5*DATAYSIZE) + SQ(iz-0.5*DATAZSIZE));\n        if (r < r0){\n          phi[ix][iy][iz] = 1.0;\n        }\n        else\n        {\n          phi[ix][iy][iz] = -1.0;\n        }\n      }\n    }\n  }\n}\n\nvoid initializationU(double u[][DATAYSIZE][DATAXSIZE], double r0, double delta)\n{\n    for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n        double r = std::sqrt(SQ(ix-0.5*DATAXSIZE) + SQ(iy-0.5*DATAYSIZE) + SQ(iz-0.5*DATAZSIZE));\n        if (r < r0) {\n          u[ix][iy][iz] = 0.0;\n        }\n        else\n        {\n          u[ix][iy][iz] = -delta * (1.0 - std::exp(-(r-r0)));\n        }\n      }\n    }\n  }\n}\n\nint main(int argc, char *argv[])\n{\n  const int num_steps = atoi(argv[1]);  \n\n  const double dx = 0.4;\n  const double dy = 0.4;\n  const double dz = 0.4;\n  const double dt = 0.01;\n  const double delta = 0.8;\n  const double r0 = 5.0;\n  const double epsilon = 0.07;\n  const double W0 = 1.0;\n  const double beta0 = 0.0;\n  const double D = 2.0;\n  const double d0 = 0.5;\n  const double a1 = 1.25 / std::sqrt(2.0);\n  const double a2 = 0.64;\n  const double lambda = (W0*a1)/(d0);\n  const double tau0 = ((W0*W0*W0*a1*a2)/(d0*D)) + ((W0*W0*beta0)/(d0));\n\n  \n\n  const int nx = DATAXSIZE;\n  const int ny = DATAYSIZE;\n  const int nz = DATAZSIZE;\n  const int vol = nx * ny * nz;\n  const size_t vol_in_bytes = sizeof(double) * vol;\n\n  \n\n  nRarray *phi_host = (nRarray *)malloc(vol_in_bytes);\n  nRarray *u_host = (nRarray *)malloc(vol_in_bytes);\n  initializationPhi(phi_host,r0);\n  initializationU(u_host,r0,delta);\n\n#ifdef VERIFY\n  nRarray *phi_ref = (nRarray *)malloc(vol_in_bytes);\n  nRarray *u_ref = (nRarray *)malloc(vol_in_bytes);\n  memcpy(phi_ref, phi_host, vol_in_bytes);\n  memcpy(u_ref, u_host, vol_in_bytes);\n  reference(phi_ref, u_ref, vol, num_steps);\n#endif \n\n  auto offload_start = std::chrono::steady_clock::now();\n\n  \n\n  double *d_phiold = (double*)phi_host;\n  double *d_uold = (double*)u_host;\n  double *d_phinew = (double*) malloc (vol_in_bytes);\n  double *d_unew = (double*) malloc (vol_in_bytes);\n  double *d_Fx = (double*) malloc (vol_in_bytes);\n  double *d_Fy = (double*) malloc (vol_in_bytes);\n  double *d_Fz = (double*) malloc (vol_in_bytes);\n\n    {\n    int t = 0;\n\n    auto start = std::chrono::steady_clock::now();\n  \n    while (t <= num_steps) {\n  \n      calculateForce((nRarray*)d_phiold, (nRarray*)d_Fx,(nRarray*)d_Fy,(nRarray*)d_Fz,\n                     dx,dy,dz,epsilon,W0,tau0);\n  \n      allenCahn((nRarray*)d_phinew,(nRarray*)d_phiold,(nRarray*)d_uold,\n                (nRarray*)d_Fx,(nRarray*)d_Fy,(nRarray*)d_Fz,\n                epsilon,W0,tau0,lambda, dt,dx,dy,dz);\n  \n      boundaryConditionsPhi((nRarray*)d_phinew);\n  \n      thermalEquation((nRarray*)d_unew,(nRarray*)d_uold,(nRarray*)d_phinew,(nRarray*)d_phiold,\n                      D,dt,dx,dy,dz);\n  \n      boundaryConditionsU((nRarray*)d_unew,delta);\n  \n      swapGrid((nRarray*)d_phinew, (nRarray*)d_phiold);\n  \n      swapGrid((nRarray*)d_unew, (nRarray*)d_uold);\n  \n      t++;\n    }\n  \n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Total kernel execution time: %.3f (ms)\\n\", time * 1e-6f);\n  }\n\n  auto offload_end = std::chrono::steady_clock::now();\n  auto offload_time = std::chrono::duration_cast<std::chrono::nanoseconds>(offload_end - offload_start).count();\n  printf(\"Offload time: %.3f (ms)\\n\", offload_time * 1e-6f);\n\n#ifdef VERIFY\n  bool ok = true;\n  for (int idx = 0; idx < nx; idx++)\n    for (int idy = 0; idy < ny; idy++)\n      for (int idz = 0; idz < nz; idz++) {\n        if (fabs(phi_ref[idx][idy][idz] - phi_host[idx][idy][idz]) > 1e-3) {\n          ok = false; printf(\"phi: %lf %lf\\n\", phi_ref[idx][idy][idz], phi_host[idx][idy][idz]);\n\t}\n        if (fabs(u_ref[idx][idy][idz] - u_host[idx][idy][idz]) > 1e-3) {\n          ok = false; printf(\"u: %lf %lf\\n\", u_ref[idx][idy][idz], u_host[idx][idy][idz]);\n        }\n      }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n  free(phi_ref);\n  free(u_ref);\n#endif\n\n  free(phi_host);\n  free(u_host);\n  free(d_phinew);\n  free(d_unew);\n  free(d_Fx);\n  free(d_Fy);\n  free(d_Fz);\n  return 0;\n}"}}
// {"kernel_name": "atomicIntrinsics", "parallel_api": "serial", "code": {"main.cpp": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <chrono>\n\n#include \"reference.h\"\n\ntemplate <class T>\nvoid testcase(const int repeat)\n{\n  const int len = 1 << 10;\n  unsigned int numThreads = 256;\n  unsigned int numData = 9;\n  unsigned int memSize = sizeof(T) * numData;\n  const T data[] = {0, 0, (T)-256, 256, 255, 0, 255, 0, 0};\n  T gpuData[9];\n\n    {\n    for (int n = 0; n < repeat; n++) {\n      memcpy(gpuData, data, memSize);\n      \n            for (int i = 0; i < len; ++i)\n      {\n                   gpuData[0] += (T)10;\n                   gpuData[1] -= (T)10;\n                   gpuData[4] &= (T)(2*i+7);\n                   gpuData[5] |= (T)(1 << i);\n                   gpuData[6] ^= (T)i;\n      }\n\n            for (int i = 0; i < len; ++i)\n         gpuData[2] = max(gpuData[2], (T)i);\n\n            for (int i = 0; i < len; ++i)\n         gpuData[3] = min(gpuData[3], (T)i);\n    }\n\n        // Compute expected values for atomicInc/Dec slots to match CUDA semantics\n        const T incLimit = (T)17;\n        const T decLimit = (T)137;\n        gpuData[7] = (T)(len % (incLimit + 1));\n        gpuData[8] = (T)(decLimit - ((len - 1) % (decLimit + 1)));\n\n        computeGold<T>(gpuData, len);\n\n    auto start = std::chrono::steady_clock::now();\n\n    for (int n = 0; n < repeat; n++) {\n      \n            for (int i = 0; i < len; ++i)\n      {\n                   gpuData[0] += (T)10;\n                   gpuData[1] -= (T)10;\n                   gpuData[4] &= (T)(2*i+7);\n                   gpuData[5] |= (T)(1 << i);\n                   gpuData[6] ^= (T)i;\n      }\n\n            for (int i = 0; i < len; ++i)\n         gpuData[2] = max(gpuData[2], (T)i);\n\n            for (int i = 0; i < len; ++i)\n         gpuData[3] = min(gpuData[3], (T)i);\n    }\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time: %f (us)\\n\", (time * 1e-3f) / repeat);\n  }\n}\n\nint main(int argc, char **argv)\n{\n  if (argc != 2) {\n    printf(\"Usage: %s <repeat>\\n\", argv[0]);\n    return 1;\n  }\n\n  const int repeat = atoi(argv[1]);\n  testcase<int>(repeat);\n  testcase<unsigned int>(repeat);\n  return 0;\n}\n"}}
// {"kernel_name": "convolution1D", "parallel_api": "serial", "code": {"main.cpp": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <chrono>\n#include <omp.h>\n\n#define MAX_MASK_WIDTH 10\n#define BLOCK_SIZE 256\n#define TILE_SIZE BLOCK_SIZE\n\ntemplate<typename T>\nvoid conv1d(const T * __restrict__ mask,\n            const T * __restrict__ in,\n                  T * __restrict__ out,\n            const int input_width,\n            const int mask_width)\n{\n    for (int i = 0; i < input_width; i++) {\n    T s = 0;\n    int start = i - mask_width / 2;\n    for (int j = 0; j < mask_width; j++) {\n      if (start + j >= 0 && start + j < input_width) {\n        s += in[start + j] * mask[j];\n      }\n    }\n    out[i] = s;\n  }\n}\n\ntemplate<typename T>\nvoid conv1d_tiled(const T *__restrict__ mask,\n                  const T *__restrict__ in,\n                        T *__restrict__ out,\n                  const int input_width,\n                  const int mask_width)\n{\n  // Serial tiling: fill full halo regions explicitly, then compute the stencil\n  T tile[TILE_SIZE + MAX_MASK_WIDTH - 1];\n  const int radius = mask_width / 2;\n\n  for (int blockStart = 0; blockStart < input_width; blockStart += TILE_SIZE) {\n    // Left halo\n    for (int t = 0; t < radius; t++) {\n      const int src = blockStart - radius + t;\n      tile[t] = (src >= 0) ? in[src] : (T)0;\n    }\n\n    // Center tile\n    for (int t = 0; t < TILE_SIZE; t++) {\n      const int src = blockStart + t;\n      tile[radius + t] = (src < input_width) ? in[src] : (T)0;\n    }\n\n    // Right halo\n    for (int t = 0; t < radius; t++) {\n      const int src = blockStart + TILE_SIZE + t;\n      tile[radius + TILE_SIZE + t] = (src < input_width) ? in[src] : (T)0;\n    }\n\n    // Convolution for this block\n    for (int t = 0; t < TILE_SIZE && (blockStart + t) < input_width; t++) {\n      T s = 0;\n      for (int j = 0; j < mask_width; j++) {\n        s += tile[t + j] * mask[j];\n      }\n      out[blockStart + t] = s;\n    }\n  }\n}\n\ntemplate<typename T>\nvoid conv1d_tiled_caching(const T *__restrict__ mask,\n                          const T *__restrict__ in,\n                                T *__restrict__ out,\n                          const int input_width,\n                          const int mask_width)\n{\n    {\n    T tile[TILE_SIZE];\n        {\n      int bid = omp_get_team_num();\n      int lid = omp_get_thread_num();\n      int dim = omp_get_num_threads();\n      int i = bid * dim + lid;\n      tile[lid] = in[i];\n      \n      int this_tile_start = bid * dim;\n      int next_tile_start = (bid + 1) * dim;\n      int start = i - (mask_width / 2);\n      T s = 0;\n      for (int j = 0; j < mask_width; j++) {\n        int in_index = start + j;\n        if (in_index >= 0 && in_index < input_width) {\n          if (in_index >= this_tile_start && in_index < next_tile_start) {\n            s += tile[lid + j - (mask_width / 2)] * mask[j];\n          } else {\n            s += in[in_index] * mask[j];\n          }\n        }\n      }\n      out[i] = s;\n    }\n  }\n}\n\ntemplate <typename T>\nvoid reference(const T *h_in,\n               const T *d_out,\n               const T *mask,\n               const int input_width,\n               const int mask_width)\n{\n  bool ok = true;\n  for (int i = 0; i < input_width; i++) {\n    T s = 0;\n    int start = i - mask_width / 2;\n    for (int j = 0; j < mask_width; j++) {\n      if (start + j >= 0 && start + j < input_width) {\n        s += h_in[start + j] * mask[j];\n      }\n    }\n    if (fabs(s - d_out[i]) > 1e-3) {\n      ok = false;\n      break;\n    }\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n}\n\ntemplate <typename T>\nvoid conv1D(const int input_width, const int mask_width, const int repeat)\n{\n  size_t size_bytes = input_width * sizeof(T);\n\n  T *a, *b;\n  a = (T *)malloc(size_bytes); \n\n  b = (T *)malloc(size_bytes); \n\n\n  T mask[MAX_MASK_WIDTH];\n\n  for (int i = 0; i < MAX_MASK_WIDTH; i++) mask[i] = 1; \n\n  srand(123);\n  for (int i = 0; i < input_width; i++) {\n    a[i] = rand() % 256;\n  }\n\n    {\n    \n\n    auto start = std::chrono::steady_clock::now();\n    for (int i = 0; i < repeat; i++) {\n      conv1d(mask, a, b, input_width, mask_width);\n    }\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time of conv1d kernel: %f (us)\\n\",\n           (time * 1e-3f) / repeat);\n        reference(a, b, mask, input_width, mask_width);\n\n    \n\n    start = std::chrono::steady_clock::now();\n    for (int i = 0; i < repeat; i++) {\n      conv1d_tiled(mask, a, b, input_width, mask_width);\n    }\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time of conv1d-tiled kernel: %f (us)\\n\",\n           (time * 1e-3f) / repeat);\n        reference(a, b, mask, input_width, mask_width);\n\n    \n\n    start = std::chrono::steady_clock::now();\n    for (int i = 0; i < repeat; i++) {\n      conv1d_tiled_caching(mask, a, b, input_width, mask_width);\n    }\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time of conv1d-tiled-caching kernel: %f (us)\\n\",\n           (time * 1e-3f) / repeat);\n        reference(a, b, mask, input_width, mask_width);\n  }\n\n  free(a);\n  free(b);\n}\n\nint main(int argc, char* argv[]) {\n  if (argc != 3) {\n    printf(\"Usage: %s <input_width> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n\n  int input_width = atoi(argv[1]);\n  \n\n  input_width = (input_width + BLOCK_SIZE - 1) / BLOCK_SIZE * BLOCK_SIZE;\n\n  const int repeat = atoi(argv[2]);\n\n  for (int mask_width = 3; mask_width < MAX_MASK_WIDTH; mask_width += 2) {\n    printf(\"\\n---------------------\\n\");\n    printf(\"Mask width: %d\\n\", mask_width); \n\n    printf(\"1D convolution (FP64)\\n\");\n    conv1D<double>(input_width, mask_width, repeat);\n\n    printf(\"1D convolution (FP32)\\n\");\n    conv1D<float>(input_width, mask_width, repeat);\n\n    printf(\"1D convolution (INT16)\\n\");\n    conv1D<int16_t>(input_width, mask_width, repeat);\n  }\n\n  return 0;\n}\n"}}
// {"kernel_name": "geodesic", "parallel_api": "serial", "code": {"main.cpp": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <chrono>\n#include <cmath>\n\ntypedef struct __attribute__((__aligned__(16)))\n{\n  float x;\n  float y;\n  float z;\n  float w;\n} float4;\n\nfloat  distance_host ( int i, float latitude_1, float longitude_1,\n                       float latitude_2, float longitude_2 )\n{\n  float  dist ;\n  float  rad_latitude_1 ;\n  float  rad_latitude_2 ;\n  float  rad_longitude_1 ;\n  float  rad_longitude_2 ;\n\n  float  BAZ , C , C2A , CU1 , CU2 , CX , CY , CZ ,\n         D , E , FAZ , SA , SU1 , SX  , SY , TU1 , TU2 , X , Y ; \n\n  const float GDC_DEG_TO_RAD = 3.141592654 / 180.0 ;  \n\n  const float GDC_FLATTENING = 1.0 - ( 6356752.31424518 / 6378137.0 ) ; \n  const float GDC_ECCENTRICITY = ( 6356752.31424518 / 6378137.0 ) ; \n  const float GDC_ELLIPSOIDAL =  1.0 / ( 6356752.31414 / 6378137.0 ) / ( 6356752.31414 / 6378137.0 ) - 1.0 ;\n  const float GDC_SEMI_MINOR = 6356752.31424518f;\n  const float EPS = 0.5e-5f;\n\n  rad_longitude_1 = longitude_1 * GDC_DEG_TO_RAD ;\n  rad_latitude_1 = latitude_1 * GDC_DEG_TO_RAD ;\n  rad_longitude_2 = longitude_2 * GDC_DEG_TO_RAD ;\n  rad_latitude_2 = latitude_2 * GDC_DEG_TO_RAD ;\n\n  TU1 = GDC_ECCENTRICITY * sinf ( rad_latitude_1 ) /\n    cosf ( rad_latitude_1 ) ;\n  TU2 = GDC_ECCENTRICITY * sinf ( rad_latitude_2 ) /\n    cosf ( rad_latitude_2 ) ;\n\n  CU1 = 1.0f / sqrtf ( TU1 * TU1 + 1.0f ) ;\n  SU1 = CU1 * TU1 ;\n  CU2 = 1.0f / sqrtf ( TU2 * TU2 + 1.0f ) ;\n  dist = CU1 * CU2 ;\n  BAZ = dist * TU2 ;\n  FAZ = BAZ * TU1 ;\n  X = rad_longitude_2 - rad_longitude_1 ;\n\n  do {\n    SX = sinf ( X ) ;\n    CX = cosf ( X ) ;\n    TU1 = CU2 * SX ;\n    TU2 = BAZ - SU1 * CU2 * CX ;\n    SY = sqrtf ( TU1 * TU1 + TU2 * TU2 ) ;\n    CY = dist * CX + FAZ ;\n    Y = atan2f ( SY, CY ) ;\n    SA = dist * SX / SY ;\n    C2A = - SA * SA + 1.0f;\n    CZ = FAZ + FAZ ;\n    if ( C2A > 0.0f ) CZ = -CZ / C2A + CY ;\n    E = CZ * CZ * 2.0f - 1.0f ;\n    C = ( ( -3.0f * C2A + 4.0f ) * GDC_FLATTENING + 4.0f ) * C2A *\n      GDC_FLATTENING / 16.0f ;\n    D = X ;\n    X = ( ( E * CY * C + CZ ) * SY * C + Y ) * SA ;\n    X = ( 1.0f - C ) * X * GDC_FLATTENING + rad_longitude_2 - rad_longitude_1 ;\n  } while ( fabsf ( D - X ) > EPS );\n\n  X = sqrtf ( GDC_ELLIPSOIDAL * C2A + 1.0f ) + 1.0f ;\n  X = ( X - 2.0f ) / X ;\n  C = 1.0f - X ;\n  C = ( X * X / 4.0f + 1.0f ) / C ;\n  D = ( 0.375f * X * X - 1.0f ) * X ;\n  X = E * CY ;\n  dist = 1.0f - E - E ;\n  dist = ( ( ( ( SY * SY * 4.0f - 3.0f ) * dist * CZ * D / 6.0f -\n          X ) * D / 4.0f + CZ ) * SY * D + Y ) * C * GDC_SEMI_MINOR ;\n  return dist;\n}\n\nvoid distance_device(const float4* VA, float* VC, const size_t N, const int iteration) {\n\n    {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int n = 0; n < iteration; n++) {\n\n            for (int wiID = 0; wiID < N; wiID++) {\n\n        const float GDC_DEG_TO_RAD = 3.141592654 / 180.0 ;  \n\n        const float GDC_FLATTENING = 1.0 - ( 6356752.31424518 / 6378137.0 ) ; \n        const float GDC_ECCENTRICITY = ( 6356752.31424518 / 6378137.0 ) ; \n        const float GDC_ELLIPSOIDAL =  1.0 / ( 6356752.31414 / 6378137.0 ) / ( 6356752.31414 / 6378137.0 ) - 1.0 ;\n        const float GDC_SEMI_MINOR = 6356752.31424518f;\n        const float EPS = 0.5e-5f;\n        float  dist, BAZ , C , C2A , CU1 , CU2 , CX , CY , CZ ,\n               D , E , FAZ , SA , SU1 , SX  , SY , TU1 , TU2 , X , Y ; \n\n        const float rad_latitude_1  = VA[wiID].x * GDC_DEG_TO_RAD ;\n        const float rad_longitude_1 = VA[wiID].y * GDC_DEG_TO_RAD ;\n        const float rad_latitude_2  = VA[wiID].z * GDC_DEG_TO_RAD ;\n        const float rad_longitude_2 = VA[wiID].w * GDC_DEG_TO_RAD ;\n\n        TU1 = GDC_ECCENTRICITY * sinf ( rad_latitude_1 ) /\n          cosf ( rad_latitude_1 ) ;\n        TU2 = GDC_ECCENTRICITY * sinf ( rad_latitude_2 ) /\n          cosf ( rad_latitude_2 ) ;\n\n        CU1 = 1.0f / sqrtf ( TU1 * TU1 + 1.0f ) ;\n        SU1 = CU1 * TU1 ;\n        CU2 = 1.0f / sqrtf ( TU2 * TU2 + 1.0f ) ;\n        dist = CU1 * CU2 ;\n        BAZ = dist * TU2 ;\n        FAZ = BAZ * TU1 ;\n        X = rad_longitude_2 - rad_longitude_1 ;\n\n        do {\n          SX = sinf ( X ) ;\n          CX = cosf ( X ) ;\n          TU1 = CU2 * SX ;\n          TU2 = BAZ - SU1 * CU2 * CX ;\n          SY = sqrtf ( TU1 * TU1 + TU2 * TU2 ) ;\n          CY = dist * CX + FAZ ;\n          Y = atan2f ( SY, CY ) ;\n          SA = dist * SX / SY ;\n          C2A = - SA * SA + 1.0f;\n          CZ = FAZ + FAZ ;\n          if ( C2A > 0.0f ) CZ = -CZ / C2A + CY ;\n          E = CZ * CZ * 2.0f - 1.0f ;\n          C = ( ( -3.0f * C2A + 4.0f ) * GDC_FLATTENING + 4.0f ) * C2A *\n            GDC_FLATTENING / 16.0f ;\n          D = X ;\n          X = ( ( E * CY * C + CZ ) * SY * C + Y ) * SA ;\n          X = ( 1.0f - C ) * X * GDC_FLATTENING + rad_longitude_2 - rad_longitude_1 ;\n        } while ( fabsf ( D - X ) > EPS ) ;\n\n        X = sqrtf ( GDC_ELLIPSOIDAL * C2A + 1.0f ) + 1.0f ;\n        X = ( X - 2.0f ) / X ;\n        C = 1.0f - X ;\n        C = ( X * X / 4.0f + 1.0f ) / C ;\n        D = ( 0.375f * X * X - 1.0f ) * X ;\n        X = E * CY ;\n        dist = 1.0f - E - E ;\n        dist = ( ( ( ( SY * SY * 4.0f - 3.0f ) * dist * CZ * D / 6.0f -\n                X ) * D / 4.0f + CZ ) * SY * D + Y ) * C * GDC_SEMI_MINOR ;\n        VC[wiID] = dist;\n      }\n    }\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time %f (s)\\n\", (time * 1e-9f) / iteration);\n  }\n}\n\nvoid verify(int size, const float *output, const float *expected_output) {\n  float error_rate = 0;\n  for (int i = 0; i < size; i++) {\n    if (fabs(output[i] - expected_output[i]) > error_rate) {\n      error_rate = fabs(output[i] - expected_output[i]);\n    }\n  }\n  printf(\"The maximum error in distance for single precision is %f\\n\", error_rate); \n}\n\nint main(int argc, char** argv) {\n  if (argc != 2) {\n    printf(\"Usage %s <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  int iteration = atoi(argv[1]);\n\n  int num_cities = 2097152; \n\n  int num_ref_cities = 6; \n\n  int index_map[] ={436483, 1952407, 627919, 377884, 442703, 1863423};\n  int N = num_cities * num_ref_cities;\n  int city = 0;\n  float lat, lon;\n\n  const char* filename = \"locations.txt\";\n  printf(\"Reading city locations from file %s...\\n\", filename);\n  FILE* fp = fopen(filename, \"r\");\n  if (fp == NULL) {\n    perror (\"Error opening the file\");\n    exit(-1);\n  }\n\n  float4* input  = (float4*) aligned_alloc(4096, N*sizeof(float4));\n  float*  output = (float*) aligned_alloc(4096, N*sizeof(float));\n  float*  expected_output = (float*) malloc(N*sizeof(float));\n\n  while (fscanf(fp, \"%f %f\\n\", &lat, &lon) != EOF) { \n    input[city].x = lat;\n    input[city].y = lon;\n    city++;\n    if (city == num_cities) break;  \n  }\n  fclose(fp);\n\n  \n\n  for (int c = 1;  c < num_ref_cities; c++) {\n    std::copy(input, input+num_cities, input+c*num_cities);\n  }\n  \n\n  for (int c = 0;  c < num_ref_cities; c++) {\n    int index = index_map[c] - 1;\n    for(int j = c*num_cities; j < (c+1)*num_cities; ++j) {\n      input[j].z = input[index].x;\n      input[j].w = input[index].y;\n    }\n  }\n\n  \n\n  for (int i = 0; i < N; i++)\n  {\n    float lat1 = input[i].x;\n    float lon1 = input[i].y;\n    float lat2 = input[i].z;\n    float lon2 = input[i].w;\n    expected_output[i] = distance_host(i, lat1, lon1, lat2, lon2);\n  }\n\n  distance_device(input, output, N, iteration);\n\n  verify(N, output, expected_output);\n\n  free(input);\n  free(output);\n  free(expected_output);\n  return 0;\n}"}}
// {"kernel_name": "heat", "parallel_api": "serial", "code": {"main.cpp": "\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n\n\n#define PI acos(-1.0) \n\n#define LINE \"--------------------\\n\" \n\n\ndouble solution(const double t, const double x, const double y, const double alpha, const double length);\ndouble l2norm(const int n, const double * __restrict u, const int nsteps, const double dt, const double alpha, const double dx, const double length);\n\nint main(int argc, char *argv[]) {\n\n  \n\n  double start = omp_get_wtime();\n\n  \n\n  int n = 1000;\n\n  \n\n  int nsteps = 10;\n\n  \n\n  \n\n  if (argc == 3) {\n\n    \n\n    n = atoi(argv[1]);\n    if (n < 0) {\n      fprintf(stderr, \"Error: n must be positive\\n\");\n      exit(EXIT_FAILURE);\n    }\n\n    \n\n    nsteps = atoi(argv[2]);\n    if (nsteps < 0) {\n      fprintf(stderr, \"Error: nsteps must be positive\\n\");\n      exit(EXIT_FAILURE);\n    }\n  }\n\n  \n\n  \n\n  \n\n  double alpha = 0.1;          \n\n  double length = 1000.0;      \n\n  double dx = length / (n+1);  \n\n  double dt = 0.5 / nsteps;    \n\n\n  \n\n  double r = alpha * dt / (dx * dx);\n\n  \n\n  printf(\"\\n\");\n  printf(\" MMS heat equation\\n\\n\");\n  printf(LINE);\n  printf(\"Problem input\\n\\n\");\n  printf(\" Grid size: %d x %d\\n\", n, n);\n  printf(\" Cell width: %E\\n\", dx);\n  printf(\" Grid length: %lf x %lf\\n\", length, length);\n  printf(\"\\n\");\n  printf(\" Alpha: %E\\n\", alpha);\n  printf(\"\\n\");\n  printf(\" Steps: %d\\n\", nsteps);\n  printf(\" Total time: %E\\n\", dt*(double)nsteps);\n  printf(\" Time step: %E\\n\", dt);\n  printf(LINE);\n\n  \n\n  printf(\"Stability\\n\\n\");\n  printf(\" r value: %lf\\n\", r);\n  if (r > 0.5)\n    printf(\" Warning: unstable\\n\");\n  printf(LINE);\n\n  \n\n  double *u     = (double*) malloc(sizeof(double)*n*n);\n  double *u_tmp = (double*) malloc(sizeof(double)*n*n);\n\n  double tic, toc;\n  const int block_size = 256;\n\n{\n  \n\n    for (int j = 0; j < n; ++j) {\n    for (int i = 0; i < n; ++i) {\n      double y = (j+1)*dx; \n\n      double x = (i+1)*dx; \n\n      u[i+j*n] = sin(PI * x / length) * sin(PI * y / length);\n    }\n  }\n\n    for (int j = 0; j < n; ++j) {\n    for (int i = 0; i < n; ++i) {\n      u_tmp[i+j*n] = 0.0;\n    }\n  }\n\n  \n\n  \n\n  \n\n\n  \n\n  const double r2 = 1.0 - 4.0*r;\n\n  \n\n  tic = omp_get_wtime();\n\n  for (int t = 0; t < nsteps; ++t) {\n\n    \n\n    \n\n    \n\n    \n\n        for (int j = 0; j < n; ++j) {\n      for (int i = 0; i < n; ++i) {\n        \n\n        \n\n        u_tmp[i+j*n] =  r2 * u[i+j*n] +\n        r * ((i < n-1) ? u[i+1+j*n] : 0.0) +\n        r * ((i > 0)   ? u[i-1+j*n] : 0.0) +\n        r * ((j < n-1) ? u[i+(j+1)*n] : 0.0) +\n        r * ((j > 0)   ? u[i+(j-1)*n] : 0.0);\n      }\n    }\n\n    \n\n    double *tmp = u;\n    u = u_tmp;\n    u_tmp = tmp;\n  }\n  \n\n  toc = omp_get_wtime();\n}\n\n  \n\n  \n\n  \n\n  \n\n  double norm = l2norm(n, u, nsteps, dt, alpha, dx, length);\n\n  \n\n  double stop = omp_get_wtime();\n\n  \n\n  printf(\"Results\\n\\n\");\n  printf(\"Error (L2norm): %E\\n\", norm);\n  printf(\"Solve time (s): %lf\\n\", toc-tic);\n  printf(\"Total time (s): %lf\\n\", stop-start);\n  printf(\"Bandwidth (GB/s): %lf\\n\", 1.0E-9*2.0*n*n*nsteps*sizeof(double)/(toc-tic));\n  printf(LINE);\n\n  \n\n  free(u);\n  free(u_tmp);\n}\n\n\n\n\ndouble solution(const double t, const double x, const double y, const double alpha, const double length) {\n\n  return exp(-2.0*alpha*PI*PI*t/(length*length)) * sin(PI*x/length) * sin(PI*y/length);\n\n}\n\n\n\n\n\n\ndouble l2norm(const int n, const double * u, const int nsteps, const double dt,\n              const double alpha, const double dx, const double length) {\n\n  \n\n  double time = dt * (double)nsteps;\n\n  \n\n  double l2norm = 0.0;\n\n  \n\n  double y = dx;\n  for (int j = 0; j < n; ++j) {\n    double x = dx;\n    for (int i = 0; i < n; ++i) {\n      double answer = solution(time, x, y, alpha, length);\n      l2norm += (u[i+j*n] - answer) * (u[i+j*n] - answer);\n\n      x += dx;\n    }\n    y += dx;\n  }\n\n  return sqrt(l2norm);\n}"}}
// {"kernel_name": "keogh", "parallel_api": "serial", "code": {"main.cpp": "#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <chrono>\n#include \"reference.h\"\n\nint main(int argc, char* argv[]) {\n\n  if (argc != 4) {\n    printf(\"Usage: ./%s <query length> <subject length> <repeat>\\n\", argv[0]);\n    return -1;\n  }\n\n  const int M = atoi(argv[1]);\n  const int N = atoi(argv[2]);\n  const int repeat = atoi(argv[3]);\n\n  printf(\"Query length = %d\\n\", M);\n  printf(\"Subject length = %d\\n\", N);\n\n  \n\n  float *subject = (float*) malloc (sizeof(float)*N);\n  float *lower_bound = (float*) malloc (sizeof(float)*N);\n  float *upper_bound = (float*) malloc (sizeof(float)*N);\n  float *lb = (float*) malloc (sizeof(float)*(N-M+1));\n  float *lb_h = (float*) malloc (sizeof(float)*(N-M+1));\n  float *avgs = (float*) malloc (sizeof(float)*(N-M+1));\n  float *stds = (float*) malloc (sizeof(float)*(N-M+1));\n\n  srand(123);\n  for (int i = 0; i < N; ++i) subject[i] = (float)rand() / (float)RAND_MAX;\n  for (int i = 0; i < N-M+1; ++i) avgs[i] = (float)rand() / (float)RAND_MAX;\n  for (int i = 0; i < N-M+1; ++i) stds[i] = (float)rand() / (float)RAND_MAX;\n  for (int i = 0; i < M; ++i) upper_bound[i] = (float)rand() / (float)RAND_MAX;\n  for (int i = 0; i < M; ++i) lower_bound[i] = (float)rand() / (float)RAND_MAX;\n\n  const int blocks = 256;\n  const int grids = (N-M+1 + blocks - 1) / blocks;\n\n    {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++) {\n            for (int idx = 0; idx < N-M+1; idx++) {\n        \n\n        float residues = 0;\n        float avg = avgs[idx];\n        float std = stds[idx];\n\n                for (int i = 0; i < M; ++i) {\n          \n\n          float value = (subject[idx+i] - avg) / std;\n          float lower = value - lower_bound[i];\n          float upper = value - upper_bound[i];\n\n          \n\n          residues += upper*upper*(upper > 0) + lower*lower*(lower < 0);\n        }\n\n        lb[idx] = residues;\n      }\n    }\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time: %f (s)\\n\", (time * 1e-9f) / repeat);\n  }\n\n  \n\n  reference(subject, avgs, stds, lb_h, lower_bound, upper_bound, M, N);\n  bool ok = true;\n  for (int i = 0; i < N-M+1; i++) {\n    if (fabs(lb[i] - lb_h[i]) > 1e-3) {\n      printf(\"%d %f %f\\n\", i, lb[i], lb_h[i]);\n      ok = false;\n      break;\n    }\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n\n  free(lb);\n  free(lb_h);\n  free(avgs);\n  free(stds);\n  free(subject);\n  free(lower_bound);\n  free(upper_bound);\n  return 0;\n}"}}
// {"kernel_name": "meanshift", "parallel_api": "serial", "code": {"main.cpp": "#include <math.h>\n#include <stdio.h>\n#include <chrono>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#include \"utils.h\"\n#include \"constants.h\"\n\nnamespace mean_shift::gpu {\n  void mean_shift(const float *data, float *data_next,\n                  const int teams, const int threads) {\n    (void)teams;\n    (void)threads;\n\n    for (size_t tid = 0; tid < N; tid++) {\n      size_t row = tid * D;\n      float new_position[D] = {0.f};\n      float tot_weight = 0.f;\n      for (size_t i = 0; i < N; ++i) {\n        size_t row_n = i * D;\n        float sq_dist = 0.f;\n        for (size_t j = 0; j < D; ++j) {\n          sq_dist += (data[row + j] - data[row_n + j]) * (data[row + j] - data[row_n + j]);\n        }\n        if (sq_dist <= RADIUS) {\n          float weight = expf(-sq_dist / DBL_SIGMA_SQ);\n          for (size_t j = 0; j < D; ++j) {\n            new_position[j] += weight * data[row_n + j];\n          }\n          tot_weight += weight;\n        }\n      }\n      if (tot_weight <= 0.f) {\n        for (size_t j = 0; j < D; ++j) {\n          data_next[row + j] = data[row + j];\n        }\n        continue;\n      }\n\n      const float inv_weight = 1.f / tot_weight;\n      for (size_t j = 0; j < D; ++j) {\n        data_next[row + j] = new_position[j] * inv_weight;\n      }\n    }\n  }\n\n  void mean_shift_tiling(const float* data, float* data_next,\n                         const int teams, const int threads) {\n    (void)teams;\n    (void)threads;\n\n    float tile_data[TILE_WIDTH * D];\n\n    for (size_t tid = 0; tid < N; ++tid) {\n      size_t row = tid * D;\n      float new_position[D] = {0.f};\n      float tot_weight = 0.f;\n\n      for (size_t tile_base = 0; tile_base < N; tile_base += TILE_WIDTH) {\n        size_t tile_count = std::min<size_t>(TILE_WIDTH, N - tile_base);\n        for (size_t i = 0; i < tile_count; ++i) {\n          size_t src_row = (tile_base + i) * D;\n          for (size_t j = 0; j < D; ++j) {\n            tile_data[i * D + j] = data[src_row + j];\n          }\n        }\n\n        for (size_t i = 0; i < tile_count; ++i) {\n          size_t local_row = i * D;\n          float sq_dist = 0.f;\n          for (size_t j = 0; j < D; ++j) {\n            float diff = data[row + j] - tile_data[local_row + j];\n            sq_dist += diff * diff;\n          }\n          if (sq_dist <= RADIUS) {\n            float weight = expf(-sq_dist / DBL_SIGMA_SQ);\n            for (size_t j = 0; j < D; ++j) {\n              new_position[j] += weight * tile_data[local_row + j];\n            }\n            tot_weight += weight;\n          }\n        }\n      }\n\n      if (tot_weight <= 0.f) {\n        for (size_t j = 0; j < D; ++j) {\n          data_next[row + j] = data[row + j];\n        }\n        continue;\n      }\n\n      const float inv_weight = 1.f / tot_weight;\n      for (size_t j = 0; j < D; ++j) {\n        data_next[row + j] = new_position[j] * inv_weight;\n      }\n    }\n  }\n}\n\nint main(int argc, char* argv[]) {\n  if (argc != 3) {\n    std::cout << \"Usage: \" << argv[0] << \" <path to data> <path to centroids>\" << std::endl;\n    return 1;\n  }\n  const auto path_to_data = argv[1];\n  const auto path_to_centroids = argv[2];\n\n  constexpr auto N = mean_shift::gpu::N;\n  constexpr auto D = mean_shift::gpu::D;\n  constexpr auto M = mean_shift::gpu::M;\n  constexpr auto THREADS = mean_shift::gpu::THREADS;\n  constexpr auto BLOCKS = mean_shift::gpu::BLOCKS;\n  constexpr auto TILE_WIDTH = mean_shift::gpu::TILE_WIDTH;\n  constexpr auto DIST_TO_REAL = mean_shift::gpu::DIST_TO_REAL;\n\n  mean_shift::gpu::utils::print_info(path_to_data, N, D, BLOCKS, THREADS, TILE_WIDTH);\n\n  const std::array<float, M * D> real = mean_shift::gpu::utils::load_csv<M, D>(path_to_centroids, ',');\n  std::array<float, N * D> data = mean_shift::gpu::utils::load_csv<N, D>(path_to_data, ',');\n  std::array<float, N * D> result = data;\n\n  const size_t total_elems = static_cast<size_t>(N) * D;\n  std::vector<float> buffer(total_elems);\n  float *d_data = result.data();\n  float *d_data_next = buffer.data();\n\n    {\n    auto start = std::chrono::steady_clock::now();\n\n    for (size_t i = 0; i < mean_shift::gpu::NUM_ITER; ++i) {\n      mean_shift::gpu::mean_shift(d_data, d_data_next, BLOCKS, THREADS);\n      mean_shift::gpu::utils::swap(d_data, d_data_next);\n    }\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    std::cout << \"\\nAverage execution time of mean-shift (base) \"\n              << (time * 1e-6f) / mean_shift::gpu::NUM_ITER << \" ms\\n\" << std::endl;\n\n    float *scratch = d_data;\n    std::copy(scratch, scratch + total_elems, result.begin());\n    d_data = result.data();\n    d_data_next = buffer.data();\n\n    auto centroids = mean_shift::gpu::utils::reduce_to_centroids<N, D>(result, mean_shift::gpu::MIN_DISTANCE);\n    bool are_close = mean_shift::gpu::utils::are_close_to_real<M, D>(centroids, real, DIST_TO_REAL);\n    if (centroids.size() == M && are_close)\n       std::cout << \"PASS\\n\";\n    else\n       std::cout << \"FAIL\\n\";\n\n    result = data;\n    d_data = result.data();\n    d_data_next = buffer.data();\n\n    start = std::chrono::steady_clock::now();\n    for (size_t i = 0; i < mean_shift::gpu::NUM_ITER; ++i) {\n      mean_shift::gpu::mean_shift_tiling(d_data, d_data_next, BLOCKS, THREADS);\n      mean_shift::gpu::utils::swap(d_data, d_data_next);\n    }\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    std::cout << \"\\nAverage execution time of mean-shift (opt) \"\n              << (time * 1e-6f) / mean_shift::gpu::NUM_ITER << \" ms\\n\" << std::endl;\n\n    float *scratch_opt = d_data;\n    std::copy(scratch_opt, scratch_opt + total_elems, result.begin());\n    d_data = result.data();\n    d_data_next = buffer.data();\n\n    centroids = mean_shift::gpu::utils::reduce_to_centroids<N, D>(result, mean_shift::gpu::MIN_DISTANCE);\n    are_close = mean_shift::gpu::utils::are_close_to_real<M, D>(centroids, real, DIST_TO_REAL);\n    if (centroids.size() == M && are_close)\n       std::cout << \"PASS\\n\";\n    else\n       std::cout << \"FAIL\\n\";\n  }\n\n  return 0;\n}\n"}}
// {"kernel_name": "michalewicz", "parallel_api": "serial", "code": {"main.cpp": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <chrono>\n#include <random>\n\n#define min(a,b) (a) < (b) ? (a) : (b)\n\ninline\nfloat michalewicz(const float *xValues, const int dim) {\n  float result = 0;\n  for (int i = 0; i < dim; ++i) {\n      float a = sinf(xValues[i]);\n      float b = sinf(((i + 1) * xValues[i] * xValues[i]) / (float)M_PI);\n      float c = powf(b, 20); \n\n      result += a * c;\n  }\n  return -1.0f * result;\n}\n\n\n\nvoid Error(float value, int dim) {\n  printf(\"Global minima = %f\\n\", value);\n  float trueMin = 0.0;\n  if (dim == 2)\n    trueMin = -1.8013;\n  else if (dim == 5)\n    trueMin = -4.687658;\n  else if (dim == 10)\n    trueMin = -9.66015;\n  printf(\"Error = %f\\n\", fabsf(trueMin - value));\n}\n\nint main(int argc, char* argv[])\n{\n  if (argc != 3) {\n    printf(\"Usage: %s <number of vectors> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  const size_t n = atol(argv[1]);\n  const int repeat = atoi(argv[2]);\n\n  \n\n  std::mt19937 gen(19937);\n  std::uniform_real_distribution<float> dis(0.0, 4.0);\n \n  \n\n  const int dims[] = {2, 5, 10}; \n\n  for (int d = 0; d < 3; d++) {\n\n    const int dim = dims[d];\n\n    const size_t size = n * dim;\n\n    const size_t size_bytes = size * sizeof(float);\n    \n    float *values = (float*) malloc (size_bytes);\n    \n    for (size_t i = 0; i < size; i++) {\n      values[i] = dis(gen);\n    }\n\n    float minValue = 0;\n    \n        {\n      auto start = std::chrono::steady_clock::now();\n\n      for (int i = 0; i < repeat; i++) {\n                for (size_t j = 0; j < n; j++) {\n          minValue = min(minValue, michalewicz(values + j * dim, dim));\n        }\n      }\n\n      auto end = std::chrono::steady_clock::now();\n      auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n      printf(\"Average execution time of kernel (dim = %d): %f (us)\\n\",\n             dim, (time * 1e-3f) / repeat);\n    }\n    Error(minValue, dim);\n    free(values);\n  }\n\n  return 0;\n}"}}
// {"kernel_name": "mixbench", "parallel_api": "serial", "code": {"main.cpp": "\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <math.h>\n#include <chrono>\n\n#define VECTOR_SIZE (8*1024*1024)\n#define granularity (8)\n#define fusion_degree (4)\n#define seed 0.1f\n\nvoid benchmark_func(float *cd, int grid_dim, int block_dim, int compute_iterations) { \n      \n    { \n        {\n      const unsigned int blockSize = block_dim;\n      const int stride = blockSize;\n      int idx = omp_get_team_num()*blockSize*granularity + omp_get_thread_num();\n      const int big_stride = omp_get_num_teams()*blockSize*granularity;\n      float tmps[granularity];\n      for(int k=0; k<fusion_degree; k++) {\n                for(int j=0; j<granularity; j++) {\n          \n\n          tmps[j] = cd[idx+j*stride+k*big_stride];\n\n          \n\n          for(int i=0; i<compute_iterations; i++)\n            tmps[j] = tmps[j]*tmps[j]+(float)seed;\n        }\n\n        \n\n        float sum = 0;\n                for(int j=0; j<granularity; j+=2)\n          sum += tmps[j]*tmps[j+1];\n\n                for(int j=0; j<granularity; j++)\n          cd[idx+k*big_stride] = sum;\n      }\n    }\n  }\n}\n\nvoid mixbenchGPU(long size, int repeat) {\n  const char *benchtype = \"compute with global memory (block strided)\";\n  printf(\"Trade-off type:%s\\n\", benchtype);\n  float *cd = (float*) malloc (size*sizeof(float));\n  for (int i = 0; i < size; i++) cd[i] = 0;\n\n  const long reduced_grid_size = size/granularity/128;\n  const int block_dim = 256;\n  const int grid_dim = reduced_grid_size/block_dim;\n\n    {\n    \n\n    for (int i = 0; i < repeat; i++) {\n      benchmark_func(cd, grid_dim, block_dim, i);\n    }\n\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++) {\n      benchmark_func(cd, grid_dim, block_dim, i);\n    }\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Total kernel execution time: %f (s)\\n\", time * 1e-9f);\n  }\n\n  \n\n  bool ok = true;\n  for (int i = 0; i < size; i++) {\n    if (cd[i] != 0) {\n      if (fabsf(cd[i] - 0.050807f) > 1e-6f) {\n        ok = false;\n        printf(\"Verification failed at index %d: %f\\n\", i, cd[i]);\n        break;\n      }\n    }\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n\n  free(cd);\n}\n\nint main(int argc, char* argv[]) {\n  if (argc != 2) {\n    printf(\"Usage: %s <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  const int repeat = atoi(argv[1]);\n\n  unsigned int datasize = VECTOR_SIZE*sizeof(float);\n\n  printf(\"Buffer size: %dMB\\n\", datasize/(1024*1024));\n\n  mixbenchGPU(VECTOR_SIZE, repeat);\n\n  return 0;\n}"}}
// {"kernel_name": "particlefilter", "parallel_api": "serial", "code": {"main.cpp": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <math.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <float.h>\n#include <time.h>\n#include <sys/time.h>\n\n#define BLOCK_X 16\n#define BLOCK_Y 16\n#define PI 3.1415926535897932f\n#define A 1103515245\n#define C 12345\n#define M INT_MAX\n#define SCALE_FACTOR 300.0f\n\n#ifndef BLOCK_SIZE \n#define BLOCK_SIZE 256\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef FLT_MAX\n#define FLT_MAX 3.40282347e+38\n#endif\n\n\n\nlong long get_time() {\n  struct timeval tv;\n  gettimeofday(&tv, NULL);\n  return (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\n\n\nfloat elapsed_time(long long start_time, long long end_time) {\n  return (float) (end_time - start_time) / (1000 * 1000);\n}\n\n\n\nfloat randu(int * seed, int index) {\n  int num = A * seed[index] + C;\n  seed[index] = num % M;\n  return fabs(seed[index] / ((float) M));\n}\n\n\n\nfloat randn(int * seed, int index) {\n  \n\n  float u = randu(seed, index);\n  float v = randu(seed, index);\n  float cosine = cos(2 * PI * v);\n  float rt = -2 * log(u);\n  return sqrt(rt) * cosine;\n}\n\n\n\nfloat roundFloat(float value) {\n  int newValue = (int) (value);\n  if (value - newValue < .5)\n    return newValue;\n  else\n    return newValue++;\n}\n\n\n\nvoid setIf(int testValue, int newValue, unsigned char * array3D, int * dimX, int * dimY, int * dimZ) {\n  int x, y, z;\n  for (x = 0; x < *dimX; x++) {\n    for (y = 0; y < *dimY; y++) {\n      for (z = 0; z < *dimZ; z++) {\n        if (array3D[x * *dimY * *dimZ + y * *dimZ + z] == testValue)\n          array3D[x * *dimY * *dimZ + y * *dimZ + z] = newValue;\n      }\n    }\n  }\n}\n\n\n\nvoid addNoise(unsigned char * array3D, int * dimX, int * dimY, int * dimZ, int * seed) {\n  int x, y, z;\n  for (x = 0; x < *dimX; x++) {\n    for (y = 0; y < *dimY; y++) {\n      for (z = 0; z < *dimZ; z++) {\n        array3D[x * *dimY * *dimZ + y * *dimZ + z] = array3D[x * *dimY * *dimZ + y * *dimZ + z] + (unsigned char) (5 * randn(seed, 0));\n      }\n    }\n  }\n}\n\n\n\nvoid strelDisk(int * disk, int radius) {\n  int diameter = radius * 2 - 1;\n  int x, y;\n  for (x = 0; x < diameter; x++) {\n    for (y = 0; y < diameter; y++) {\n      float distance = sqrt(pow((float) (x - radius + 1), 2) + pow((float) (y - radius + 1), 2));\n      if (distance < radius)\n        disk[x * diameter + y] = 1;\n      else\n        disk[x * diameter + y] = 0;\n    }\n  }\n}\n\n\n\nvoid dilate_matrix(unsigned char * matrix, int posX, int posY, int posZ, int dimX, int dimY, int dimZ, int error) {\n  int startX = posX - error;\n  while (startX < 0)\n    startX++;\n  int startY = posY - error;\n  while (startY < 0)\n    startY++;\n  int endX = posX + error;\n  while (endX > dimX)\n    endX--;\n  int endY = posY + error;\n  while (endY > dimY)\n    endY--;\n  int x, y;\n  for (x = startX; x < endX; x++) {\n    for (y = startY; y < endY; y++) {\n      float distance = sqrt(pow((float) (x - posX), 2) + pow((float) (y - posY), 2));\n      if (distance < error)\n        matrix[x * dimY * dimZ + y * dimZ + posZ] = 1;\n    }\n  }\n}\n\n\n\nvoid imdilate_disk(unsigned char * matrix, int dimX, int dimY, int dimZ, int error, unsigned char * newMatrix) {\n  int x, y, z;\n  for (z = 0; z < dimZ; z++) {\n    for (x = 0; x < dimX; x++) {\n      for (y = 0; y < dimY; y++) {\n        if (matrix[x * dimY * dimZ + y * dimZ + z] == 1) {\n          dilate_matrix(newMatrix, x, y, z, dimX, dimY, dimZ, error);\n        }\n      }\n    }\n  }\n}\n\n\n\nvoid getneighbors(int * se, int numOnes, int * neighbors, int radius) {\n  int x, y;\n  int neighY = 0;\n  int center = radius - 1;\n  int diameter = radius * 2 - 1;\n  for (x = 0; x < diameter; x++) {\n    for (y = 0; y < diameter; y++) {\n      if (se[x * diameter + y]) {\n        neighbors[neighY * 2] = (int) (y - center);\n        neighbors[neighY * 2 + 1] = (int) (x - center);\n        neighY++;\n      }\n    }\n  }\n}\n\n\n\nvoid videoSequence(unsigned char * I, int IszX, int IszY, int Nfr, int * seed) {\n  int k;\n  int max_size = IszX * IszY * Nfr;\n  \n\n  int x0 = (int) roundFloat(IszY / 2.0);\n  int y0 = (int) roundFloat(IszX / 2.0);\n  I[x0 * IszY * Nfr + y0 * Nfr + 0] = 1;\n\n  \n\n  int xk, yk, pos;\n  for (k = 1; k < Nfr; k++) {\n    xk = abs(x0 + (k - 1));\n    yk = abs(y0 - 2 * (k - 1));\n    pos = yk * IszY * Nfr + xk * Nfr + k;\n    if (pos >= max_size)\n      pos = 0;\n    I[pos] = 1;\n  }\n\n  \n\n  unsigned char * newMatrix = (unsigned char *) calloc(IszX * IszY * Nfr, sizeof(unsigned char));\n  imdilate_disk(I, IszX, IszY, Nfr, 5, newMatrix);\n  int x, y;\n  for (x = 0; x < IszX; x++) {\n    for (y = 0; y < IszY; y++) {\n      for (k = 0; k < Nfr; k++) {\n        I[x * IszY * Nfr + y * Nfr + k] = newMatrix[x * IszY * Nfr + y * Nfr + k];\n      }\n    }\n  }\n  free(newMatrix);\n\n  \n\n  setIf(0, 100, I, &IszX, &IszY, &Nfr);\n  setIf(1, 228, I, &IszX, &IszY, &Nfr);\n  \n\n  addNoise(I, &IszX, &IszY, &Nfr, seed);\n\n}\n\n\n\nint findIndex(float * CDF, int lengthCDF, float value) {\n  int index = -1;\n  int x;\n  for (x = 0; x < lengthCDF; x++) {\n    if (CDF[x] >= value) {\n      index = x;\n      break;\n    }\n  }\n  if (index == -1) {\n    return lengthCDF - 1;\n  }\n  return index;\n}\n\n\n\nint particleFilter(unsigned char * I, int IszX, int IszY, int Nfr, int * seed, int Nparticles) {\n  int max_size = IszX * IszY*Nfr;\n  \n\n  float xe = roundFloat(IszY / 2.0);\n  float ye = roundFloat(IszX / 2.0);\n\n  \n\n  int radius = 5;\n  int diameter = radius * 2 - 1;\n  int * disk = (int*) calloc(diameter * diameter, sizeof (int));\n  strelDisk(disk, radius);\n  int countOnes = 0;\n  int x, y;\n  for (x = 0; x < diameter; x++) {\n    for (y = 0; y < diameter; y++) {\n      if (disk[x * diameter + y] == 1)\n        countOnes++;\n    }\n  }\n  int * objxy = (int *) calloc(countOnes * 2, sizeof(int));\n  getneighbors(disk, countOnes, objxy, radius);\n\n  \n\n  float * weights = (float *) calloc(Nparticles, sizeof(float));\n  for (x = 0; x < Nparticles; x++) {\n    weights[x] = 1 / ((float) (Nparticles));\n  }\n  \n\n  float * likelihood = (float *) calloc(Nparticles + 1, sizeof (float));\n  float * partial_sums = (float *) calloc(Nparticles + 1, sizeof (float));\n  float * arrayX = (float *) calloc(Nparticles, sizeof (float));\n  float * arrayY = (float *) calloc(Nparticles, sizeof (float));\n  float * xj = (float *) calloc(Nparticles, sizeof (float));\n  float * yj = (float *) calloc(Nparticles, sizeof (float));\n  float * CDF = (float *) calloc(Nparticles, sizeof(float));\n\n\n  \n\n  int * ind = (int*) calloc(countOnes * Nparticles, sizeof(int));\n  float * u = (float *) calloc(Nparticles, sizeof(float));\n\n  \n\n  \n\n  \n\n  for (x = 0; x < Nparticles; x++) {\n\n    xj[x] = xe;\n    yj[x] = ye;\n  }\n\n  long long offload_start = get_time();\n\n\n  int k;\n\n  int num_blocks = (Nparticles + BLOCK_SIZE - 1) / BLOCK_SIZE;\n#ifdef DEBUG\n  printf(\"BLOCK_SIZE=%d \\n\",BLOCK_SIZE);\n#endif\n\n  {\n    long long start = get_time();\n\n    for (k = 1; k < Nfr; k++) {\n      \n\n            {\n        float weights_local[BLOCK_SIZE];\n                {\n          int block_id = omp_get_team_num();\n          int thread_id = omp_get_thread_num();\n          int block_dim = omp_get_num_threads();\n          int i = block_id * block_dim + thread_id;\n          int y;\n          int indX, indY;\n          float u, v;\n\n          if(i < Nparticles){\n            arrayX[i] = xj[i];\n            arrayY[i] = yj[i];\n            weights[i] = 1.0f / ((float) (Nparticles)); \n            seed[i] = (A*seed[i] + C) % M;\n            u = fabsf(seed[i]/((float)M));\n            seed[i] = (A*seed[i] + C) % M;\n            v = fabsf(seed[i]/((float)M));\n            arrayX[i] += 1.0f + 5.0f*(sqrtf(-2.0f*logf(u))*cosf(2.0f*PI*v));\n\n            seed[i] = (A*seed[i] + C) % M;\n            u = fabsf(seed[i]/((float)M));\n            seed[i] = (A*seed[i] + C) % M;\n            v = fabsf(seed[i]/((float)M));\n            arrayY[i] += -2.0f + 2.0f*(sqrtf(-2.0f*logf(u))*cosf(2.0f*PI*v));\n          }\n\n          \n          if(i < Nparticles)\n          {\n            for(y = 0; y < countOnes; y++){\n\n              int iX = arrayX[i];\n              int iY = arrayY[i];\n              int rnd_iX = (arrayX[i] - iX) < .5f ? iX : iX++;\n              int rnd_iY = (arrayY[i] - iY) < .5f ? iY : iY++;\n              indX = rnd_iX + objxy[y*2 + 1];\n              indY = rnd_iY + objxy[y*2];\n\n              ind[i*countOnes + y] = abs(indX*IszY*Nfr + indY*Nfr + k);\n              if(ind[i*countOnes + y] >= max_size)\n                ind[i*countOnes + y] = 0;\n            }\n            float likelihoodSum = 0.0f;\n            for(int x = 0; x < countOnes; x++)\n              likelihoodSum += ((I[ind[i*countOnes + x]] - 100) * (I[ind[i*countOnes + x]] - 100) -\n                  (I[ind[i*countOnes + x]] - 228) * (I[ind[i*countOnes + x]] - 228)) / 50.0f;\n            likelihood[i] = likelihoodSum/countOnes-SCALE_FACTOR;\n\n            weights[i] = weights[i] * expf(likelihood[i]);\n\n          }\n\n          weights_local[thread_id] = (i < Nparticles) ?  weights[i] : 0.f;\n\n          \n          for(unsigned int s=block_dim/2; s>0; s>>=1)\n          {\n            if(thread_id < s)\n            {\n              weights_local[thread_id] += weights_local[thread_id + s];\n            }\n                    }\n          if(thread_id == 0)\n          {\n            partial_sums[block_id] = weights_local[0];\n          }\n        }\n      }\n\n            {\n        float sum = 0;\n        int num_blocks = (Nparticles + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        for (int x = 0; x < num_blocks; x++) {\n          sum += partial_sums[x];\n        }\n        partial_sums[0] = sum;\n      }\n\n#ifdef DEBUG\n      \n\n      printf(\"kernel sum: frame=%d partial_sums[0]=%f\\n\",\n          k, partial_sums[0]);\n#endif\n\n            {\n        float u1;\n        float sumWeights; \n                {\n          int local_id = omp_get_thread_num();\n          int i = omp_get_team_num() * omp_get_num_threads() + local_id;\n          if(0 == local_id)\n            sumWeights = partial_sums[0];\n\n                    if(i < Nparticles) {\n            weights[i] = weights[i]/sumWeights;\n          }\n\n                    if(i == 0) {\n            CDF[0] = weights[0];\n            for(int x = 1; x < Nparticles; x++){\n              CDF[x] = weights[x] + CDF[x-1];\n            }\n\n            seed[i] = (A*seed[i] + C) % M;\n            float p = fabsf(seed[i]/((float)M));\n            seed[i] = (A*seed[i] + C) % M;\n            float q = fabsf(seed[i]/((float)M));\n            u[0] = (1.0f/((float)(Nparticles))) * \n              (sqrtf(-2.0f*logf(p))*cosf(2.0f*PI*q));\n            \n\n          }\n\n                    if(0 == local_id)\n            u1 = u[0];\n\n                    if(i < Nparticles)\n          {\n            u[i] = u1 + i/((float)(Nparticles));\n          }\n        }\n      }\n\n#ifdef DEBUG\n\n\n      xe = 0;\n      ye = 0;\n      float total=0.0;\n      \n\n      for (x = 0; x < Nparticles; x++) {\n        xe += arrayX[x] * weights[x];\n        ye += arrayY[x] * weights[x];\n        total+= weights[x];\n      }\n      printf(\"total weight: %lf\\n\", total);\n      printf(\"XE: %lf\\n\", xe);\n      printf(\"YE: %lf\\n\", ye);\n      float distance = sqrt(pow((float) (xe - (int) roundFloat(IszY / 2.0)), 2) + pow((float) (ye - (int) roundFloat(IszX / 2.0)), 2));\n      printf(\"distance: %lf\\n\", distance);\n#endif\n\n            for (int i = 0; i < Nparticles; i++)\n      {\n        int index = -1;\n        int x;\n\n        for(x = 0; x < Nparticles; x++){\n          if(CDF[x] >= u[i]){\n            index = x;\n            break;\n          }\n        }\n        if(index == -1){\n          index = Nparticles-1;\n        }\n\n        xj[i] = arrayX[index];\n        yj[i] = arrayY[index];\n      }\n    }\n\n\n    long long end = get_time();\n    printf(\"Average execution time of kernels: %f (s)\\n\",\n           elapsed_time(start, end) / (Nfr-1));\n\n  } \n\n\n  long long offload_end = get_time();\n  printf(\"Device offloading time: %lf (s)\\n\", elapsed_time(offload_start, offload_end));\n\n  xe = 0;\n  ye = 0;\n  \n\n  for (x = 0; x < Nparticles; x++) {\n    xe += arrayX[x] * weights[x];\n    ye += arrayY[x] * weights[x];\n  }\n  float distance = sqrt(pow((float) (xe - (int) roundFloat(IszY / 2.0)), 2) + pow((float) (ye - (int) roundFloat(IszX / 2.0)), 2));\n\n  \n\n  FILE *fid;\n  fid=fopen(\"output.txt\", \"w+\");\n  if( fid == NULL ){\n    printf( \"The file was not opened for writing\\n\" );\n    return -1;\n  }\n  fprintf(fid, \"XE: %lf\\n\", xe);\n  fprintf(fid, \"YE: %lf\\n\", ye);\n  fprintf(fid, \"distance: %lf\\n\", distance);\n  fclose(fid);\n\n  \n\n  free(likelihood);\n  free(partial_sums);\n  free(arrayX);\n  free(arrayY);\n  free(xj);\n  free(yj);\n  free(CDF);\n  free(ind);\n  free(u);\n  return 0;\n}\n\nint main(int argc, char * argv[]) {\n\n  const char* usage = \"./main -x <dimX> -y <dimY> -z <Nfr> -np <Nparticles>\";\n  \n\n  if (argc != 9) {\n    printf(\"%s\\n\", usage);\n    return 0;\n  }\n  \n\n  if (strcmp(argv[1], \"-x\") || strcmp(argv[3], \"-y\") || strcmp(argv[5], \"-z\") || strcmp(argv[7], \"-np\")) {\n    printf(\"%s\\n\", usage);\n    return 0;\n  }\n\n  int IszX, IszY, Nfr, Nparticles;\n\n  \n\n  if (sscanf(argv[2], \"%d\", &IszX) == EOF) {\n    printf(\"ERROR: dimX input is incorrect\");\n    return 0;\n  }\n\n  if (IszX <= 0) {\n    printf(\"dimX must be > 0\\n\");\n    return 0;\n  }\n\n  \n\n  if (sscanf(argv[4], \"%d\", &IszY) == EOF) {\n    printf(\"ERROR: dimY input is incorrect\");\n    return 0;\n  }\n\n  if (IszY <= 0) {\n    printf(\"dimY must be > 0\\n\");\n    return 0;\n  }\n\n  \n\n  if (sscanf(argv[6], \"%d\", &Nfr) == EOF) {\n    printf(\"ERROR: Number of frames input is incorrect\");\n    return 0;\n  }\n\n  if (Nfr <= 0) {\n    printf(\"number of frames must be > 0\\n\");\n    return 0;\n  }\n\n  \n\n  if (sscanf(argv[8], \"%d\", &Nparticles) == EOF) {\n    printf(\"ERROR: Number of particles input is incorrect\");\n    return 0;\n  }\n\n  if (Nparticles <= 0) {\n    printf(\"Number of particles must be > 0\\n\");\n    return 0;\n  }\n\n#ifdef DEBUG\n  printf(\"dimX=%d dimY=%d Nfr=%d Nparticles=%d\\n\", \n      IszX, IszY, Nfr, Nparticles);\n#endif\n\n  \n\n  int * seed = (int *) calloc(Nparticles, sizeof(int));\n  int i;\n  for (i = 0; i < Nparticles; i++)\n    seed[i] = i+1;\n\n  \n\n  unsigned char * I = (unsigned char *) calloc(IszX * IszY * Nfr, sizeof(unsigned char));\n  long long start = get_time();\n\n  \n\n  videoSequence(I, IszX, IszY, Nfr, seed);\n  long long endVideoSequence = get_time();\n  printf(\"VIDEO SEQUENCE TOOK %f (s)\\n\", elapsed_time(start, endVideoSequence));\n\n  \n\n  particleFilter(I, IszX, IszY, Nfr, seed, Nparticles);\n  long long endParticleFilter = get_time();\n  printf(\"PARTICLE FILTER TOOK %f (s)\\n\", elapsed_time(endVideoSequence, endParticleFilter));\n\n  printf(\"ENTIRE PROGRAM TOOK %f (s)\\n\", elapsed_time(start, endParticleFilter));\n\n  free(seed);\n  free(I);\n  return 0;\n}"}}
// {"kernel_name": "pool", "parallel_api": "serial", "code": {"main.cpp": "#include <chrono>\n#include <cmath>\n#include <cstdio>\n#include <new>\n#include <string>\n\n\n\n#define BSIZE 256\n\ntemplate <class T>\nclass AvgPoolGrad {\n  public:\n    void compute(const T& x, const T& y, const T& dy, T scale, T* dx) {\n      *dx += (scale * dy);\n    }\n};\n\ntemplate <class T>\nclass MaxPoolGrad {\n  public:\n    void compute(const T& x, const T& y, const T& dy, T scale, T* dx) {\n      *dx += dy * static_cast<T>(x == y);\n    }\n};\n\n#include \"reference.h\"\n\ntemplate <typename PoolProcess, typename T>\nvoid KernelPool2DGrad(\n    const int nthreads,\n    const T*__restrict input_data,\n    const T*__restrict output_data,\n    const T*__restrict output_grad,\n    const int channels,\n    const int input_height,\n    const int input_width,\n    const int output_height,\n    const int output_width,\n    const int ksize_height,\n    const int ksize_width,\n    const int stride_height,\n    const int stride_width,\n    const int padding_height,\n    const int padding_width,\n    PoolProcess pool_process,\n    bool exclusive,\n    T*__restrict input_grad,\n    bool channel_last = false)\n{\n    for (int index = 0; index < nthreads; index ++) {\n    int w_offset, h_offset, offsetC, batch_idx;\n    int tmp;\n    if (!channel_last) { \n\n      w_offset = index % input_width + padding_width;\n      tmp = index / input_width;\n      h_offset = tmp % input_height + padding_height;\n      tmp = tmp / input_height;\n      offsetC = tmp % channels;\n      batch_idx = tmp / channels;\n    } else { \n\n      offsetC = index % channels;\n      tmp = index / channels;\n      w_offset = tmp % input_width + padding_width;\n      tmp = tmp / input_width;\n      h_offset = tmp % input_height + padding_height;\n      batch_idx = tmp / input_height;\n    }\n\n    int phstart, phend;\n    int pwstart, pwend;\n    phstart = (h_offset < ksize_height) ? 0 : (h_offset - ksize_height) / stride_height + 1;\n    pwstart = (w_offset < ksize_width) ? 0 : (w_offset - ksize_width) / stride_width + 1;\n    phend = std::min(h_offset / stride_height + 1, output_height);\n    pwend = std::min(w_offset / stride_width + 1, output_width);\n\n    \n\n    T gradient = static_cast<T>(0.0);\n    T input = input_data[index];\n\n    int output_stride = batch_idx * output_height * output_width * channels;\n    if (!channel_last)\n      output_stride += offsetC * output_height * output_width;\n\n    const T *__restrict output_data_t = output_data + output_stride;\n    const T *__restrict output_grad_t = output_grad + output_stride;\n\n    for (int ph = phstart; ph < phend; ++ph) {\n      for (int pw = pwstart; pw < pwend; ++pw) {\n        int pool_size;\n        int hstart = ph * stride_height - padding_height;\n        int wstart = pw * stride_width - padding_width;\n        int hend = std::min(hstart + ksize_height, input_height);\n        int wend = std::min(wstart + ksize_width, input_width);\n        hstart = std::max(hstart, 0);\n        wstart = std::max(wstart, 0);\n        pool_size = exclusive ? (hend - hstart) * (wend - wstart)\n          : ksize_height * ksize_width;\n\n        int output_sub_idx = channel_last\n          ? (ph * output_width + pw) * channels + offsetC\n          : ph * output_width + pw;\n        pool_process.compute(input, output_data_t[output_sub_idx],\n            output_grad_t[output_sub_idx],\n            static_cast<T>(1.f / pool_size), &gradient);\n      }\n    }\n    input_grad[index] = gradient;\n  }\n}\n\nint main(int argc, char* argv[])\n{\n  if (argc != 8) {\n    printf(\"Usage: %s <batch> <input channels> <input height> \", argv[0]);\n    printf(\"<input width> <output height> <output width> <repeat>\\n\");\n    return 1;\n  }\n  \n\n  const int batch_size = atoi(argv[1]);\n  const int input_channels = atoi(argv[2]);\n  const int input_height = atoi(argv[3]);\n  const int input_width = atoi(argv[4]);\n\n  \n\n  const int output_height = atoi(argv[5]);\n  const int output_width = atoi(argv[6]);\n\n  \n\n  const int repeat = atoi(argv[7]);\n\n  const int input_numel = batch_size*input_channels*input_height*input_width;\n  const int output_numel = batch_size*input_channels*output_height*output_width;\n\n  \n\n  const int ksize_height = 11;\n  const int ksize_width = 11;\n  const int stride_height = 4;\n  const int stride_width = 4;\n  const int padding_height = 1;\n  const int padding_width = 1;\n  const bool exclusive = true;\n  const std::string data_format = \"NCHW\";\n  const bool channel_last = (data_format == \"NHWC\");\n\n  \n\n  int nthreads = batch_size * input_channels * input_height * input_width;\n\n  \n\n  AvgPoolGrad<float> pool_process;\n\n  float * input = new float[input_numel];\n  float * output = new float[output_numel];\n  float * output_grad = new float[output_numel];\n  float * input_grad = new float[input_numel];\n  float * input_grad_ref = new float[input_numel];\n\n  srand(123);\n  for (int i = 0; i < input_numel; ++i) {\n    input[i] = (float)rand() / (float)RAND_MAX;\n    input_grad[i] = 0.f;  \n\n  }\n\n  for (int i = 0; i < output_numel; ++i) {\n    output[i] = (float)rand() / (float)RAND_MAX;\n    output_grad[i] = input_width * input_height;\n  }\n\n    {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++) {\n      KernelPool2DGrad<AvgPoolGrad<float>, float>(\n        nthreads, input, output, output_grad, input_channels,\n        input_height, input_width, output_height, output_width, ksize_height,\n        ksize_width, stride_height, stride_width, padding_height, padding_width,\n        pool_process, exclusive, input_grad, channel_last);\n    }\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time: %f (s)\\n\", (time * 1e-9f) / repeat);\n  }\n\n  \n\n  reference<AvgPoolGrad<float>, float>(\n          nthreads, input, output, output_grad,\n          input_channels, input_height, input_width, output_height, output_width, ksize_height,\n          ksize_width, stride_height, stride_width, padding_height, padding_width,\n          pool_process, exclusive, input_grad_ref, channel_last);\n\n  bool ok = true;\n  for (int i = 0; i < input_numel; ++i) {\n    if (fabsf(input_grad[i] - input_grad_ref[i]) > 1e-3) {\n      ok = false;\n      break;\n    }\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n\n  delete[] input;\n  delete[] output;\n  delete[] input_grad;\n  delete[] input_grad_ref;\n  delete[] output_grad;\n  return 0;\n}"}}
// {"kernel_name": "stddev", "parallel_api": "serial", "code": {"main.cpp": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <chrono>\n#include \"reference.h\"\n\n\ntemplate <typename Type, typename IdxType = int>\nvoid stddev(Type *std, const Type *data, IdxType D, IdxType N, bool sample) {\n  // Simple serial implementation that matches the reference algorithm\n  IdxType sample_size = sample ? N-1 : N;\n  for (IdxType c = 0; c < D; c++) {\n    Type sum = 0;\n    for (IdxType r = 0; r < N; r++)\n      sum += data[r*D+c] * data[r*D+c];\n    std[c] = sqrtf(sum / sample_size);\n  }\n}\n\nint main(int argc, char* argv[]) {\n  if (argc != 4) {\n    printf(\"Usage: %s <D> <N> <repeat>\\n\", argv[0]);\n    printf(\"D: number of columns of data (must be a multiple of 32)\\n\");\n    printf(\"N: number of rows of data (at least one row)\\n\");\n    return 1;\n  }\n  int D = atoi(argv[1]); \n\n  int N = atoi(argv[2]); \n\n  int repeat = atoi(argv[3]);\n\n  bool sample = true;\n  long inputSize = D * N;\n  long inputSizeByte = inputSize * sizeof(float);\n  float *data = (float*) malloc (inputSizeByte);\n\n  srand(123);\n  for (int i = 0; i < N; i++)\n    for (int j = 0; j < D; j++) \n      data[i*D + j] = rand() / (float)RAND_MAX; \n\n  long outputSize = D;\n  long outputSizeByte = outputSize * sizeof(float);\n  float *std  = (float*) malloc (outputSizeByte);\n  float *std_ref  = (float*) malloc (outputSizeByte);\n\n  stddev(std, data, D, N, sample);\n\n  auto start = std::chrono::steady_clock::now();\n\n  for (int i = 0; i < repeat; i++)\n    stddev(std, data, D, N, sample);\n\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Average execution time of stddev kernels: %f (s)\\n\", (time * 1e-9f) / repeat);\n\n  stddev_ref(std_ref, data, D, N, sample);\n\n  bool ok = true;\n  for (int i = 0; i < D; i++) {\n    if (fabsf(std_ref[i] - std[i]) > 1e-3) {\n      ok = false;\n      break;\n    }\n  }\n\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n  free(std_ref);\n  free(std);\n  free(data);\n  return 0;\n}\n"}}
// {"kernel_name": "stencil1d", "parallel_api": "serial", "code": {"main.cpp": "\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <chrono>\n\n#define RADIUS 7\n#define BLOCK_SIZE 256\n\nint main(int argc, char* argv[]) {\n  if (argc != 3) {\n    printf(\"Usage: %s <length> <repeat>\\n\", argv[0]);\n    printf(\"length is a multiple of %d\\n\", BLOCK_SIZE);\n    return 1;\n  }\n  const int length = atoi(argv[1]);\n  const int repeat = atoi(argv[2]);\n\n  int size = length;\n  int pad_size = (length + RADIUS);\n\n  \n\n  int* a = (int *)malloc(pad_size*sizeof(int)); \n  int* b = (int *)malloc(size*sizeof(int));\n\n  for (int i = 0; i < length+RADIUS; i++) a[i] = i;\n\n  auto start = std::chrono::steady_clock::now();\n\n  for (int i = 0; i < repeat; i++) {\n        for (int i = 0; i < length; i = i + BLOCK_SIZE) {\n      int temp[BLOCK_SIZE + 2 * RADIUS];\n            for (int j = 0; j < BLOCK_SIZE; j++) {\n        int gindex = i+j;\n        temp[j+RADIUS] = a[gindex]; \n        if (j < RADIUS) {\n          temp[j] = (gindex < RADIUS) ? 0 : a[gindex - RADIUS];\n          temp[j + RADIUS + BLOCK_SIZE] = a[gindex + BLOCK_SIZE];\n        }\n      }\n\n            for (int j = 0; j < BLOCK_SIZE; j++) {\n        int result = 0;\n        for (int offset = -RADIUS ; offset <= RADIUS ; offset++)\n          result += temp[j+RADIUS+offset];\n        b[i+j] = result; \n      }\n    }\n  }\n\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Average kernel execution time: %f (s)\\n\", (time * 1e-9f) / repeat);\n\n  \n\n  bool ok = true;\n  for (int i = 0; i < 2*RADIUS; i++) {\n    int s = 0;\n    for (int j = i; j <= i+2*RADIUS; j++)\n      s += j < RADIUS ? 0 : (a[j] - RADIUS);\n    if (s != b[i]) {\n      printf(\"Error at %d: %d (host) != %d (device)\\n\", i, s, b[i]);\n      ok = false;\n      break;\n    }\n  }\n\n  for (int i = 2*RADIUS; i < length; i++) {\n    int s = 0;\n    for (int j = i-RADIUS; j <= i+RADIUS; j++)\n      s += a[j];\n    if (s != b[i]) {\n      printf(\"Error at %d: %d (host) != %d (device)\\n\", i, s, b[i]);\n      ok = false;\n      break;\n    }\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n\n  \n\n  free(a);\n  free(b); \n  return 0;\n}"}}
// {"kernel_name": "vanGenuchten", "parallel_api": "serial", "code": {"main.cpp": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <chrono>\n#include \"reference.h\"\n\nvoid vanGenuchten(\n  const double *__restrict Ksat,\n  const double *__restrict psi,\n        double *__restrict C,\n        double *__restrict theta,\n        double *__restrict K,\n  const int size)\n{\n    for (int i = 0; i < size; i++) {\n\n    double Se, _theta, _psi, lambda, m, t;\n\n    lambda = n - 1.0;\n    m = lambda/n;\n\n    \n\n    _psi = psi[i] * 100.0;\n    if ( _psi < 0.0 )\n      _theta = (theta_S - theta_R) / pow(1.0 + pow((alpha*(-_psi)),n), m) + theta_R;\n    else\n      _theta = theta_S;\n\n    theta[i] = _theta;\n\n    \n\n    Se = (_theta - theta_R)/(theta_S - theta_R);\n\n    \n\n    t = 1.0 - pow(1.0-pow(Se,1.0/m), m);\n    K[i] = Ksat[i] * sqrt(Se) * t * t;\n\n    \n\n    \n\n    if (_psi < 0.0)\n      C[i] = 100 * alpha * n * (1.0/n-1.0)*pow(alpha*abs(_psi), n-1.0)\n        * (theta_R-theta_S) * pow(pow(alpha*abs(_psi), n)+1.0, 1.0/n-2.0);\n    else\n      C[i] = 0.0;\n  }\n}\n\nint main(int argc, char* argv[])\n{\n  if (argc != 5) {\n    printf(\"Usage: ./%s <dimX> <dimY> <dimZ> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n\n  const int dimX = atoi(argv[1]);\n  const int dimY = atoi(argv[2]);\n  const int dimZ = atoi(argv[3]);\n  const int repeat = atoi(argv[4]);\n\n  const int size = dimX * dimY * dimZ;\n\n  double *Ksat, *psi, *C, *theta, *K;\n  double *C_ref, *theta_ref, *K_ref;\n  \n  Ksat = new double[size];\n  psi = new double[size];\n  C = new double[size];\n  theta = new double[size];\n  K = new double[size];\n\n  C_ref = new double[size];\n  theta_ref = new double[size];\n  K_ref = new double[size];\n\n  \n\n  for (int i = 0; i < size; i++) {\n    Ksat[i] = 1e-6 +  (1.0 - 1e-6) * i / size; \n    psi[i] = -100.0 + 101.0 * i / size;\n  }\n\n  \n\n  reference(Ksat, psi, C_ref, theta_ref, K_ref, size);\n\n    {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      vanGenuchten(Ksat, psi, C, theta, K, size);\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time: %f (s)\\n\", (time * 1e-9f) / repeat);\n  }\n\n  bool ok = true;\n  for (int i = 0; i < size; i++) {\n    if (fabs(C[i] - C_ref[i]) > 1e-3 || \n        fabs(theta[i] - theta_ref[i]) > 1e-3 ||\n        fabs(K[i] - K_ref[i]) > 1e-3) {\n      ok = false;\n      break;\n    }\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n\n  delete(Ksat);\n  delete(psi);\n  delete(C);\n  delete(theta);\n  delete(K);\n  delete(C_ref);\n  delete(theta_ref);\n  delete(K_ref);\n\n  return 0;\n}"}}
// {"kernel_name": "winograd", "parallel_api": "serial", "code": {"main.cpp": "#include <chrono>\n#include \"utils.h\"\n\nint main(int argc, char* argv[]) {\n\n  double start = rtclock();\n\n  DATA_TYPE *A = (DATA_TYPE*)malloc(MAP_SIZE * MAP_SIZE * sizeof(DATA_TYPE));\n  DATA_TYPE *B_host = (DATA_TYPE*)malloc((MAP_SIZE - 2) * (MAP_SIZE - 2) * sizeof(DATA_TYPE));\n  DATA_TYPE *B = (DATA_TYPE*)malloc((MAP_SIZE - 2) * (MAP_SIZE - 2) * sizeof(DATA_TYPE));\n  DATA_TYPE *C = (DATA_TYPE*)malloc(4 * 4 * sizeof(DATA_TYPE));\n\n  for (int i = 0; i < MAP_SIZE; ++i)\n    for (int j = 0; j < MAP_SIZE; ++j)\n      A[i * MAP_SIZE + j] = rand() / (float)RAND_MAX;\n\n  \n\n  WinogradConv2D_2x2_filter_transformation(C);\n\n  const int tile_n = (MAP_SIZE - 2 + 1) / 2;\n\n  \n\n  size_t globalWorkSize[2] = {\n    (size_t)ceil(((float)tile_n) / ((float)DIM_LOCAL_WORK_GROUP_X)) * DIM_LOCAL_WORK_GROUP_X,\n    (size_t)ceil(((float)tile_n) / ((float)DIM_LOCAL_WORK_GROUP_Y)) * DIM_LOCAL_WORK_GROUP_Y };\n\n  size_t localWorkSize[2] = {DIM_LOCAL_WORK_GROUP_X, DIM_LOCAL_WORK_GROUP_Y};\n\n  \n\n  size_t cpu_global_size[2];\n  size_t gpu_global_size[2];\n  size_t global_offset[2];\n\n  bool pass = true;\n\n  double co_time = 0.0;\n\n\n{\n  \n\n  for (int cpu_offset = 0; cpu_offset <= 100; cpu_offset++) {\n\n    cpu_global_size[0] = cpu_offset * (size_t)ceil(((float)tile_n) / ((float)DIM_LOCAL_WORK_GROUP_X)) \n      / 100 * DIM_LOCAL_WORK_GROUP_X;\n    cpu_global_size[1] = globalWorkSize[1];\n\n    gpu_global_size[0] = globalWorkSize[0] - cpu_global_size[0];\n    gpu_global_size[1] = globalWorkSize[1];\n\n    global_offset[0] = cpu_global_size[0];\n    global_offset[1] = 0;\n\n    const int tile_i_size = gpu_global_size[0];\n    const int tile_j_size = gpu_global_size[1];\n    const int offset_i = global_offset[0];\n    const int offset_j = global_offset[1];\n    const int thread_size = localWorkSize[1] * localWorkSize[0];\n\n    bool cpu_run = false, gpu_run = false;\n    if (cpu_global_size[0] > 0) {\n      cpu_run = true;\n    }\n    if (gpu_global_size[0] > 0) {\n      gpu_run = true;\n    }\n\n    \n\n    double co_start = rtclock();\n\n    if (gpu_run) {\n            for (int tile_j = 0; tile_j < tile_j_size; tile_j++) {\n        for (int tile_i = 0; tile_i < tile_i_size; tile_i++) {\n          \n\n\n          DATA_TYPE input_tile[4][4], tmp_tile[4][4], transformed_tile[4][4];\n          for (int i = 0; i < 4; i ++) {\n            for (int j = 0; j < 4; j ++) { \n              int x = 2 * (tile_i + offset_i) + i;\n              int y = 2 * (tile_j + offset_j) + j;\n              if (x >= MAP_SIZE || y >= MAP_SIZE) {\n                input_tile[i][j] = 0;\n                continue;\n              }\n              input_tile[i][j] = A[x * MAP_SIZE + y];\n            }\n          } \n\n          \n\n          for (int j = 0; j < 4; j ++) {\n            tmp_tile[0][j] = input_tile[0][j] - input_tile[2][j];\n            tmp_tile[1][j] = input_tile[1][j] + input_tile[2][j];\n            tmp_tile[2][j] = -input_tile[1][j] + input_tile[2][j];\n            tmp_tile[3][j] = input_tile[1][j] - input_tile[3][j];\n          }\n          \n\n          for (int i = 0; i < 4; i ++) {\n            transformed_tile[i][0] = tmp_tile[i][0] - tmp_tile[i][2];\n            transformed_tile[i][1] = tmp_tile[i][1] + tmp_tile[i][2];\n            transformed_tile[i][2] = -tmp_tile[i][1] + tmp_tile[i][2];\n            transformed_tile[i][3] = tmp_tile[i][1] - tmp_tile[i][3];\n          }\n\n          \n\n\n          DATA_TYPE multiplied_tile[4][4];\n          for (int i = 0; i < 4; i ++) {\n            for (int j = 0; j < 4; j ++) {\n              multiplied_tile[i][j] = transformed_tile[i][j] * C[i * 4 + j];\n            }\n          }\n\n          \n\n\n          DATA_TYPE tmp_tile_1[2][4], final_tile[2][2];\n\n          \n\n          for (int j = 0; j < 4; j ++) {\n            tmp_tile_1[0][j] = multiplied_tile[0][j] + multiplied_tile[1][j] + multiplied_tile[2][j];\n            tmp_tile_1[1][j] = multiplied_tile[1][j] - multiplied_tile[2][j] - multiplied_tile[3][j];\n          }\n          \n\n          for (int i = 0; i < 2; i ++) {\n            final_tile[i][0] = tmp_tile_1[i][0] + tmp_tile_1[i][1] + tmp_tile_1[i][2];\n            final_tile[i][1] = tmp_tile_1[i][1] - tmp_tile_1[i][2] - tmp_tile_1[i][3];\n          }\n\n          for (int i = 0; i < 2; i ++) {\n            for (int j = 0; j < 2; j ++) {\n              int x = 2 * (tile_i + offset_i) + i;\n              int y = 2 * (tile_j + offset_j) + j;\n              if (x >= MAP_SIZE - 2 || y >= MAP_SIZE - 2) {\n                continue;\n              }\n              B[x * (MAP_SIZE - 2) + y] = final_tile[i][j];\n            }\n          }\n        }\n      }\n    }\n\n    if (cpu_run) {\n      WinogradConv2D_2x2_omp(A, B, C, cpu_global_size);\n\n      if (gpu_run) {\n              }\n      else {\n              }\n    }\n\n    \n    co_time += rtclock() - co_start;\n\n#ifdef VERBOSE\n    if (cpu_run) printf(\"run on host\\n\");\n    if (gpu_run) printf(\"run on device\\n\");\n    printf(\"CPU workload size : %d\\n\", cpu_offset);\n#endif\n\n    WinogradConv2D_2x2(A, B_host, C);\n    pass &= compareResults(B_host, B);\n\n  } \n\n}  \n\n\n  printf(\"%s\\n\", pass ? \"PASS\" : \"FAIL\");\n\n  free(A);\n  free(B);\n  free(B_host);\n  free(C);\n\n  double end = rtclock();\n  printf(\"Co-execution time: %lf s\\n\", co_time);\n  printf(\"Total time: %lf s\\n\", end - start);\n  printf(\"Ratio of co-execution time to total time: %.2lf%%\\n\",\n         100.0 * co_time / (end - start));\n\n  return 0;\n}"}}
// {"kernel_name": "jacobi", "parallel_api": "serial", "code": {"main.cpp": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <chrono>\n\n\n\n#define N 2048\n\n#define IDX(i, j) ((i) + (j) * N)\n\nvoid initialize_data (float* f) {\n  \n\n  for (int j = 0; j < N; ++j) {\n    for (int i = 0; i < N; ++i) {\n\n      if (i == 0 || i == N-1) {\n        f[IDX(i,j)] = sinf(j * 2 * M_PI / (N - 1));\n      }\n      else if (j == 0 || j == N-1) {\n        f[IDX(i,j)] = sinf(i * 2 * M_PI / (N - 1));\n      }\n      else {\n        f[IDX(i,j)] = 0.0f;\n      }\n\n    }\n  }\n}\n\nint main () {\n  \n\n  std::clock_t start_time = std::clock();\n\n  \n\n  float* f = (float*) aligned_alloc(64, N * N * sizeof(float));\n  float* f_old = (float*) aligned_alloc(64, N * N * sizeof(float));\n  \n\n  float error = {std::numeric_limits<float>::max()};\n  const float tolerance = 0.5e-3f;\n\n  \n\n  \n\n  initialize_data(f);\n  initialize_data(f_old);\n\n  \n\n  \n\n  const int max_iters = 10000;\n  int num_iters = 0;\n\n{\n  auto start = std::chrono::steady_clock::now();\n\n  while (error > tolerance && num_iters < max_iters) {\n    \n\n    \n\n    error = 0.f;\n    \n        for (int i = 1; i <= N-2; i++) {\n      for (int j = 1; j <= N-2; j++) {\n        float t = 0.25f * (f_old[IDX(i-1,j)] +\n                           f_old[IDX(i+1,j)] +\n                           f_old[IDX(i,j-1)] +\n                           f_old[IDX(i,j+1)]);\n        float df = t - f_old[IDX(i, j)];\n        f[IDX(i,j)] = t;\n        error += df * df;\n      }\n    }\n      \n    \n\n    \n\n    \n\n        for (int j = 0; j < N; j++) \n      for (int i = 0; i < N; i++) \n        if (j >= 1 && j <= N-2 && i >= 1 && i <= N-2)\n          f_old[IDX(i,j)] = f[IDX(i,j)];\n\n    \n\n    \n\n    error = sqrtf(error / (N * N));\n\n    \n\n    if (num_iters % 1000 == 0) {\n      std::cout << \"Error after iteration \" << num_iters << \" = \" << error << std::endl;\n    }\n\n    \n\n    ++num_iters;\n  }\n\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  std::cout << \"Average execution time per iteration: \" << (time * 1e-9f) / num_iters << \" (s)\\n\";\n}\n\n  \n\n  \n\n\n  if (error <= tolerance && num_iters < max_iters) {\n    std::cout << \"PASS\" << std::endl;\n  }\n  else {\n    std::cout << \"FAIL\" << std::endl;\n    return -1;\n  }\n\n  \n\n  free(f);\n  free(f_old);\n\n  \n\n  double duration = (std::clock() - start_time) / (double) CLOCKS_PER_SEC;\n  std::cout << \"Total elapsed time: \" << std::setprecision(4) << duration << \" seconds\" << std::endl;\n\n  return 0;\n}"}}
// {"kernel_name": "atomicCost", "parallel_api": "serial", "code": {"main.cpp": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <chrono>\n\n#define BLOCK_SIZE 256\n\n\n\ntemplate <typename T>\nvoid woAtomicOnGlobalMem(T* result, int size, int n)\n{\n    for (unsigned int tid = 0; tid < n; tid++) {\n    for ( unsigned int i = tid * size; i < (tid + 1) * size; i++) {\n      result[tid] += i % 2;\n    }\n  }\n}\n\n\n\ntemplate <typename T>\nvoid wiAtomicOnGlobalMem(T* result, int size, int n)\n{\n    for (unsigned int tid = 0; tid < n; tid++) {\n    for ( unsigned int i = tid * size; i < (tid + 1) * size; i++) {\n            result[tid] += i % 2;\n    }\n  }\n}\n\ntemplate <typename T>\nvoid atomicCost (int length, int size, int repeat)\n{\n  printf(\"\\n\\n\");\n  printf(\"Each thread sums up %d elements\\n\", size);\n\n  int num_threads = length / size;\n  assert(length % size == 0);\n  assert(num_threads % BLOCK_SIZE == 0);\n\n  size_t result_size = sizeof(T) * num_threads;\n\n  T* result_wi = (T*) malloc (result_size);\n  T* result_wo = (T*) malloc (result_size);\n  memset(result_wi, 0, result_size);\n  memset(result_wo, 0, result_size);\n\n    {\n    auto start = std::chrono::steady_clock::now();\n    for(int i=0; i<repeat; i++)\n    {\n      wiAtomicOnGlobalMem<T>(result_wi, size, num_threads);\n    }\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average execution time of WithAtomicOnGlobalMem: %f (us)\\n\",\n            time * 1e-3f / repeat);\n    \n    start = std::chrono::steady_clock::now();\n    for(int i=0; i<repeat; i++)\n    {\n      woAtomicOnGlobalMem<T>(result_wo, size, num_threads);\n    }\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average execution time of WithoutAtomicOnGlobalMem: %f (us)\\n\",\n            time * 1e-3f / repeat);\n    \n    int diff = memcmp(result_wi, result_wo, result_size);\n    printf(\"%s\\n\", diff ? \"FAIL\" : \"PASS\");\n  }\n\n  free(result_wi);\n  free(result_wo);\n}\n\nint main(int argc, char* argv[])\n{\n  if (argc != 3) {\n    printf(\"Usage: %s <N> <repeat>\\n\", argv[0]);\n    printf(\"N: the number of elements to sum per thread (1 - 16)\\n\");\n    return 1;\n  }\n  const int nelems = atoi(argv[1]);\n  const int repeat = atoi(argv[2]);\n\n  const int length = 922521600;\n  assert(length % BLOCK_SIZE == 0);\n\n  printf(\"\\nFP64 atomic add\\n\");\n  atomicCost<double>(length, nelems, repeat);\n\n  printf(\"\\nINT32 atomic add\\n\");\n  atomicCost<int>(length, nelems, repeat);\n\n  printf(\"\\nFP32 atomic add\\n\");\n  atomicCost<float>(length, nelems, repeat);\n\n  return 0;\n}"}}
// {"kernel_name": "pnpoly", "parallel_api": "serial", "code": {"main.cpp": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <random>\n#include <chrono>\n\n#define VERTICES 100\n#define BLOCK_SIZE_X 256\n\ntypedef struct __attribute__((__aligned__(8)))\n{\n  float x, y;\n} float2;\n\n/*\n * This file contains the implementation of a kernel for the\n * point-in-polygon problem using the crossing number algorithm\n *\n * The kernel pnpoly_base is used for correctness checking.\n *\n * The algorithm used here is adapted from: \n *     'Inclusion of a Point in a Polygon', Dan Sunday, 2001\n *     (http://geomalgorithms.com/a03-_inclusion.html)\n *\n * Author: Ben van Werkhoven <b.vanwerkhoven@esciencecenter.nl>\n */\n\n/*\n * The is_between method returns a boolean that is True when the a is between c and b.\n */\ninline int is_between(float a, float b, float c) {\n  return (b > a) != (c > a);\n}\n\n/*\n * The Point-in-Polygon kernel\n */\ntemplate <int tile_size>\nvoid pnpoly_opt(\n    int*__restrict bitmap,\n    const float2*__restrict point,\n    const float2*__restrict vertex,\n    int n) \n{\n for (int i = 0; i < n; i++) {\n    int c[tile_size];\n    float2 lpoint[tile_size];\n    #pragma unroll\n    for (int ti=0; ti<tile_size; ti++) {\n      c[ti] = 0;\n      if (i+BLOCK_SIZE_X*ti < n) {\n        lpoint[ti] = point[i+BLOCK_SIZE_X*ti];\n      }\n    }\n\n    int k = VERTICES-1;\n\n    for (int j=0; j<VERTICES; k = j++) {    // edge from vj to vk\n      float2 vj = vertex[j]; \n      float2 vk = vertex[k]; \n\n      float slope = (vk.x-vj.x) / (vk.y-vj.y);\n\n      #pragma unroll\n      for (int ti=0; ti<tile_size; ti++) {\n\n        float2 p = lpoint[ti];\n\n        if (is_between(p.y, vj.y, vk.y) &&         //if p is between vj and vk vertically\n            (p.x < slope * (p.y-vj.y) + vj.x)\n           ) {  //if p.x crosses the line vj-vk when moved in positive x-direction\n          c[ti] = !c[ti];\n        }\n      }\n    }\n\n    #pragma unroll\n    for (int ti=0; ti<tile_size; ti++) {\n      //could do an if statement here if 1s are expected to be rare\n      if (i+BLOCK_SIZE_X*ti < n)\n        bitmap[i+BLOCK_SIZE_X*ti] = c[ti];\n    }\n  }\n}\n\n\n/*\n * The naive implementation is used for verifying correctness of the optimized implementation\n */\nvoid pnpoly_base(\n    int*__restrict bitmap,\n    const float2*__restrict point,\n    const float2*__restrict vertex,\n    int n) \n{\n for (int i = 0; i < n; i++) {\n    int c = 0;\n    float2 p = point[i];\n\n    int k = VERTICES-1;\n\n    for (int j=0; j<VERTICES; k = j++) {    // edge from v to vp\n      float2 vj = vertex[j]; \n      float2 vk = vertex[k]; \n\n      float slope = (vk.x-vj.x) / (vk.y-vj.y);\n\n      if (((vj.y>p.y) != (vk.y>p.y)) &&            //if p is between vj and vk vertically\n          (p.x < slope * (p.y-vj.y) + vj.x)) {   //if p.x crosses the line vj-vk when moved in positive x-direction\n        c = !c;\n      }\n    }\n\n    bitmap[i] = c; // 0 if even (out), and 1 if odd (in)\n  }\n}\n\nint main(int argc, char* argv[]) {\n  if (argc != 2) {\n    printf(\"Usage: ./%s <repeat>\\n\", argv[0]);\n    return 1;\n  }\n\n  const int repeat = atoi(argv[1]);\n  const int nPoints = 1e6;\n  const int vertices = VERTICES;\n\n  std::default_random_engine rng (123);\n  std::normal_distribution<float> distribution(0, 1);\n\n  float2 *point = (float2*) malloc (sizeof(float2) * nPoints);\n  for (int i = 0; i < nPoints; i++) {\n    point[i].x = distribution(rng);\n    point[i].y = distribution(rng);\n  }\n\n  float2 *vertex = (float2*) malloc (vertices * sizeof(float2));\n  for (int i = 0; i < vertices; i++) {\n    float t = distribution(rng) * 2.f * M_PI;\n    vertex[i].x = cosf(t);\n    vertex[i].y = sinf(t);\n  }\n\n  int *bitmap_ref = (int*) malloc (nPoints * sizeof(int));\n  int *bitmap_opt = (int*) malloc (nPoints * sizeof(int));\n\n  {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      pnpoly_base(bitmap_ref, point, vertex, nPoints);\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time (pnpoly_base): %f (s)\\n\", (time * 1e-9f) / repeat);\n\n    start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      pnpoly_opt<1>(bitmap_opt, point, vertex, nPoints);\n\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time (pnpoly_opt<1>): %f (s)\\n\", (time * 1e-9f) / repeat);\n\n    start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      pnpoly_opt<2>(bitmap_opt, point, vertex, nPoints);\n\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time (pnpoly_opt<2>): %f (s)\\n\", (time * 1e-9f) / repeat);\n\n    start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      pnpoly_opt<4>(bitmap_opt, point, vertex, nPoints);\n\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time (pnpoly_opt<4>): %f (s)\\n\", (time * 1e-9f) / repeat);\n\n    start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      pnpoly_opt<8>(bitmap_opt, point, vertex, nPoints);\n\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time (pnpoly_opt<8>): %f (s)\\n\", (time * 1e-9f) / repeat);\n\n    start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      pnpoly_opt<16>(bitmap_opt, point, vertex, nPoints);\n\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time (pnpoly_opt<16>): %f (s)\\n\", (time * 1e-9f) / repeat);\n\n    start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      pnpoly_opt<32>(bitmap_opt, point, vertex, nPoints);\n\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time (pnpoly_opt<32>): %f (s)\\n\", (time * 1e-9f) / repeat);\n\n    start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      pnpoly_opt<64>(bitmap_opt, point, vertex, nPoints);\n\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time (pnpoly_opt<64>): %f (s)\\n\", (time * 1e-9f) / repeat);\n  }\n\n  int error = memcmp(bitmap_opt, bitmap_ref, nPoints*sizeof(int)); \n  \n  int checksum = 0;\n  for (int i = 0; i < nPoints; i++) checksum += bitmap_opt[i];\n  printf(\"Checksum: %d\\n\", checksum);\n\n  printf(\"%s\\n\", error ? \"FAIL\" : \"PASS\");\n\n  free(vertex);\n  free(point);\n  free(bitmap_ref);\n  free(bitmap_opt);\n  return 0;\n}\n"}}
{"kernel_name": "layout", "parallel_api": "serial", "code": {"main.cpp": "\n\n\n\n#include <iostream>\n#include <stdlib.h>\n#include <string.h>\n#include <chrono>\n\n#define TREE_NUM 4096\n#define TREE_SIZE 4096\n#define GROUP_SIZE 256\n\nstruct AppleTree\n{\n  int apples[TREE_SIZE];\n};\n\nstruct ApplesOnTrees\n{\n  int trees[TREE_NUM];\n};\n\nint main(int argc, char * argv[])\n{\n  if (argc != 2) {\n    printf(\"Usage: %s <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  \n  const int iterations = atoi(argv[1]); \n\n  const int treeSize = TREE_SIZE;\n  const int treeNumber = TREE_NUM;\n  bool fail = false;\n\n  if(iterations < 1)\n  {\n    std::cout<<\"Iterations cannot be 0 or negative. Exiting..\\n\";\n    return -1;\n  }\n\n  if(treeNumber < GROUP_SIZE)\n  {\n    std::cout<<\"treeNumber should be larger than the work group size\"<<std::endl;\n    return -1;\n  }\n  if(treeNumber % 256 !=0)\n  {\n    std::cout<<\"treeNumber should be a multiple of 256\"<<std::endl;\n    return -1;\n  }\n\n  const int elements = treeSize * treeNumber;\n  size_t inputSize = elements * sizeof(int);\n  size_t outputSize = treeNumber * sizeof(int);\n\n  \n\n  int* data = (int*) malloc (inputSize);\n\n  \n\n  int *output = (int *)malloc(outputSize);\n\n  \n\n  int *reference = (int *)malloc(outputSize);\n  memset(reference,0,outputSize);\n  for(int i=0; i < treeNumber; i++)\n    for(int j=0; j < treeSize; j++)\n      reference[i] += i * treeSize + j;\n\n{\n  \n\n  for (int i = 0; i < treeNumber; i++)\n    for(int j = 0; j < treeSize; j++)\n      data[j + i* treeSize] = j + i* treeSize;\n\n  \n  AppleTree *trees = (AppleTree*) data;\n\n  auto start = std::chrono::steady_clock::now();\n\n  for (int n = 0; n < iterations; n++) {\n        for (uint gid = 0; gid < treeNumber; gid++) \n    {\n      uint res = 0;\n      for(int i = 0; i < treeSize; i++)\n      {\n        res += trees[gid].apples[i];\n      }\n      output[gid] = res;\n    }\n  }\n\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  std::cout << \"Average kernel execution time (AoS): \"\n            << (time * 1e-3f) / iterations << \" (us)\\n\";\n\n  \n  for(int i=0; i< treeNumber; i++)\n  {\n    if(output[i] != reference[i])\n    {\n      fail = true;\n      break;\n    }\n  }\n\n  if (fail)\n    std::cout << \"FAIL\\n\";\n  else\n    std::cout << \"PASS\\n\";\n\n  \n\n  for (int i = 0; i < treeNumber; i++)\n    for(int j = 0; j < treeSize; j++)\n      data[i + j* treeNumber] = j + i* treeSize;\n\n  \n  ApplesOnTrees *applesOnTrees = (ApplesOnTrees*) data;\n\n  start = std::chrono::steady_clock::now();\n\n  for (int n = 0; n < iterations; n++) {\n        for (uint gid = 0; gid < treeNumber; gid++) \n    {\n      uint res = 0;\n      for(int i = 0; i < treeSize; i++)\n      {\n        res += applesOnTrees[i].trees[gid];\n      }\n      output[gid] = res;\n    }\n  }\n\n  end = std::chrono::steady_clock::now();\n  time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  std::cout << \"Average kernel execution time (SoA): \"\n            << (time * 1e-3f) / iterations << \" (us)\\n\";\n\n  \n  for(int i=0; i< treeNumber; i++)\n  {\n    if(output[i] != reference[i])\n    {\n      fail = true;\n      break;\n    }\n  }\n\n  if (fail)\n    std::cout << \"FAIL\\n\";\n  else\n    std::cout << \"PASS\\n\";\n\n}\n\n  free(output);\n  free(reference);\n  free(data);\n  return 0;\n}\n"}}
{"kernel_name": "matrix-rotate", "parallel_api": "serial", "code": {"main.cpp": "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <chrono>\n\nvoid rotate_matrix_parallel (float *matrix, const int n, const int repeat) {\n    {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++) {\n            for (int layer = 0; layer < n / 2; ++layer) {\n        int first = layer;\n        int last = n - 1 - layer;\n        for(int i = first; i < last; ++i) {\n          int offset = i - first;\n\n          float top = matrix[first*n+i]; \n\n          \n\n          matrix[first*n+i] = matrix[(last-offset)*n+first];\n\n          \n\n          matrix[(last-offset)*n+first] = matrix[last*n+(last-offset)];\n\n          \n\n          matrix[last*n+(last-offset)] = matrix[i*n+last];\n\n          \n\n          matrix[i*n+last] = top; \n\n        }\n      }\n    }\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time: %f (s)\\n\", (time * 1e-9f) / repeat);\n  }\n}\n\nvoid rotate_matrix_serial(float *matrix, const int n) {\n  for (int layer = 0; layer < n / 2; ++layer) {\n    int first = layer;\n    int last = n - 1 - layer;\n    for(int i = first; i < last; ++i) {\n      int offset = i - first;\n        float top = matrix[first*n+i]; \n\n        \n\n        matrix[first*n+i] = matrix[(last-offset)*n+first];\n\n        \n\n        matrix[(last-offset)*n+first] = matrix[last*n+(last-offset)];\n\n        \n\n        matrix[last*n+(last-offset)] = matrix[i*n+last];\n\n        \n\n        matrix[i*n+last] = top; \n\n    }\n  }\n}\n\nint main(int argc, char** argv) {\n  if (argc != 3) {\n    printf(\"Usage: %s <matrix size> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  const int n = atoi(argv[1]);\n  const int repeat = atoi(argv[2]);\n\n  float *serial_res = (float*) aligned_alloc(1024, n*n*sizeof(float));\n  float *parallel_res = (float*) aligned_alloc(1024, n*n*sizeof(float));\n\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++)\n      serial_res[i*n+j] = parallel_res[i*n+j] = i*n+j;\n\n  for (int i = 0; i < repeat; i++) {\n    rotate_matrix_serial(serial_res, n);\n  }\n\n  rotate_matrix_parallel (parallel_res, n, repeat);\n\n  bool ok = true;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (serial_res[i*n+j] != parallel_res[i*n+j]) {\n        ok = false;\n        break;\n      }\n    }\n  }\n\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n\n  free(serial_res);\n  free(parallel_res);\n  return 0;\n}"}}
{"kernel_name": "pathfinder", "parallel_api": "serial", "code": {"main.cpp": "\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n#include <iostream>\n#include <sys/time.h>\n#include <string.h>\n\nusing namespace std;\n\n\n\n#define HALO     1\n#define STR_SIZE 256\n#define DEVICE   0\n#define M_SEED   9\n#define IN_RANGE(x, min, max)  ((x)>=(min) && (x)<=(max))\n#define CLAMP_RANGE(x, min, max) x = (x<(min)) ? min : ((x>(max)) ? max : x )\n#define MIN(a, b) ((a)<=(b) ? (a) : (b))\n\n\nvoid fatal(char *s)\n{\n  fprintf(stderr, \"error: %s\\n\", s);\n}\n\ndouble get_time() {\n  struct timeval t;\n  gettimeofday(&t,NULL);\n  return t.tv_sec+t.tv_usec*1e-6;\n}\n\nint main(int argc, char** argv)\n{\n  \n\n  int   rows, cols;\n  int*  data;\n  int** wall;\n  int*  result;\n  int   pyramid_height;\n\n  if (argc == 4)\n  {\n    cols = atoi(argv[1]);\n    rows = atoi(argv[2]);\n    pyramid_height = atoi(argv[3]);\n  }\n  else\n  {\n    printf(\"Usage: %s <column length> <row length> <pyramid_height>\\n\", argv[0]);\n\n    exit(0);\n  }\n\n  data = new int[rows * cols];\n  wall = new int*[rows];\n  for (int n = 0; n < rows; n++)\n  {\n    \n\n    wall[n] = data + cols * n;\n  }\n  result = new int[cols];\n\n  int seed = M_SEED;\n  srand(seed);\n\n  for (int i = 0; i < rows; i++)\n  {\n    for (int j = 0; j < cols; j++)\n    {\n      wall[i][j] = rand() % 10;\n    }\n  }\n#ifdef BENCH_PRINT\n  for (int i = 0; i < rows; i++)\n  {\n    for (int j = 0; j < cols; j++)\n    {\n      printf(\"%d \", wall[i][j]);\n    }\n    printf(\"\\n\");\n  }\n#endif\n\n  \n\n  const int borderCols = (pyramid_height) * HALO;\n\n  \n\n\n  const int size = rows * cols;  \n\n  const int lws = 250;\n  const int gws = size/lws;  \n\n  int theHalo = HALO;\n  int* outputBuffer = (int*)calloc(16384, sizeof(int));\n\n  double offload_start = get_time();\n\n  \n\n  int* gpuWall = data+cols;\n  \n\n  \n\n  int* gpuSrc = (int*) malloc (sizeof(int)*cols);\n  int* gpuResult = (int*) malloc (sizeof(int)*cols);\n  memcpy(gpuSrc, data, cols*sizeof(int));\n\n  {\n    double kstart = 0.0;\n\n    for (int t = 0; t < rows - 1; t += pyramid_height)\n    {\n      if (t == pyramid_height) {\n        kstart = get_time();\n      }\n\n      \n\n      int iteration = MIN(pyramid_height, rows-t-1);\n\n            {\n        int prev[lws];\n        int result[lws];\n                {\n          \n\n          int BLOCK_SIZE = omp_get_num_threads();\n          int bx = omp_get_team_num();\n          int tx = omp_get_thread_num();\n\n          \n\n          \n\n          \n\n          \n\n\n          \n\n          int small_block_cols = BLOCK_SIZE - (iteration*theHalo*2);\n\n          \n\n          \n\n          int blkX = (small_block_cols*bx) - borderCols;\n          int blkXmax = blkX+BLOCK_SIZE-1;\n\n          \n\n          int xidx = blkX+tx;\n\n          \n\n          \n\n          \n\n          int validXmin = (blkX < 0) ? -blkX : 0;\n          int validXmax = (blkXmax > cols-1) ? BLOCK_SIZE-1-(blkXmax-cols+1) : BLOCK_SIZE-1;\n\n          int W = tx-1;\n          int E = tx+1;\n\n          W = (W < validXmin) ? validXmin : W;\n          E = (E > validXmax) ? validXmax : E;\n\n          bool isValid = IN_RANGE(tx, validXmin, validXmax);\n\n          if(IN_RANGE(xidx, 0, cols-1))\n          {\n            prev[tx] = gpuSrc[xidx];\n          }\n\n          \n          bool computed;\n          for (int i = 0; i < iteration; i++)\n          {\n            computed = false;\n\n            if( IN_RANGE(tx, i+1, BLOCK_SIZE-i-2) && isValid )\n            {\n              computed = true;\n              int left = prev[W];\n              int up = prev[tx];\n              int right = prev[E];\n              int shortest = MIN(left, up);\n              shortest = MIN(shortest, right);\n\n              int index = cols*(t+i)+xidx;\n              result[tx] = shortest + gpuWall[index];\n\n              \n\n              \n\n              if (tx==11 && i==0)\n              {\n                \n\n                int bufIndex = gpuSrc[xidx];\n                \n\n                outputBuffer[bufIndex] = 1;\n              }\n              \n\n            }\n\n            \n            if(i==iteration-1)\n            {\n              \n\n              \n\n              break;\n            }\n\n            if(computed)\n            {\n              \n\n              prev[tx] = result[tx];\n            }\n                      }\n\n          \n\n          \n\n          \n\n          if (computed)\n          {\n            gpuResult[xidx] = result[tx];\n          }\n        }\n      } \n      int *temp = gpuResult;\n      gpuResult = gpuSrc;\n      gpuSrc = temp;\n    }\n\n    double kend = get_time();\n    printf(\"Total kernel execution time: %lf (s)\\n\", kend - kstart);\n\n      }\n\n  double offload_end = get_time();\n  printf(\"Device offloading time = %lf(s)\\n\", offload_end - offload_start);\n\n  \n\n  outputBuffer[16383] = '\\0';\n\n#ifdef BENCH_PRINT\n  for (int i = 0; i < cols; i++)\n    printf(\"%d \", data[i]);\n  printf(\"\\n\");\n  for (int i = 0; i < cols; i++)\n    printf(\"%d \", gpuSrc[i]);\n  printf(\"\\n\");\n#endif\n\n  \n\n  delete[] data;\n  delete[] wall;\n  delete[] result;\n  free(outputBuffer);\n  free(gpuSrc);\n  free(gpuResult);\n\n  return EXIT_SUCCESS;\n}"}}
{"kernel_name": "randomAccess", "parallel_api": "serial", "code": {"main.cpp": "#include <stdio.h>\n#include <stdlib.h>\n#include <chrono>\n\ntypedef unsigned long long int u64Int;\ntypedef long long int s64Int;\n\n\n\n#define POLY 0x0000000000000007UL\n#define PERIOD 1317624576693539401L\n\n#define NUPDATE (4 * TableSize)\n\nu64Int\nHPCC_starts(s64Int n)\n{\n  int i, j;\n  u64Int m2[64];\n  u64Int temp, ran;\n\n  while (n < 0) n += PERIOD;\n  while (n > PERIOD) n -= PERIOD;\n  if (n == 0) return 0x1;\n\n  temp = 0x1;\n\n    for (i=0; i<64; i++) {\n    m2[i] = temp;\n    temp = (temp << 1) ^ ((s64Int) temp < 0 ? POLY : 0);\n    temp = (temp << 1) ^ ((s64Int) temp < 0 ? POLY : 0);\n  }\n\n  for (i=62; i>=0; i--)\n    if ((n >> i) & 1)\n      break;\n\n  ran = 0x2;\n  while (i > 0) {\n    temp = 0;\n        for (j=0; j<64; j++)\n      if ((ran >> j) & 1)\n        temp ^= m2[j];\n    ran = temp;\n    i -= 1;\n    if ((n >> i) & 1)\n      ran = (ran << 1) ^ ((s64Int) ran < 0 ? POLY : 0);\n  }\n\n  return ran;\n}\n\n\nint main(int argc, char** argv) {\n  if (argc != 2) {\n    printf(\"Usage: %s <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  const int repeat = atoi(argv[1]);\n\n  int failure;\n  u64Int i;\n  u64Int temp;\n  double totalMem;\n  u64Int *Table = NULL;\n  u64Int logTableSize, TableSize;\n\n  \n\n  totalMem = 1024*1024*512;\n  totalMem /= sizeof(u64Int);\n\n  \n\n  for (totalMem *= 0.5, logTableSize = 0, TableSize = 1;\n       totalMem >= 1.0;\n       totalMem *= 0.5, logTableSize++, TableSize <<= 1)\n    ; \n\n\n   printf(\"Table size = %llu\\n\",  TableSize);\n\n   posix_memalign((void**)&Table, 1024, TableSize * sizeof(u64Int));\n\n  if (! Table ) {\n    fprintf( stderr, \"Failed to allocate memory for the update table %llu\\n\", TableSize);\n    return 1;\n  }\n\n  \n\n  fprintf(stdout, \"Main table size   = 2^%llu = %llu words\\n\", logTableSize,TableSize);\n  fprintf(stdout, \"Number of updates = %llu\\n\", NUPDATE);\n\n  u64Int ran[128];\n\n{\n  auto start = std::chrono::steady_clock::now();\n\n  for (int i = 0; i < repeat; i++) {\n    \n\n        for (i=0; i<TableSize; i++) {\n      Table[i] = i;\n    }\n        for (int j=0; j<128; j++)\n      ran[j] = HPCC_starts ((NUPDATE/128) * j);\n\n        for (int j=0; j<128; j++) {\n      for (u64Int i=0; i<NUPDATE/128; i++) {\n        ran[j] = (ran[j] << 1) ^ ((s64Int) ran[j] < 0 ? POLY : 0);\n                Table[ran[j] & (TableSize-1)] ^= ran[j];\n      }\n    }\n  }\n\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Average kernel execution time: %f (s)\\n\", (time * 1e-9f) / repeat);\n\n}\n\n  \n\n  temp = 0x1;\n  for (i=0; i<NUPDATE; i++) {\n    temp = (temp << 1) ^ (((s64Int) temp < 0) ? POLY : 0);\n    Table[temp & (TableSize-1)] ^= temp;\n  }\n  \n  temp = 0;\n  for (i=0; i<TableSize; i++)\n    if (Table[i] != i) {\n      temp++;\n    }\n\n  fprintf( stdout, \"Found %llu errors in %llu locations (%s).\\n\",\n           temp, TableSize, (temp <= 0.01*TableSize) ? \"passed\" : \"failed\");\n  if (temp <= 0.01*TableSize) failure = 0;\n  else failure = 1;\n\n  free( Table );\n  return failure;\n\n}\n"}}
{"kernel_name": "bsearch", "parallel_api": "serial", "code": {"main.cpp": "#include <cstdlib>\n#include <chrono>\n#include <iostream>\n\n#ifndef Real_t \n#define Real_t float\n#endif\n\ntemplate <typename T>\nvoid bs ( const size_t aSize,\n    const size_t zSize,\n    const T *acc_a,  \n\n    const T *acc_z,  \n\n    size_t *acc_r,  \n\n    const size_t n,\n    const int repeat )\n{\n  auto start = std::chrono::steady_clock::now();\n  for (int i= 0; i < repeat; i++) {\n        for (int i = 0; i < zSize; i++) { \n      T z = acc_z[i];\n      size_t low = 0;\n      size_t high = n;\n      while (high - low > 1) {\n        size_t mid = low + (high - low)/2;\n        if (z < acc_a[mid])\n          high = mid;\n        else\n          low = mid;\n      }\n      acc_r[i] = low;\n    }\n  }\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  std::cout << \"Average device execution time (bs1) \" << (time * 1e-9f) / repeat << \" (s)\\n\";\n}\n\ntemplate <typename T>\nvoid bs2 ( const size_t aSize,\n    const size_t zSize,\n    const T *acc_a,  \n\n    const T *acc_z,  \n\n    size_t *acc_r,  \n\n    const size_t n,\n    const int repeat )\n{\n  auto start = std::chrono::steady_clock::now();\n  for (int i= 0; i < repeat; i++) {\n        for (int i = 0; i < zSize; i++) { \n      unsigned  nbits = 0;\n      while (n >> nbits) nbits++;\n      size_t k = 1ULL << (nbits - 1);\n      T z = acc_z[i];\n      size_t idx = (acc_a[k] <= z) ? k : 0;\n      while (k >>= 1) {\n        size_t r = idx | k;\n        if (r < n && z >= acc_a[r]) { \n          idx = r;\n        }\n      }\n      acc_r[i] = idx;\n    }\n  }\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  std::cout << \"Average device execution time (bs2) \" << (time * 1e-9f) / repeat << \" (s)\\n\";\n}\n\ntemplate <typename T>\nvoid bs3 ( const size_t aSize,\n    const size_t zSize,\n    const T *acc_a,  \n\n    const T *acc_z,  \n\n    size_t *acc_r,  \n\n    const size_t n,\n    const int repeat )\n{\n  auto start = std::chrono::steady_clock::now();\n  for (int i= 0; i < repeat; i++) {\n        for (int i = 0; i < zSize; i++) { \n      unsigned nbits = 0;\n      while (n >> nbits) nbits++;\n      size_t k = 1ULL << (nbits - 1);\n      T z = acc_z[i];\n      size_t idx = (acc_a[k] <= z) ? k : 0;\n      while (k >>= 1) {\n        size_t r = idx | k;\n        size_t w = r < n ? r : n; \n        if (z >= acc_a[w]) { \n          idx = r;\n        }\n      }\n      acc_r[i] = idx;\n    }\n  }\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  std::cout << \"Average device execution time (bs3) \" << (time * 1e-9f) / repeat << \" (s)\\n\";\n}\n\ntemplate <typename T>\nvoid bs4 ( const size_t aSize,\n    const size_t zSize,\n    const T *acc_a,  \n\n    const T *acc_z,  \n\n    size_t *acc_r,  \n\n    const size_t n,\n    const int repeat )\n{\n  auto start = std::chrono::steady_clock::now();\n  for (int i= 0; i < repeat; i++) {\n        {\n      size_t k;\n            {\n        size_t lid = omp_get_thread_num();\n        size_t gid = omp_get_team_num()*omp_get_num_threads()+lid;\n        if (lid == 0) {\n          unsigned nbits = 0;\n          while (n >> nbits) nbits++;\n          k = 1ULL << (nbits - 1);\n        }\n        \n        size_t p = k;\n        T z = acc_z[gid];\n        size_t idx = (acc_a[p] <= z) ? p : 0;\n        while (p >>= 1) {\n          size_t r = idx | p;\n          size_t w = r < n ? r : n;\n          if (z >= acc_a[w]) { \n            idx = r;\n          }\n        }\n        acc_r[gid] = idx;\n      }\n    }\n  }\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  std::cout << \"Average device execution time (bs4) \" << (time * 1e-9f) / repeat << \" (s)\\n\";\n}\n\n#ifdef DEBUG\nvoid verify(Real_t *a, Real_t *z, size_t *r, size_t aSize, size_t zSize, std::string msg)\n{\n  for (size_t i = 0; i < zSize; ++i)\n  {\n    \n\n    if (!(r[i]+1 < aSize && a[r[i]] <= z[i] && z[i] < a[r[i] + 1]))\n    {\n      std::cout << msg << \": incorrect result:\" << std::endl;\n      std::cout << \"index = \" << i << \" r[index] = \" << r[i] << std::endl;\n      std::cout << a[r[i]] << \" <= \" << z[i] << \" < \" << a[r[i] + 1] << std::endl;\n      break;\n    }\n    \n\n    r[i] = 0xFFFFFFFF;\n  }\n}\n#endif\n\nint main(int argc, char* argv[])\n{\n  if (argc != 3) {\n    std::cout << \"Usage ./main <number of elements> <repeat>\\n\";\n    return 1;\n  }\n\n  size_t numElem = atol(argv[1]);\n  uint repeat = atoi(argv[2]);\n\n  srand(2);\n  size_t aSize = numElem;\n  size_t zSize = 2*aSize;\n  Real_t *a = NULL;\n  Real_t *z = NULL;\n  size_t *r = NULL;\n  posix_memalign((void**)&a, 1024, aSize * sizeof(Real_t));\n  posix_memalign((void**)&z, 1024, zSize * sizeof(Real_t));\n  posix_memalign((void**)&r, 1024, zSize * sizeof(size_t));\n\n  size_t N = aSize-1;\n\n  \n\n  for (size_t i = 0; i < aSize; i++) a[i] = i;\n\n  \n\n  for (size_t i = 0; i < zSize; i++) { \n    z[i] = rand() % N;\n  }\n\n    {\n    bs(aSize, zSize, a, z, r, N, repeat);\n  \n  #ifdef DEBUG\n        verify(a, z, r, aSize, zSize, \"bs1\");\n  #endif\n  \n    bs2(aSize, zSize, a, z, r, N, repeat);\n  \n  #ifdef DEBUG\n        verify(a, z, r, aSize, zSize, \"bs2\");\n  #endif\n  \n    bs3(aSize, zSize, a, z, r, N, repeat);\n  \n  #ifdef DEBUG\n        verify(a, z, r, aSize, zSize, \"bs3\");\n  #endif\n  \n    bs4(aSize, zSize, a, z, r, N, repeat);\n  \n  #ifdef DEBUG\n        verify(a, z, r, aSize, zSize, \"bs4\");\n  #endif\n  }\n\n  free(a);\n  free(z);\n  free(r);\n  return 0;\n}"}}
{"kernel_name": "colorwheel", "parallel_api": "serial", "code": {"main.cpp": "#include <chrono>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n\n\n\n\n\n\n\n\n\n\n\n#define RY  15\n#define YG  6\n#define GC  4\n#define CB  11\n#define BM  13\n#define MR  6\n#define MAXCOLS  (RY + YG + GC + CB + BM + MR)\ntypedef unsigned char uchar;\n\nvoid setcols(int cw[MAXCOLS][3], int r, int g, int b, int k)\n{\n  cw[k][0] = r;\n  cw[k][1] = g;\n  cw[k][2] = b;\n}\n\nvoid computeColor(float fx, float fy, uchar *pix)\n{\n  int cw[MAXCOLS][3];  \n\n\n  \n\n  \n\n  \n\n  \n\n  int i;\n  int k = 0;\n  for (i = 0; i < RY; i++) setcols(cw, 255,     255*i/RY,   0,       k++);\n  for (i = 0; i < YG; i++) setcols(cw, 255-255*i/YG, 255,     0,     k++);\n  for (i = 0; i < GC; i++) setcols(cw, 0,       255,     255*i/GC,   k++);\n  for (i = 0; i < CB; i++) setcols(cw, 0,       255-255*i/CB, 255,   k++);\n  for (i = 0; i < BM; i++) setcols(cw, 255*i/BM,     0,     255,     k++);\n  for (i = 0; i < MR; i++) setcols(cw, 255,     0,     255-255*i/MR, k++);\n\n  float rad = sqrtf(fx * fx + fy * fy);\n  float a = atan2f(-fy, -fx) / (float)M_PI;\n  float fk = (a + 1.f) / 2.f * (MAXCOLS-1);\n  int k0 = (int)fk;\n  int k1 = (k0 + 1) % MAXCOLS;\n  float f = fk - k0;\n  for (int b = 0; b < 3; b++) {\n    float col0 = cw[k0][b] / 255.f;\n    float col1 = cw[k1][b] / 255.f;\n    float col = (1.f - f) * col0 + f * col1;\n    if (rad <= 1)\n      col = 1.f - rad * (1.f - col); \n\n    else\n      col *= .75f; \n\n    pix[2 - b] = (int)(255.f * col);\n  }\n}\n\nint main(int argc, char **argv)\n{\n  if (argc != 4) {\n    printf(\"Usage: %s <range> <size> <repeat>\\n\", argv[0]);\n    exit(1);\n  }\n  const float truerange = atof(argv[1]);\n  const int size = atoi(argv[2]);\n  const int repeat = atoi(argv[3]);\n\n  \n\n  float range = 1.04f * truerange;\n\n  const int half_size = size/2;\n\n  \n\n  size_t imgSize = size * size * 3;\n  uchar* pix = (uchar*) malloc (imgSize);\n  uchar* res = (uchar*) malloc (imgSize);\n\n  memset(pix, 0, imgSize);\n\n  for (int y = 0; y < size; y++) {\n    for (int x = 0; x < size; x++) {\n      float fx = (float)x / (float)half_size * range - range;\n      float fy = (float)y / (float)half_size * range - range;\n      if (x == half_size || y == half_size) continue; \n\n      size_t idx = (y * size + x) * 3;\n      computeColor(fx/truerange, fy/truerange, pix+idx);\n    }\n  }\n\n  printf(\"Start execution on a device\\n\");\n  uchar *d_pix = (uchar*) malloc(imgSize);\n  memset(d_pix, 0, imgSize);\n\n    {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++) {\n            for (int y = 0; y < size; y++) {\n        for (int x = 0; x < size; x++) {\n          float fx = (float)x / (float)half_size * range - range;\n          float fy = (float)y / (float)half_size * range - range;\n          if (x != half_size && y != half_size) {\n            size_t idx = (y * size + x) * 3;\n            computeColor(fx/truerange, fy/truerange, d_pix+idx);\n          }\n        }\n      }\n    }\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time : %f (ms)\\n\", (time * 1e-6f) / repeat);\n  }\n\n  \n\n  int fail = memcmp(pix, d_pix, imgSize);\n  if (fail) {\n    int max_error = 0;\n    for (size_t i = 0; i < imgSize; i++) {\n       int e = abs(d_pix[i] - pix[i]);\n       if (e > max_error) max_error = e;\n    }\n    printf(\"Maximum error between host and device results: %d\\n\", max_error);\n  }\n  else {\n    printf(\"%s\\n\", \"PASS\");\n  }\n  \n  free(d_pix);\n  free(pix);\n  free(res);\n  return 0;\n}"}}
{"kernel_name": "dense-embedding", "parallel_api": "serial", "code": {"main.cpp": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <chrono>\n#include <random>\n\ntemplate <typename T>\nvoid reference(\n    const T* input,\n    const T* dense,\n    T* output,\n    int embedding_dim,\n    int batch_size,\n    const int* offset)\n{\n  for (int batch_idx = 0; batch_idx < batch_size; batch_idx++) {\n    const int range = offset[batch_idx + 1] - offset[batch_idx];\n    for (int idx = 0; idx < embedding_dim; idx++) {\n      const T dense_elem = dense[batch_idx * embedding_dim + idx];\n      for (int nested_idx = idx; nested_idx < range; nested_idx += embedding_dim) {\n        output[offset[batch_idx] + nested_idx] =\n          input[offset[batch_idx] + nested_idx] + dense_elem;\n      }\n    }\n  }\n}\n\nint main(int argc, char* argv[])\n{\n  if (argc != 4) {\n    printf(\"Usage: %s <number of rows> <batch size> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  const int nrows = atoi(argv[1]);\n  const int batch_size = atoi(argv[2]);\n  const int repeat = atoi(argv[3]);\n  assert(nrows > batch_size * batch_size);\n\n  printf(\"Number of rows in the embedding table: %d\\n\", nrows);\n  printf(\"Batch size: %d\\n\", batch_size);\n\n  const int embed_dims[] = {768, 2048, 12288};\n\n  for (size_t n = 0; n < sizeof(embed_dims)/sizeof(int); n++) {\n    int ncols = embed_dims[n];\n    printf(\"\\nEmbedding dimension: %d\\n\", ncols);\n\n    int input_size = nrows * ncols;  \n\n    size_t input_size_bytes = input_size * sizeof(float);\n\n    int dense_size = batch_size * ncols ;\n    int dense_size_bytes = dense_size * sizeof(float);\n\n    int batch_size_bytes = (batch_size + 1) * sizeof(float);\n\n    float *input, *dense, *output_k1, *output_k2, *output_ref;\n    input = (float*) malloc (input_size_bytes); \n\n    dense = (float*) malloc (dense_size_bytes); \n\n    output_k1 = (float*) malloc (input_size_bytes); \n\n    output_k2 = (float*) malloc (input_size_bytes); \n\n    output_ref = (float*) malloc (input_size_bytes); \n\n    int *offset = (int*) malloc (batch_size_bytes);  \n\n\n    \n\n    \n\n    \n\n    \n\n    srand(123);\n    offset[0] = 0;\n    for (int i = 1; i <= batch_size; i++)\n      offset[i] = offset[i-1] + (rand() % batch_size + 1) * ncols;\n\n    std::default_random_engine g (123);\n    std::uniform_real_distribution<float> distr (-1.f, 1.f);\n    for (int i = 0; i < dense_size; i++) {\n      dense[i] = distr(g);\n    }\n\n    for (int i = 0; i < input_size; i++) {\n      input[i] = distr(g);\n      output_k1[i] = output_k2[i] = output_ref[i] = 0;\n    }\n\n    reference(input, dense, output_ref, ncols, batch_size, offset);\n\n        {\n      for (int block_size = 128; block_size <= 1024; block_size = block_size * 2) {\n        printf(\"block size: %d\\n\", block_size);\n\n        auto start = std::chrono::steady_clock::now();\n\n        for (int i = 0; i < repeat; i++) {\n                    {\n                        {\n              const int batch_idx  = omp_get_team_num(); \n\n              const int grain_size = omp_get_num_threads();\n              const int tid = omp_get_thread_num();\n              const int range = offset[batch_idx + 1] - offset[batch_idx];\n              for (int idx = tid; idx < ncols; idx += grain_size) {\n                const auto dense_elem = dense[batch_idx * ncols + idx];\n                for (int nested_idx = idx; nested_idx < range; nested_idx += ncols) {\n                  output_k1[offset[batch_idx] + nested_idx] = input[offset[batch_idx] + nested_idx] + dense_elem;\n                }\n              }\n            }\n          }\n        }\n\n        auto end = std::chrono::steady_clock::now();\n        auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n        printf(\"Average execution time of dense embedding kernel (k1): %f (us)\\n\", (time * 1e-3f) / repeat);\n\n        \n        start = std::chrono::steady_clock::now();\n\n        for (int i = 0; i < repeat; i++) {\n                    {\n                        {\n              const int batch_idx  = omp_get_team_num(); \n\n              const int start = offset[batch_idx];\n              const int range = offset[batch_idx + 1] - start;\n              for (int idx = omp_get_thread_num(); idx < ncols; idx += omp_get_num_threads()) {\n                const auto dense_elem = dense[batch_idx * ncols + idx];\n                for (int nested_idx = idx; nested_idx < range; nested_idx += ncols) {\n                  output_k2[start + nested_idx] = input[start + nested_idx] + dense_elem;\n                }\n              }\n            }\n          }\n        }\n\n        end = std::chrono::steady_clock::now();\n        time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n        printf(\"Average execution time of dense embedding kernel (k2): %f (us)\\n\", (time * 1e-3f) / repeat);\n\n        \n        bool ok = true;\n        for (int i = 0; i < input_size; i++) {\n          if (fabsf(output_k1[i] - output_ref[i]) > 1e-3f ||\n              fabsf(output_k2[i] - output_ref[i]) > 1e-3f) {\n            ok = false;\n            break;\n          }\n        }\n        printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n      }\n    }\n\n    free(input);\n    free(dense);\n    free(output_k1);\n    free(output_k2);\n    free(output_ref);\n    free(offset);\n  }\n\n  return 0;\n}"}}
{"kernel_name": "entropy", "parallel_api": "serial", "code": {"main.cpp": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <chrono>\n#include \"reference.h\"\n\nvoid entropy(\n      float *__restrict d_entropy,\n  const char*__restrict d_val, \n  int height, int width)\n{\n    for (int y = 0; y < height; y++) {\n    for (int x = 0; x < width; x++) {\n      \n\n      char count[16];\n      for (int i = 0; i < 16; i++) count[i] = 0;\n\n      \n\n      char total = 0;\n\n      \n\n      for(int dy = -2; dy <= 2; dy++) {\n        for(int dx = -2; dx <= 2; dx++) {\n          int xx = x + dx;\n          int yy = y + dy;\n          if(xx >= 0 && yy >= 0 && yy < height && xx < width) {\n            count[d_val[yy * width + xx]]++;\n            total++;\n          }\n        }\n      }\n\n      float entropy = 0;\n      if (total < 1) {\n        total = 1;\n      } else {\n        for(int k = 0; k < 16; k++) {\n          float p = (float)count[k] / (float)total;\n          entropy -= p * log2f(p);\n        }\n      }\n\n      d_entropy[y * width + x] = entropy;\n    }\n  }\n}\n\ntemplate<int bsize_x, int bsize_y>\nvoid entropy_opt(\n       float *__restrict d_entropy,\n  const  char*__restrict d_val, \n  const float*__restrict d_logTable,\n  int m, int n)\n{\n  const int teamX = (n+bsize_x-1)/bsize_x;\n  const int teamY = (m+bsize_y-1)/bsize_y;\n  const int numTeams = teamX * teamY;\n\n    {\n    int sd_count[16][bsize_x*bsize_y];\n        {\n      const int threadIdx_x = omp_get_num_threads() % bsize_x;\n      const int threadIdx_y = omp_get_num_threads() / bsize_x;\n      const int teamIdx_x = omp_get_num_teams() % teamX;\n      const int teamIdx_y = omp_get_num_teams() / teamX;\n      const int x = teamIdx_x * bsize_x + threadIdx_x;\n      const int y = teamIdx_y * bsize_y + threadIdx_y;\n\n      const int idx = threadIdx_y*bsize_x + threadIdx_x;\n\n      for(int i = 0; i < 16; i++) sd_count[i][idx] = 0;\n\n      char total = 0;\n      for(int dy = -2; dy <= 2; dy++) {\n        for(int dx = -2; dx <= 2; dx++) {\n          int xx = x + dx,\n              yy = y + dy;\n\n          if(xx >= 0 && yy >= 0 && yy < m && xx < n) {\n            sd_count[d_val[yy*n+xx]][idx]++;\n            total++;\n          }\n        }\n      }\n\n      float entropy = 0;\n      for(int k = 0; k < 16; k++)\n        entropy -= d_logTable[sd_count[k][idx]];\n      \n      entropy = entropy / total + log2f(total);\n      if(y < m && x < n) d_entropy[y*n+x] = entropy;\n    }\n  }\n}\n\nint main(int argc, char* argv[]) {\n  if (argc != 4) {\n    printf(\"Usage: %s <width> <height> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  const int width = atoi(argv[1]); \n  const int height = atoi(argv[2]); \n  const int repeat = atoi(argv[3]); \n\n  const int input_bytes = width * height * sizeof(char);\n  const int output_bytes = width * height * sizeof(float);\n  char* input = (char*) malloc (input_bytes);\n  float* output = (float*) malloc (output_bytes);\n  float* output_ref = (float*) malloc (output_bytes);\n\n  float logTable[26];\n  for (int i = 0; i <= 25; i++) logTable[i] = i <= 1 ? 0 : i*log2f(i);\n\n  srand(123);\n  for (int i = 0; i < height; i++)\n    for (int j = 0; j < width; j++)\n      input[i * width + j] = rand() % 16;\n\n    {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      entropy(output, input, height, width);\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel (baseline) execution time %f (s)\\n\", (time * 1e-9f) / repeat);\n\n    start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      entropy_opt<16, 16>(output, input, logTable, height, width);\n\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel (optimized) execution time %f (s)\\n\", (time * 1e-9f) / repeat);\n  }\n\n  \n\n  reference(output_ref, input, height, width);\n\n  bool ok = true;\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      if (fabsf(output[i * width + j] - output_ref[i * width + j]) > 1e-3f) {\n        ok = false; \n        break;\n      }\n    }\n    if (!ok) break;\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n \n  free(input);\n  free(output);\n  free(output_ref);\n  return 0;\n}"}}
